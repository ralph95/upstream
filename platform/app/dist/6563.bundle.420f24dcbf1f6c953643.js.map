{"version":3,"file":"6563.bundle.420f24dcbf1f6c953643.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js"],"sourcesContent":["function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n","import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey) {\n            return kb.ShiftCtrl;\n        }\n        if (evt.altKey) {\n            return kb.ShiftAlt;\n        }\n        if (evt.metaKey) {\n            return kb.ShiftMeta;\n        }\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey) {\n            return kb.CtrlAlt;\n        }\n        if (evt.metaKey) {\n            return kb.CtrlMeta;\n        }\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n","import { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { setAnnotationManager } from './annotationState';\nconst defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nsetAnnotationManager(defaultManager);\nexport function resetAnnotationManager() {\n    setAnnotationManager(defaultManager);\n}\n","const checkAndDefineTextBoxProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.handles) {\n        annotation.data.handles = {};\n    }\n    if (!annotation.data.handles.textBox) {\n        annotation.data.handles.textBox = {};\n    }\n    return annotation;\n};\nconst checkAndDefineCachedStatsProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.cachedStats) {\n        annotation.data.cachedStats = {};\n    }\n    return annotation;\n};\nexport { checkAndDefineTextBoxProperty, checkAndDefineCachedStatsProperty };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationAdded(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_ADDED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationModified(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {\n    const eventDetail = {\n        segmentationId,\n        type,\n        viewportId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {\n    const eventDetail = {\n        viewportId,\n        segmentationId,\n        type,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\n","import { getSegmentationRepresentation } from '../getSegmentationRepresentation';\nexport function internalGetHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\n","import { state } from '../state';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i]) {\n                continue;\n            }\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { getInterpolatedPoints, shouldSmooth, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        annotation,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;\n    this.createMemo(element, annotation);\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    if (annotation.autoGenerated) {\n        annotation.autoGenerated = false;\n    }\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n        annotation,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = getArea(pointSet1);\n    const areaPointSet2 = getArea(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration, annotation)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        if (annotation.autoGenerated) {\n            annotation.autoGenerated = false;\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { ChangeTypes, Events } from '../../../enums';\nimport { state } from '../../../store/state';\nimport { vec3 } from 'gl-matrix';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../../stateManagement/annotation/helpers/state';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n        this.configuration.contourHoleAdditionModifierKey;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};\n    if (!spacing || !xDir || !yDir) {\n        return;\n    }\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n        contourHoleProcessingEnabled,\n        newAnnotation: true,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;\n    this.createMemo(element, annotation, { newAnnotation });\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n        annotation.invalidated = true;\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    if (annotation.invalidated) {\n        triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n    }\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.doneEditMemo();\n    this.drawData.newAnnotation = false;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction completeDrawClosedContour(element, options) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n    if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n        return false;\n    }\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    if (!textBox?.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        if (indexToRemoveUpTo === 1) {\n            this.drawData.canvasPoints = canvasPoints.splice(1);\n        }\n        else {\n            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n        }\n    }\n}\nfunction completeDrawOpenContour(element, options) {\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled } = options ?? {};\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: false,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    if (!textBox.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    const remainingPoints = canvasPoints.slice(crossingIndex);\n    const newArea = polyline.getArea(remainingPoints);\n    if (utilities.isEqual(newArea, 0)) {\n        canvasPoints.splice(crossingIndex + 1);\n        return;\n    }\n    canvasPoints.splice(0, crossingIndex);\n    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n    if (this.completeDrawClosedContour(element, options)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this.doneEditMemo();\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    this.createMemo(element, this.commonData.annotation);\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    triggerAnnotationModified(annotation, element);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.doneEditMemo();\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: false,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        const worldPoints = annotation.data.contour.polyline;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle?.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawPath as drawPathSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport getContourHolesDataCanvas from '../../../utilities/contours/getContourHolesDataCanvas';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n    });\n    const { closed: isClosedContour } = annotation.data.contour;\n    const options = {\n        color,\n        width: lineWidth,\n        lineDash,\n        fillColor,\n        fillOpacity,\n        closePath: isClosedContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.contour.closed) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n    else {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [canvasPolyline, ...childContours];\n    const polylineUID = '1';\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { openUShapeContourVectorToPeak } = annotation.data;\n    const { polyline } = annotation.data.contour;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.closePath = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [fusedCanvasPoints, ...childContours];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    if (annotation.parentAnnotationUID && options.fillOpacity) {\n        options.fillOpacity = 0;\n    }\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const polylineUID = '1';\n    const center = canvasPolyline[0];\n    const radius = 6;\n    const numberOfPoints = 100;\n    const circlePoints = [];\n    for (let i = 0; i < numberOfPoints; i++) {\n        const angle = (i / numberOfPoints) * 2 * Math.PI;\n        const x = center[0] + radius * Math.cos(angle);\n        const y = center[1] + radius * Math.sin(angle);\n        circlePoints.push([x, y]);\n    }\n    const crosshair = [\n        [center[0] - radius * 2, center[1]],\n        [center[0] + radius * 2, center[1]],\n        [center[0], center[1] - radius * 2],\n        [center[0], center[1] + radius * 2],\n    ];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);\n    const allContours = [circlePoints, ...childContours];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderPointContourWithMarker =\n        renderPointContourWithMarker.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n","import { BaseVolumeViewport, cache, getEnabledElement, metaData, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { addAnnotation, removeAnnotation, getAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport ChangeTypes from '../../enums/ChangeTypes';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { addContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst { DefaultHistoryMemo } = csUtils.HistoryMemo;\nconst { PointsManager } = csUtils;\nclass AnnotationTool extends AnnotationDisplayTool {\n    static createAnnotationForViewport(viewport, ...annotationBaseData) {\n        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);\n    }\n    static createAndAddAnnotation(viewport, ...annotationBaseData) {\n        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationModified(annotation, viewport.element);\n    }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation.annotationUID) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n        this.isSuvScaled = AnnotationTool.isSuvScaled;\n        if (toolProps.configuration?.getTextLines) {\n            this.configuration.getTextLines = toolProps.configuration.getTextLines;\n        }\n        if (toolProps.configuration?.statsCalculator) {\n            this.configuration.statsCalculator =\n                toolProps.configuration.statsCalculator;\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { isCanvasAnnotation } = data;\n        const { points, textBox } = data.handles;\n        if (textBox) {\n            const { worldBoundingBox } = textBox;\n            if (worldBoundingBox) {\n                const canvasBoundingBox = {\n                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n                };\n                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                    data.handles.activeHandleIndex = null;\n                    return textBox;\n                }\n            }\n        }\n        for (let i = 0; i < points?.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = isCanvasAnnotation\n                ? point.slice(0, 2)\n                : viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    static isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = csUtils.getVolumeId(targetId);\n            const volume = cache.getVolume(volumeId);\n            return volume?.scaling?.PT !== undefined;\n        }\n        const scalingModule = imageId && metaData.get('scalingModule', imageId);\n        return typeof scalingModule?.suvbw === 'number';\n    }\n    getAnnotationStyle(context) {\n        const { annotation, styleSpecifier } = context;\n        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);\n        const { annotationUID } = annotation;\n        const visibility = isAnnotationVisible(annotationUID);\n        const locked = isAnnotationLocked(annotationUID);\n        const lineWidth = getStyle('lineWidth');\n        const lineDash = getStyle('lineDash');\n        const angleArcLineDash = getStyle('angleArcLineDash');\n        const color = getStyle('color');\n        const markerSize = getStyle('markerSize');\n        const shadow = getStyle('shadow');\n        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        return {\n            visibility,\n            locked,\n            color,\n            lineWidth,\n            lineDash,\n            lineOpacity: 1,\n            fillColor: color,\n            fillOpacity: 0,\n            shadow,\n            textbox: textboxStyle,\n            markerSize,\n            angleArcLineDash,\n        };\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n    static createAnnotationState(annotation, deleting) {\n        const { data, annotationUID } = annotation;\n        const cloneData = {\n            ...data,\n            cachedStats: {},\n        };\n        delete cloneData.contour;\n        delete cloneData.spline;\n        const state = {\n            annotationUID,\n            data: structuredClone(cloneData),\n            deleting,\n        };\n        const contour = data.contour;\n        if (contour) {\n            state.data.contour = {\n                ...contour,\n                polyline: null,\n                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),\n            };\n        }\n        return state;\n    }\n    static createAnnotationMemo(element, annotation, options) {\n        if (!annotation) {\n            return;\n        }\n        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};\n        const { annotationUID } = annotation;\n        const state = AnnotationTool.createAnnotationState(annotation, deleting);\n        const annotationMemo = {\n            restoreMemo: () => {\n                const newState = AnnotationTool.createAnnotationState(annotation, deleting);\n                const { viewport } = getEnabledElement(element) || {};\n                viewport?.setViewReference(annotation.metadata);\n                if (state.deleting === true) {\n                    state.deleting = false;\n                    Object.assign(annotation.data, state.data);\n                    if (annotation.data.contour) {\n                        const annotationData = annotation.data;\n                        annotationData.contour.polyline = state.data.contour.pointsManager.points;\n                        delete state.data.contour.pointsManager;\n                        if (annotationData.segmentation) {\n                            addContourSegmentationAnnotation(annotation);\n                        }\n                    }\n                    state.data = newState.data;\n                    addAnnotation(annotation, element);\n                    setAnnotationSelected(annotation.annotationUID, true);\n                    viewport?.render();\n                    return;\n                }\n                if (state.deleting === false) {\n                    state.deleting = true;\n                    state.data = newState.data;\n                    setAnnotationSelected(annotation.annotationUID);\n                    removeAnnotation(annotation.annotationUID);\n                    viewport?.render();\n                    return;\n                }\n                const currentAnnotation = getAnnotation(annotationUID);\n                if (!currentAnnotation) {\n                    console.warn('No current annotation');\n                    return;\n                }\n                Object.assign(currentAnnotation.data, state.data);\n                if (currentAnnotation.data.contour) {\n                    currentAnnotation.data\n                        .contour.polyline = state.data.contour.pointsManager.points;\n                }\n                state.data = newState.data;\n                currentAnnotation.invalidated = true;\n                triggerAnnotationModified(currentAnnotation, element, ChangeTypes.History);\n            },\n            id: annotationUID,\n            operationType: 'annotation',\n        };\n        DefaultHistoryMemo.push(annotationMemo);\n        return annotationMemo;\n    }\n    createMemo(element, annotation, options) {\n        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);\n    }\n    startGroupRecording() {\n        DefaultHistoryMemo.startGroupRecording();\n    }\n    endGroupRecording() {\n        DefaultHistoryMemo.endGroupRecording();\n    }\n    static hydrateBase(ToolClass, enabledElement, points, options = {}) {\n        if (!enabledElement) {\n            return null;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const camera = viewport.getCamera();\n        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;\n        const viewUp = options.viewUp ?? camera.viewUp;\n        const instance = options.toolInstance || new ToolClass();\n        let referencedImageId;\n        let finalViewPlaneNormal = viewPlaneNormal;\n        let finalViewUp = viewUp;\n        if (options.referencedImageId) {\n            referencedImageId = options.referencedImageId;\n            finalViewPlaneNormal = undefined;\n            finalViewUp = undefined;\n        }\n        else {\n            if (viewport instanceof StackViewport) {\n                const closestImageIndex = csUtils.getClosestStackImageIndexForPoint(points[0], viewport);\n                if (closestImageIndex !== undefined) {\n                    referencedImageId = viewport.getImageIds()[closestImageIndex];\n                }\n            }\n            else if (viewport instanceof BaseVolumeViewport) {\n                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n            }\n            else {\n                throw new Error('Unsupported viewport type');\n            }\n        }\n        return {\n            FrameOfReferenceUID,\n            referencedImageId,\n            viewPlaneNormal: finalViewPlaneNormal,\n            viewUp: finalViewUp,\n            instance,\n            viewport,\n        };\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, getChildAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport AnnotationTool from './AnnotationTool';\nimport updateContourPolyline from '../../utilities/contours/updateContourPolyline';\nimport getContourHolesDataCanvas from '../../utilities/contours/getContourHolesDataCanvas';\nclass ContourBaseTool extends AnnotationTool {\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        let renderStatus = false;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return renderStatus;\n        }\n        let annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        const targetId = this.getTargetId(viewport);\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        for (let i = 0; i < annotations.length; i++) {\n            const annotation = annotations[i];\n            styleSpecifier.annotationUID = annotation.annotationUID;\n            const annotationStyle = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!annotationStyle.visibility) {\n                continue;\n            }\n            const annotationRendered = this.renderAnnotationInstance({\n                enabledElement,\n                targetId,\n                annotation,\n                annotationStyle,\n                svgDrawingHelper,\n            });\n            renderStatus ||= annotationRendered;\n            annotation.invalidated = false;\n        }\n        return renderStatus;\n    }\n    createAnnotation(evt) {\n        const annotation = super.createAnnotation(evt);\n        Object.assign(annotation.data, {\n            contour: {\n                polyline: [],\n                closed: false,\n            },\n        });\n        Object.assign(annotation, {\n            interpolationUID: '',\n            autoGenerated: false,\n        });\n        return annotation;\n    }\n    addAnnotation(annotation, element) {\n        return addAnnotation(annotation, element);\n    }\n    cancelAnnotation(annotation) {\n    }\n    moveAnnotation(annotation, worldPosDelta) {\n        const { points } = annotation.data.handles;\n        for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n            const point = points[i];\n            point[0] += worldPosDelta[0];\n            point[1] += worldPosDelta[1];\n            point[2] += worldPosDelta[2];\n        }\n        annotation.invalidated = true;\n        getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));\n    }\n    updateContourPolyline(annotation, polylineData, transforms, options) {\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, polylineData, transforms, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n            updateWindingDirection: options?.updateWindingDirection,\n        });\n    }\n    getPolylinePoints(annotation) {\n        return annotation.data.contour?.polyline ?? annotation.data.polyline;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        if (annotation.parentAnnotationUID) {\n            return;\n        }\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));\n        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;\n        const childContours = getContourHolesDataCanvas(annotation, viewport);\n        const allContours = [polylineCanvasPoints, ...childContours];\n        drawPathSvg(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {\n            color: color,\n            lineDash: lineDash,\n            lineWidth: Math.max(0.1, lineWidth),\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n        });\n        return true;\n    }\n}\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';\nimport { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nclass ContourSegmentationBaseTool extends ContourBaseTool {\n    static { this.PreviewSegmentIndex = 255; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n    }\n    onSetToolConfiguration() {\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n        else {\n            InterpolationManager.removeTool(this.getToolName());\n        }\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const contourAnnotation = super.createAnnotation(evt);\n        if (!this.isContourSegmentationTool()) {\n            return contourAnnotation;\n        }\n        const activeSeg = getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation detected, create one before using scissors tool');\n        }\n        if (!activeSeg.representationData.Contour) {\n            throw new Error(`A contour segmentation must be active`);\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n            },\n        });\n    }\n    addAnnotation(annotation, element) {\n        const annotationUID = super.addAnnotation(annotation, element);\n        if (this.isContourSegmentationTool()) {\n            const contourSegAnnotation = annotation;\n            addContourSegmentationAnnotation(contourSegAnnotation);\n        }\n        return annotationUID;\n    }\n    cancelAnnotation(annotation) {\n        if (this.isContourSegmentationTool()) {\n            removeContourSegmentationAnnotation(annotation);\n        }\n        super.cancelAnnotation(annotation);\n    }\n    getAnnotationStyle(context) {\n        const annotationStyle = super.getAnnotationStyle(context);\n        if (!this.isContourSegmentationTool()) {\n            return annotationStyle;\n        }\n        const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation } = renderContext;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated && this.isContourSegmentationTool()) {\n            const { segmentationId } = (annotation).data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            const toolGroupIds = viewportIds.map((viewportId) => {\n                const toolGroup = getToolGroupForViewport(viewportId);\n                return toolGroup.id;\n            });\n            triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n        }\n        return renderResult;\n    }\n    _getContourSegmentationStyle(context) {\n        const annotation = context.annotation;\n        const { segmentationId, segmentIndex } = annotation.data.segmentation;\n        const { viewportId } = context.styleSpecifier;\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n        if (!segmentationRepresentations?.length) {\n            return {};\n        }\n        let segmentationRepresentation;\n        if (segmentationRepresentations.length > 1) {\n            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&\n                rep.type === SegmentationRepresentations.Contour);\n        }\n        else {\n            segmentationRepresentation = segmentationRepresentations[0];\n        }\n        const { autoGenerated } = annotation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const annotationLocked = segmentsLocked.includes(segmentIndex);\n        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n            autoGenerated,\n        });\n        return {\n            color,\n            fillColor,\n            lineWidth,\n            fillOpacity,\n            lineDash,\n            textbox: {\n                color,\n            },\n            visibility,\n            locked: annotationLocked,\n        };\n    }\n}\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthAutoGenerated: 3,\n    outlineWidth: 1,\n    outlineWidthInactive: 1,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    outlineDash: undefined,\n    outlineDashInactive: undefined,\n    outlineDashAutoGenerated: '5,3',\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.3,\n    fillAlphaAutoGenerated: 0.3,\n};\nfunction getDefaultContourStyle() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourStyle;\n","import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';\nimport { cache, utilities } from '@cornerstonejs/core';\nimport { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';\nimport { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';\nimport { validateGeometry } from './utils';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';\nfunction handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {\n    if (annotationUIDsMap.size) {\n        viewport.render();\n    }\n    else {\n        addContourSetsToElement(viewport, geometryIds, contourRepresentation);\n    }\n}\nfunction addContourSetsToElement(viewport, geometryIds, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        validateGeometry(geometry);\n        const segmentSpecificConfig = segmentationStyle.getStyle({\n            viewportId: viewport.id,\n            segmentationId,\n            type: SegmentationRepresentations.Contour,\n            segmentIndex,\n        });\n        const contourSet = geometry.data;\n        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;\n        contourSet.contours.forEach((contour) => {\n            const { points, color, id } = contour;\n            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);\n            const contourSegmentationAnnotation = {\n                annotationUID: utilities.uuidv4(),\n                data: {\n                    contour: {\n                        closed: true,\n                        polyline: points,\n                    },\n                    segmentation: {\n                        segmentationId,\n                        segmentIndex,\n                        color,\n                        id,\n                    },\n                    handles: {},\n                },\n                handles: {},\n                highlighted: false,\n                autoGenerated: false,\n                invalidated: false,\n                isLocked: true,\n                isVisible: true,\n                metadata: {\n                    referencedImageId,\n                    toolName: 'PlanarFreehandContourSegmentationTool',\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n                },\n            };\n            const annotationGroupSelector = viewport.element;\n            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);\n            addContourSegmentationAnnotation(contourSegmentationAnnotation);\n        });\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n    });\n    viewport.render();\n}\nexport { handleContourSegmentation, addContourSetsToElement };\n","import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.contours.forEach((contour) => {\n        const pointList = contour.points;\n        const flatPoints = contour.flatPointsArray;\n        const type = contour.type;\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n","import { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { removeAnnotation } from '../../../stateManagement';\nfunction removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    annotationUIDsMap.forEach((annotationSet) => {\n        annotationSet.forEach((annotationUID) => {\n            removeAnnotation(annotationUID);\n        });\n    });\n}\nexport default removeContourFromElement;\n","import { cache, Enums, convertMapperToNotSharedMapper, volumeLoader, eventTarget, createVolumeActor, } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nconst internalCache = new Map();\nconst load = ({ cfun, ofun, actor }) => {\n    actor.getProperty().setRGBTransferFunction(1, cfun);\n    actor.getProperty().setScalarOpacity(1, ofun);\n};\nexport async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {\n    const defaultActor = viewport.getDefaultActor();\n    const { actor } = defaultActor;\n    const { uid, callback } = defaultActor;\n    const referenceVolumeId = viewport.getVolumeId();\n    if (internalCache.get(uid)?.added) {\n        return {\n            uid,\n            actor,\n        };\n    }\n    const volumeInputArray = volumeInputs;\n    const firstImageVolume = cache.getVolume(volumeInputArray[0].volumeId);\n    if (!firstImageVolume) {\n        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);\n    }\n    const { volumeId } = volumeInputArray[0];\n    const segImageVolume = await volumeLoader.loadVolume(volumeId);\n    if (!segImageVolume) {\n        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);\n    }\n    const segVoxelManager = segImageVolume.voxelManager;\n    const segData = segVoxelManager.getCompleteScalarDataArray();\n    const { imageData: segImageData } = segImageVolume;\n    const baseVolume = cache.getVolume(referenceVolumeId);\n    const baseVoxelManager = baseVolume.voxelManager;\n    const baseData = baseVoxelManager.getCompleteScalarDataArray();\n    const newComp = 2;\n    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());\n    const dims = segImageData.getDimensions();\n    for (let z = 0; z < dims[2]; ++z) {\n        for (let y = 0; y < dims[1]; ++y) {\n            for (let x = 0; x < dims[0]; ++x) {\n                const iTuple = x + dims[0] * (y + dims[1] * z);\n                cubeData[iTuple * newComp + 0] = baseData[iTuple];\n                cubeData[iTuple * newComp + 1] = segData[iTuple];\n            }\n        }\n    }\n    viewport.removeActors([uid]);\n    const oldMapper = actor.getMapper();\n    const mapper = convertMapperToNotSharedMapper(oldMapper);\n    actor.setMapper(mapper);\n    mapper.setBlendMode(Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);\n    const arrayAgain = mapper.getInputData().getPointData().getArray(0);\n    arrayAgain.setData(cubeData);\n    arrayAgain.setNumberOfComponents(2);\n    actor.getProperty().setColorMixPreset(1);\n    actor.getProperty().setForceNearestInterpolation(1, true);\n    actor.getProperty().setIndependentComponents(true);\n    viewport.addActor({\n        actor,\n        uid,\n        callback,\n        referencedId: referenceVolumeId,\n        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n    });\n    internalCache.set(uid, {\n        added: true,\n        segmentationRepresentationUID: `${segmentationId}`,\n        originalBlendMode: viewport.getBlendMode(),\n    });\n    actor.set({\n        preLoad: load,\n    });\n    function onSegmentationDataModified(evt) {\n        const { segmentationId } = evt.detail;\n        const { representationData } = getSegmentation(segmentationId);\n        const { volumeId: segVolumeId } = representationData.Labelmap;\n        if (segVolumeId !== segImageVolume.volumeId) {\n            return;\n        }\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const segVoxelManager = segmentationVolume.voxelManager;\n        const imageData = mapper.getInputData();\n        const array = imageData.getPointData().getArray(0);\n        const baseData = array.getData();\n        const newComp = 2;\n        const dims = segImageData.getDimensions();\n        const slices = Array.from({ length: dims[2] }, (_, i) => i);\n        for (const z of slices) {\n            for (let y = 0; y < dims[1]; ++y) {\n                for (let x = 0; x < dims[0]; ++x) {\n                    const iTuple = x + dims[0] * (y + dims[1] * z);\n                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);\n                }\n            }\n        }\n        array.setData(baseData);\n        imageData.modified();\n        viewport.render();\n    }\n    eventTarget.addEventListenerDebounced(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);\n    eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);\n        const actorEntry = viewport.getActor(uid);\n        const { element, id } = viewport;\n        viewport.removeActors([uid]);\n        const actor = await createVolumeActor({\n            volumeId: uid,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            callback: ({ volumeActor }) => {\n                if (actorEntry.callback) {\n                    actorEntry.callback({\n                        volumeActor,\n                        volumeId,\n                    });\n                }\n            },\n        }, element, id);\n        viewport.addActor({ actor, uid });\n        viewport.render();\n    });\n    return {\n        uid,\n        actor,\n    };\n}\n","import { getEnabledElement, addVolumesToViewports, addImageSlicesToViewports, Enums, cache, BaseVolumeViewport, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationDataModified, triggerSegmentationModified, } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { addVolumesAsIndependentComponents } from './addVolumesAsIndependentComponents';\nconst { uuidv4 } = utilities;\nasync function addLabelmapToElement(element, labelMapData, segmentationId, config) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeLabelMapData = labelMapData;\n        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);\n        if (!cache.getVolume(volumeId)) {\n            await _handleMissingVolume(labelMapData);\n        }\n        let blendMode = config?.blendMode ?? Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n        let useIndependentComponents = blendMode === Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;\n        if (useIndependentComponents) {\n            const referenceVolumeId = viewport.getVolumeId();\n            const baseVolume = cache.getVolume(referenceVolumeId);\n            const segVolume = cache.getVolume(volumeId);\n            const segDims = segVolume.dimensions;\n            const refDims = baseVolume.dimensions;\n            if (segDims[0] !== refDims[0] ||\n                segDims[1] !== refDims[1] ||\n                segDims[2] !== refDims[2]) {\n                useIndependentComponents = false;\n                blendMode = Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n                console.debug('Dimensions mismatch - falling back to regular volume addition');\n            }\n        }\n        const volumeInputs = [\n            {\n                volumeId,\n                visibility,\n                representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                useIndependentComponents,\n                blendMode,\n            },\n        ];\n        if (!volumeInputs[0].useIndependentComponents) {\n            await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n        }\n        else {\n            const result = await addVolumesAsIndependentComponents({\n                viewport,\n                volumeInputs,\n                segmentationId,\n            });\n            return result;\n        }\n    }\n    else {\n        const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        const stackInputs = segmentationImageIds.map((imageId) => ({\n            imageId,\n            representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${imageId}`,\n        }));\n        addImageSlicesToViewports(renderingEngine, stackInputs, [viewportId]);\n    }\n    triggerSegmentationDataModified(segmentationId);\n}\nfunction _ensureVolumeHasVolumeId(labelMapData, segmentationId) {\n    let { volumeId } = labelMapData;\n    if (!volumeId) {\n        volumeId = uuidv4();\n        const segmentation = getSegmentation(segmentationId);\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            volumeId,\n        };\n        labelMapData.volumeId = volumeId;\n        triggerSegmentationModified(segmentationId);\n    }\n    return volumeId;\n}\nasync function _handleMissingVolume(labelMapData) {\n    const stackData = labelMapData;\n    const hasImageIds = stackData.imageIds.length > 0;\n    if (!hasImageIds) {\n        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');\n    }\n    const volume = await volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);\n    return volume;\n}\nexport default addLabelmapToElement;\n","const defaultLabelmapConfig = {\n    renderOutline: true,\n    renderOutlineInactive: true,\n    outlineWidth: 3,\n    outlineWidthInactive: 2,\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.4,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapStyle() {\n    return defaultLabelmapConfig;\n}\nexport default getDefaultLabelmapStyle;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getLabelmapActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeLabelmapFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);\n}\nexport default removeLabelmapFromElement;\n","import { utilities } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorEntry, getSurfaceRepresentationUID, } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction addOrUpdateSurfaceToElement(viewport, surface, segmentationId) {\n    const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);\n    const surfaceActor = surfaceActorEntry?.actor;\n    const isVisible = surface.visible;\n    if (surfaceActor) {\n        surfaceActor.setVisibility(isVisible);\n        if (!isVisible) {\n            return;\n        }\n        const surfaceMapper = surfaceActor.getMapper();\n        const currentPolyData = surfaceMapper.getInputData();\n        const newPoints = surface.points;\n        const newPolys = surface.polys;\n        const currentPoints = currentPolyData.getPoints().getData();\n        const currentPolys = currentPolyData.getPolys().getData();\n        if (newPoints.length === currentPoints.length &&\n            newPolys.length === currentPolys.length) {\n            return;\n        }\n        const polyData = vtkPolyData.newInstance();\n        polyData.getPoints().setData(newPoints, 3);\n        const triangles = vtkCellArray.newInstance({\n            values: Float32Array.from(newPolys),\n        });\n        polyData.setPolys(triangles);\n        surfaceMapper.setInputData(polyData);\n        surfaceMapper.modified();\n        viewport.getRenderer().resetCameraClippingRange();\n        return;\n    }\n    const points = surface.points;\n    const polys = surface.polys;\n    const color = surface.color;\n    const surfacePolyData = vtkPolyData.newInstance();\n    surfacePolyData.getPoints().setData(points, 3);\n    const triangles = vtkCellArray.newInstance({\n        values: Float32Array.from(polys),\n    });\n    surfacePolyData.setPolys(triangles);\n    const mapper = vtkMapper.newInstance({});\n    let clippingFilter;\n    mapper.setInputData(surfacePolyData);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n    actor.getProperty().setLineWidth(2);\n    const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);\n    viewport.addActor({\n        uid: utilities.uuidv4(),\n        actor: actor,\n        clippingFilter,\n        representationUID,\n    });\n    viewport.resetCamera();\n    viewport.getRenderer().resetCameraClippingRange();\n    viewport.render();\n}\nexport default addOrUpdateSurfaceToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeSurfaceFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const filteredSurfaceActors = actorEntries.filter((actor) => actor.representationUID &&\n        typeof actor.representationUID === 'string' &&\n        actor.representationUID.startsWith(segmentationId));\n    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));\n}\nexport default removeSurfaceFromElement;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { StrategyCallbacks } from '../../../enums';\nexport default class BrushStrategy {\n    static { this.COMPOSITIONS = compositions; }\n    static { this.childFunctions = {\n        [StrategyCallbacks.OnInteractionStart]: addListMethod(StrategyCallbacks.OnInteractionStart, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.OnInteractionEnd]: addListMethod(StrategyCallbacks.OnInteractionEnd, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n        [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n        [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks.CreateIsInThreshold),\n        [StrategyCallbacks.Interpolate]: addListMethod(StrategyCallbacks.Interpolate, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.AcceptPreview]: addListMethod(StrategyCallbacks.AcceptPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.RejectPreview]: addListMethod(StrategyCallbacks.RejectPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks.INTERNAL_setValue),\n        [StrategyCallbacks.Preview]: addSingletonMethod(StrategyCallbacks.Preview, false),\n        [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks.ComputeInnerCircleRadius),\n        [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),\n        [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureImageVolumeFor3DManipulation),\n        [StrategyCallbacks.AddPreview]: addListMethod(StrategyCallbacks.AddPreview),\n        [StrategyCallbacks.GetStatistics]: addSingletonMethod(StrategyCallbacks.GetStatistics),\n        compositions: null,\n    }; }\n    constructor(name, ...initializers) {\n        this._initialize = [];\n        this._fill = [];\n        this._onInteractionStart = [];\n        this.fill = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.Fill);\n            if (!initializedData) {\n                return;\n            }\n            this._fill.forEach((func) => func(initializedData));\n            const { segmentationVoxelManager, segmentIndex } = initializedData;\n            triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n            return initializedData;\n        };\n        this.onInteractionStart = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData);\n            if (!initializedData) {\n                return;\n            }\n            this._onInteractionStart.forEach((func) => func.call(this, initializedData));\n        };\n        this.addPreview = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.AddPreview);\n            if (!initializedData) {\n                return;\n            }\n            return initializedData;\n        };\n        this.configurationName = name;\n        this.compositions = initializers;\n        initializers.forEach((initializer) => {\n            const result = typeof initializer === 'function' ? initializer() : initializer;\n            if (!result) {\n                return;\n            }\n            for (const key in result) {\n                if (!BrushStrategy.childFunctions[key]) {\n                    throw new Error(`Didn't find ${key} as a brush strategy`);\n                }\n                BrushStrategy.childFunctions[key](this, result[key]);\n            }\n        });\n        this.strategyFunction = (enabledElement, operationData) => {\n            return this.fill(enabledElement, operationData);\n        };\n        for (const key of Object.keys(BrushStrategy.childFunctions)) {\n            this.strategyFunction[key] = this[key];\n        }\n    }\n    initialize(enabledElement, operationData, operationName) {\n        const { viewport } = enabledElement;\n        const data = getStrategyData({ operationData, viewport, strategy: this });\n        if (!data) {\n            return null;\n        }\n        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;\n        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);\n        const initializedData = {\n            operationName,\n            ...operationData,\n            segmentIndex: operationData.segmentIndex,\n            enabledElement,\n            imageVoxelManager,\n            segmentationVoxelManager,\n            segmentationImageData,\n            viewport,\n            centerWorld: null,\n            isInObject: null,\n            isInObjectBoundsIJK: null,\n            brushStrategy: this,\n            memo,\n        };\n        this._initialize.forEach((func) => func(initializedData));\n        return initializedData;\n    }\n}\nfunction addListMethod(name, createInitialized) {\n    const listName = `_${name}`;\n    return (brushStrategy, func) => {\n        brushStrategy[listName] ||= [];\n        brushStrategy[listName].push(func);\n        brushStrategy[name] ||= createInitialized\n            ? (enabledElement, operationData, ...args) => {\n                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);\n                let returnValue;\n                brushStrategy[listName].forEach((func) => {\n                    const value = func.call(brushStrategy, initializedData, ...args);\n                    returnValue ||= value;\n                });\n                return returnValue;\n            }\n            : (operationData, ...args) => {\n                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));\n            };\n    };\n}\nfunction addSingletonMethod(name, isInitialized = true) {\n    return (brushStrategy, func) => {\n        if (brushStrategy[name]) {\n            throw new Error(`The singleton method ${name} already exists`);\n        }\n        brushStrategy[name] = isInitialized\n            ? func\n            : (enabledElement, operationData, ...args) => {\n                operationData.enabledElement = enabledElement;\n                return func.call(brushStrategy, operationData, ...args);\n            };\n    };\n}\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;\n        if (!configuration?.useCenterSegmentIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            operationData.centerSegmentIndexInfo.hasSegmentIndex = false;\n            operationData.centerSegmentIndexInfo.hasPreviewIndex = false;\n            return;\n        }\n        let hasSegmentIndex = false;\n        let hasPreviewIndex = false;\n        const nestedBounds = [\n            ...segmentationVoxelManager.getBoundsIJK(),\n        ];\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const callback = ({ value }) => {\n            hasSegmentIndex ||= value === segmentIndex;\n            hasPreviewIndex ||= value === previewSegmentIndex;\n        };\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: nestedBounds,\n        });\n        if (!hasSegmentIndex && !hasPreviewIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            return;\n        }\n        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;\n        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;\n        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;\n        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {\n            return;\n        }\n        if (operationName === StrategyCallbacks.RejectPreview ||\n            operationName === StrategyCallbacks.OnInteractionEnd) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager.getBoundsIJK();\n        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;\n        const useDelta = oldThreshold ? 0 : dynamicRadius;\n        const { viewPlaneNormal } = viewport.getCamera();\n        const nestedBounds = boundsIJK.map((ijk, idx) => {\n            const [min, max] = ijk;\n            return [\n                Math.max(min, centerIJK[idx] - useDelta),\n                Math.min(max, centerIJK[idx] + useDelta),\n            ];\n        });\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const threshold = oldThreshold || [Infinity, -Infinity];\n        const useDeltaSqr = useDelta * useDelta;\n        const callback = ({ value, pointIJK }) => {\n            const distance = vec3.sqrDist(centerIJK, pointIJK);\n            if (distance > useDeltaSqr) {\n                return;\n            }\n            const gray = Array.isArray(value) ? vec3.len(value) : value;\n            threshold[0] = Math.min(gray, threshold[0]);\n            threshold[1] = Math.max(gray, threshold[1]);\n        };\n        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n        configuration.threshold.range = threshold;\n    },\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { configuration } = operationData;\n        if (!configuration?.threshold?.isDynamic) {\n            return;\n        }\n        configuration.threshold.range = null;\n    },\n    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {\n        const { configuration, viewport } = operationData;\n        const { dynamicRadius = 0, isDynamic } = configuration.threshold;\n        if (!isDynamic) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n            return;\n        }\n        if (dynamicRadius === 0) {\n            return;\n        }\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        const { spacing } = imageData;\n        const centerCanvas = [\n            viewport.element.clientWidth / 2,\n            viewport.element.clientHeight / 2,\n        ];\n        const radiusInWorld = dynamicRadius * spacing[0];\n        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);\n        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);\n        if (!configuration.threshold.dynamicRadiusInCanvas) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n        }\n        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        operationData.segmentIndex = 0;\n    },\n};\n","import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport IslandRemoval from '../../../../utilities/segmentation/islandRemoval';\nexport default {\n    [StrategyCallbacks.OnInteractionEnd]: (operationData) => {\n        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;\n        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||\n            segmentIndex === null) {\n            return;\n        }\n        const islandRemoval = new IslandRemoval();\n        const voxelManager = memo?.voxelManager || segmentationVoxelManager;\n        if (!islandRemoval.initialize(viewport, voxelManager, {\n            previewSegmentIndex,\n            segmentIndex,\n        })) {\n            return;\n        }\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();\n        if (!arrayOfSlices) {\n            return;\n        }\n        triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);\n    },\n};\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/events/triggerSegmentationDataModified';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { setSegmentIndexColor } from '../../../../stateManagement/segmentation/config/segmentationColor';\nimport { getViewportIdsWithSegmentation } from '../../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nexport default {\n    [StrategyCallbacks.Preview]: function (operationData) {\n        const { previewSegmentIndex, configuration, enabledElement } = operationData;\n        if (!previewSegmentIndex || !configuration) {\n            return;\n        }\n        this.onInteractionStart?.(enabledElement, operationData);\n        const preview = this.fill(enabledElement, operationData);\n        if (preview) {\n            this.onInteractionEnd?.(enabledElement, operationData);\n        }\n        return preview;\n    },\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;\n        operationData.modified = false;\n        if (previewSegmentIndex == null || segmentIndex == null) {\n            return;\n        }\n        const viewportIds = getViewportIdsWithSegmentation(operationData.segmentationId);\n        viewportIds?.forEach((viewportId) => {\n            setSegmentIndexColor(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);\n        });\n        operationData.modified = true;\n    },\n    [StrategyCallbacks.AcceptPreview]: (operationData) => {\n        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};\n        const { changedIndices } = centerSegmentIndexInfo || {};\n        const labelmapMemo = memo;\n        const callback = ({ index }) => {\n            const oldValue = segmentationVoxelManager.getAtIndex(index);\n            if (changedIndices?.length > 0) {\n                if (changedIndices.includes(index)) {\n                    labelmapMemo.voxelManager.setAtIndex(index, 0);\n                }\n            }\n            else {\n                if (oldValue === previewSegmentIndex) {\n                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);\n                }\n            }\n        };\n        segmentationVoxelManager.forEach(callback);\n        triggerSegmentationDataModified(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n        operationData.centerSegmentIndexInfo.changedIndices = [];\n    },\n    [StrategyCallbacks.RejectPreview]: (operationData) => {\n        if (!operationData) {\n            return;\n        }\n        utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {\n            const labelmapMemo = memo;\n            if (!labelmapMemo?.voxelManager) {\n                return false;\n            }\n            const { segmentationVoxelManager } = labelmapMemo;\n            let hasPreviewSegmentIndex = false;\n            const callback = ({ value }) => {\n                if (value === operationData.previewSegmentIndex) {\n                    hasPreviewSegmentIndex = true;\n                }\n            };\n            segmentationVoxelManager.forEach(callback);\n            return hasPreviewSegmentIndex;\n        });\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Fill]: (operationData) => {\n        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;\n        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);\n        const { setValue } = brushStrategy;\n        const callback = isWithinThreshold\n            ? (data) => {\n                const { value, index } = data;\n                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n                    return;\n                }\n                setValue(operationData, data);\n            }\n            : (data) => setValue(operationData, data);\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: operationData.isInObjectBoundsIJK,\n        });\n        segmentationVoxelManager.addPoint(centerIJK);\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { handleUseSegmentCenterIndex } from '../utils/handleUseSegmentCenterIndex';\nexport default {\n    [StrategyCallbacks.INTERNAL_setValue]: (operationData, { value, index }) => {\n        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;\n        const existingValue = segmentationVoxelManager.getAtIndex(index);\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&\n            existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex === null) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);\n            return;\n        }\n        if (!previewSegmentIndex) {\n            let useSegmentIndex = segmentIndex;\n            if (centerSegmentIndexInfo) {\n                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;\n            }\n            memo.voxelManager.setAtIndex(index, useSegmentIndex);\n            return;\n        }\n        handleUseSegmentCenterIndex({\n            operationData,\n            existingValue,\n            index,\n        });\n    },\n};\n","export function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {\n    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;\n    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;\n    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === 0 || existingValue !== segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        centerSegmentIndexInfo.changedIndices.push(index);\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        !hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n}\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.CreateIsInThreshold]: (operationData) => {\n        const { imageVoxelManager, segmentIndex, configuration } = operationData;\n        if (!configuration || !segmentIndex) {\n            return;\n        }\n        return (index) => {\n            const voxelValue = imageVoxelManager.getAtIndex(index);\n            const gray = Array.isArray(voxelValue)\n                ? vec3.length(voxelValue)\n                : voxelValue;\n            const { threshold } = configuration || {};\n            if (!threshold?.range?.length) {\n                return true;\n            }\n            return threshold.range[0] <= gray && gray <= threshold.range[1];\n        };\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getStatistics from '../../../../utilities/segmentation/getStatistics';\nexport default {\n    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {\n        const { indices } = options;\n        const { segmentationId, viewport } = operationData;\n        getStatistics({\n            segmentationId,\n            segmentIndices: indices,\n        });\n    },\n};\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemovalComposition';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\nimport labelmapStatistics from './labelmapStatistics';\nimport ensureSegmentationVolumeFor3DManipulation from './ensureSegmentationVolume';\nimport ensureImageVolumeFor3DManipulation from './ensureImageVolume';\nexport default {\n    determineSegmentIndex,\n    dynamicThreshold,\n    erase,\n    islandRemoval,\n    preview,\n    regionFill,\n    setValue,\n    threshold,\n    labelmapStatistics,\n    ensureSegmentationVolumeFor3DManipulation,\n    ensureImageVolumeFor3DManipulation,\n};\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy('EraseCircle', compositions.erase, ...CIRCLE_STRATEGY.compositions);\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\nexport { eraseInsideCircle };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy('EraseSphere', compositions.erase, ...SPHERE_STRATEGY.compositions);\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\nexport { eraseInsideSphere };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport BrushStrategy from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint, getEllipseCornersFromCanvasCoordinates, } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfoFromViewport } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const baseExtent = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const strokeRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : undefined;\n        const strokeCenters = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const baseBounds = baseExtent.boundsIJK;\n        const baseCenterIJK = operationData.centerIJK;\n        const boundsForStroke = strokeCenters.reduce((acc, centerPoint) => {\n            if (!centerPoint) {\n                return acc;\n            }\n            const translatedCenterIJK = transformWorldToIndex(segmentationImageData, centerPoint);\n            const deltaIJK = [\n                translatedCenterIJK[0] - baseCenterIJK[0],\n                translatedCenterIJK[1] - baseCenterIJK[1],\n                translatedCenterIJK[2] - baseCenterIJK[2],\n            ];\n            const translatedBounds = [\n                [baseBounds[0][0] + deltaIJK[0], baseBounds[0][1] + deltaIJK[0]],\n                [baseBounds[1][0] + deltaIJK[1], baseBounds[1][1] + deltaIJK[1]],\n                [baseBounds[2][0] + deltaIJK[2], baseBounds[2][1] + deltaIJK[2]],\n            ];\n            if (!acc) {\n                return translatedBounds;\n            }\n            return [\n                [\n                    Math.min(acc[0][0], translatedBounds[0][0]),\n                    Math.max(acc[0][1], translatedBounds[0][1]),\n                ],\n                [\n                    Math.min(acc[1][0], translatedBounds[1][0]),\n                    Math.max(acc[1][1], translatedBounds[1][1]),\n                ],\n                [\n                    Math.min(acc[2][0], translatedBounds[2][0]),\n                    Math.max(acc[2][1], translatedBounds[2][1]),\n                ],\n            ];\n        }, null);\n        const boundsToUse = boundsForStroke ?? baseExtent.boundsIJK;\n        if (segmentationImageData) {\n            const dimensions = segmentationImageData.getDimensions();\n            operationData.isInObjectBoundsIJK = [\n                [\n                    Math.max(0, Math.min(boundsToUse[0][0], dimensions[0] - 1)),\n                    Math.max(0, Math.min(boundsToUse[0][1], dimensions[0] - 1)),\n                ],\n                [\n                    Math.max(0, Math.min(boundsToUse[1][0], dimensions[1] - 1)),\n                    Math.max(0, Math.min(boundsToUse[1][1], dimensions[1] - 1)),\n                ],\n                [\n                    Math.max(0, Math.min(boundsToUse[2][0], dimensions[2] - 1)),\n                    Math.max(0, Math.min(boundsToUse[2][1], dimensions[2] - 1)),\n                ],\n            ];\n        }\n        else {\n            operationData.isInObjectBoundsIJK = boundsToUse;\n        }\n        operationData.isInObject = createEllipseInPoint(cornersInWorld, {\n            strokePointsWorld: operationData.strokePointsWorld,\n            segmentationImageData,\n            radius: strokeRadius,\n        });\n    },\n};\nconst SPHERE_STRATEGY = new BrushStrategy('Sphere', compositions.regionFill, compositions.setValue, sphereComposition, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics, compositions.ensureSegmentationVolumeFor3DManipulation);\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.islandRemoval, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\nconst thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;\nexport function fillOutsideSphere() {\n    throw new Error('fill outside sphere not implemented');\n}\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY, thresholdInsideSphereIsland, };\n","class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n","import { getAnnotations } from '../../../stateManagement/annotation/annotationState';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function getInterpolationData(viewportData, filterParams = []) {\n    const { viewport, sliceData, annotation } = viewportData;\n    const interpolationDatas = new Map();\n    const { toolName, originalToolName } = annotation.metadata;\n    const testToolName = originalToolName || toolName;\n    const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||\n        annotation.metadata.originalToolName === testToolName);\n    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n        const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);\n        if (modifiedAnnotations?.length) {\n            modifiedAnnotations.forEach((annotation) => {\n                const { metadata } = annotation;\n                if (metadata.originalToolName === testToolName &&\n                    metadata.originalToolName !== metadata.toolName) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n    }\n    if (!annotations?.length) {\n        return interpolationDatas;\n    }\n    for (let i = 0; i < sliceData.numberOfSlices; i++) {\n        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);\n        if (!imageAnnotations?.length) {\n            continue;\n        }\n        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {\n            return filterParams.every((x) => {\n                const parent = x.parentKey\n                    ? x.parentKey(imageAnnotation)\n                    : imageAnnotation;\n                const value = parent?.[x.key];\n                if (Array.isArray(value)) {\n                    return value.every((item, index) => item === x.value[index]);\n                }\n                return value === x.value;\n            });\n        });\n        if (filteredInterpolatedAnnotations.length) {\n            interpolationDatas.set(i, filteredInterpolatedAnnotations);\n        }\n    }\n    return interpolationDatas;\n}\n","import getInterpolationData from './getInterpolationData';\nexport default function getInterpolationDataCollection(viewportData, filterParams) {\n    const imageAnnotations = getInterpolationData(viewportData, filterParams);\n    const interpolatedDataCollection = [];\n    if (!imageAnnotations?.size) {\n        return interpolatedDataCollection;\n    }\n    for (const annotations of imageAnnotations.values()) {\n        annotations.forEach((annotation) => {\n            interpolatedDataCollection.push(annotation);\n        });\n    }\n    return interpolatedDataCollection;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport default function createPolylineToolData(polyline, handlePoints, referencedToolData) {\n    const annotation = csUtils.deepMerge({\n        data: {},\n        metadata: {},\n    }, referencedToolData);\n    Object.assign(annotation, {\n        highlighted: false,\n        invalidated: true,\n        autoGenerated: true,\n        annotationUID: undefined,\n        cachedStats: {},\n        childAnnotationUIDs: [],\n        parentAnnotationUID: undefined,\n    });\n    Object.assign(annotation.data, {\n        handles: {\n            points: handlePoints.points || handlePoints || [],\n            interpolationSources: handlePoints.sources,\n            activeHandleIndex: null,\n            textBox: {\n                hasMoved: false,\n                worldPosition: [0, 0, 0],\n                worldBoundingBox: {\n                    topLeft: [0, 0, 0],\n                    topRight: [0, 0, 0],\n                    bottomLeft: [0, 0, 0],\n                    bottomRight: [0, 0, 0],\n                },\n            },\n        },\n        contour: {\n            ...referencedToolData.data.contour,\n            polyline,\n        },\n    });\n    return annotation;\n}\n","import getInterpolationData from './getInterpolationData';\nfunction findAnnotationsForInterpolation(toolData, viewportData) {\n    const interpolationData = getInterpolationData(viewportData, [\n        {\n            key: 'interpolationUID',\n            value: viewportData.interpolationUID,\n        },\n    ]);\n    const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n    if (!rangeToInterpolate) {\n        console.warn('No annotations found to interpolate', interpolationData);\n        return;\n    }\n    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);\n    const interpolationList = [];\n    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n        if (_sliceNeedsInterpolating(interpolationData, i)) {\n            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);\n            if (contourPair?.[0] === sliceEdited ||\n                contourPair?.[1] === sliceEdited) {\n                _appendInterpolationList(contourPair, interpolationList, i);\n            }\n        }\n    }\n    return {\n        interpolationData,\n        interpolationList,\n    };\n}\nfunction getRangeToInterpolate(interpolationData) {\n    let first = Infinity;\n    let last = -Infinity;\n    let found = false;\n    for (const [sliceIndex, annotations] of interpolationData.entries()) {\n        if (annotations.length) {\n            first = Math.min(sliceIndex, first);\n            last = Math.max(sliceIndex, last);\n            found = true;\n        }\n    }\n    if (!found) {\n        return;\n    }\n    return [first, last];\n}\nfunction _getSlicePositionOfToolData(interpolationData, annotationUID) {\n    for (const [sliceIndex, annotations] of interpolationData) {\n        for (let j = 0; j < annotations.length; j++) {\n            if (annotations[j].annotationUID === annotationUID) {\n                return sliceIndex;\n            }\n        }\n    }\n    return;\n}\nfunction _sliceNeedsInterpolating(interpolationData, sliceIndex) {\n    const annotations = interpolationData.get(sliceIndex);\n    return (!annotations?.length ||\n        (annotations.length === 1 && annotations[0].autoGenerated));\n}\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n    const [startIndex] = contourPair;\n    interpolationList[startIndex] ||= {\n        pair: contourPair,\n        list: [],\n    };\n    interpolationList[startIndex].list.push(itemIndex);\n}\nfunction _getBoundingPair(sliceIndex, sliceRange, interpolationData) {\n    const annotationPair = [];\n    let canInterpolate = true;\n    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || !annotationPair.length) {\n        return;\n    }\n    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || annotationPair.length < 2) {\n        return;\n    }\n    return annotationPair;\n}\nexport default findAnnotationsForInterpolation;\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nconst { PointsManager } = utilities;\nexport default function selectHandles(polyline, handleCount = 12) {\n    const handles = PointsManager.create3(handleCount);\n    handles.sources = [];\n    const { sources: destPoints } = handles;\n    const { length, sources: sourcePoints = [] } = polyline;\n    const distance = 5;\n    if (length < distance * 3) {\n        return polyline.subselect(handleCount);\n    }\n    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));\n    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));\n    const dotValues = createDotValues(polyline, distance);\n    const minimumRegions = findMinimumRegions(dotValues, handleCount);\n    const indices = [];\n    if (minimumRegions?.length > 2) {\n        let lastHandle = -1;\n        const thirdInterval = interval / 3;\n        minimumRegions.forEach((region) => {\n            const [start, , end] = region;\n            const midIndex = Math.ceil((start + end) / 2);\n            if (end - lastHandle < thirdInterval) {\n                return;\n            }\n            if (midIndex - start > 2 * thirdInterval) {\n                addInterval(indices, lastHandle, start, interval, length);\n                lastHandle = addInterval(indices, start, midIndex, interval, length);\n            }\n            else {\n                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);\n            }\n            if (end - lastHandle > thirdInterval) {\n                lastHandle = addInterval(indices, lastHandle, end, interval, length);\n            }\n        });\n        const firstHandle = indices[0];\n        const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n        if (lastDistance > 2 * thirdInterval) {\n            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);\n        }\n    }\n    else {\n        const interval = Math.floor(length / handleCount);\n        addInterval(indices, -1, length - interval, interval, length);\n    }\n    indices.forEach((index) => {\n        const point = polyline.getPointArray(index);\n        handles.push(point);\n        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));\n    });\n    return handles;\n}\nexport function createDotValues(polyline, distance = 6) {\n    const { length } = polyline;\n    const prevVec3 = vec3.create();\n    const nextVec3 = vec3.create();\n    const dotValues = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        const point = polyline.getPoint(i);\n        const prevPoint = polyline.getPoint(i - distance);\n        const nextPoint = polyline.getPoint((i + distance) % length);\n        vec3.sub(prevVec3, point, prevPoint);\n        vec3.sub(nextVec3, nextPoint, point);\n        const dot = vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n        dotValues[i] = dot;\n    }\n    return dotValues;\n}\nfunction findMinimumRegions(dotValues, handleCount) {\n    const { max, deviation } = getStats(dotValues);\n    const { length } = dotValues;\n    if (deviation < 0.01 || length < handleCount * 3) {\n        return [];\n    }\n    const inflection = [];\n    let pair = null;\n    let minValue;\n    let minIndex = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        if (dot < max - deviation) {\n            if (pair) {\n                pair[2] = i;\n                if (dot < minValue) {\n                    minValue = dot;\n                    minIndex = i;\n                }\n                pair[1] = minIndex;\n            }\n            else {\n                minValue = dot;\n                minIndex = i;\n                pair = [i, i, i];\n            }\n        }\n        else {\n            if (pair) {\n                inflection.push(pair);\n                pair = null;\n            }\n        }\n    }\n    if (pair) {\n        if (inflection[0][0] === 0) {\n            inflection[0][0] = pair[0];\n        }\n        else {\n            pair[1] = minIndex;\n            pair[2] = length - 1;\n            inflection.push(pair);\n        }\n    }\n    return inflection;\n}\nexport function addInterval(indices, start, finish, interval, length) {\n    if (finish < start) {\n        finish += length;\n    }\n    const distance = finish - start;\n    const count = Math.ceil(distance / interval);\n    if (count <= 0) {\n        if (indices[indices.length - 1] !== finish) {\n            indices.push(indexValue(finish, length));\n        }\n        return finish;\n    }\n    for (let i = 1; i <= count; i++) {\n        const index = indexValue(start + (i * distance) / count, length);\n        indices.push(index);\n    }\n    return indices[indices.length - 1];\n}\nfunction indexValue(v, length) {\n    return (Math.round(v) + length) % length;\n}\nfunction getStats(dotValues) {\n    const { length } = dotValues;\n    let sum = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    let sumSq = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        sum += dot;\n        min = Math.min(min, dot);\n        max = Math.max(max, dot);\n    }\n    const mean = sum / length;\n    for (let i = 0; i < length; i++) {\n        const valueDiff = dotValues[i] - mean;\n        sumSq += valueDiff * valueDiff;\n    }\n    return {\n        mean,\n        max,\n        min,\n        sumSq,\n        deviation: Math.sqrt(sumSq / length),\n    };\n}\n","import { triggerEvent, utilities } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../contourSegmentation';\nconst { PointsManager } = utilities;\nconst dP = 0.2;\nfunction interpolate(viewportData) {\n    if (!viewportData.annotation) {\n        return;\n    }\n    const { isInterpolationUpdate, annotation } = viewportData;\n    queueMicrotask(() => {\n        try {\n            if (isInterpolationUpdate) {\n                annotation.isInterpolationUpdate = true;\n                annotation.autoGenerated = false;\n            }\n            startInterpolation(viewportData);\n        }\n        finally {\n            if (isInterpolationUpdate) {\n                annotation.autoGenerated = true;\n            }\n        }\n    });\n}\nfunction startInterpolation(viewportData) {\n    const { annotation: toolData } = viewportData;\n    updateChildInterpolationUID(toolData);\n    const { interpolationData, interpolationList } = findAnnotationsForInterpolation(toolData, viewportData) || {};\n    if (!interpolationData || !interpolationList) {\n        return;\n    }\n    const eventData = {\n        toolName: toolData.metadata.toolName,\n        toolType: toolData.metadata.toolName,\n        viewport: viewportData.viewport,\n    };\n    for (let i = 0; i < interpolationList.length; i++) {\n        if (interpolationList[i]) {\n            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);\n        }\n    }\n    const { id, renderingEngineId, element } = viewportData.viewport;\n    const eventDetails = {\n        annotation: toolData,\n        element,\n        viewportId: id,\n        renderingEngineId,\n    };\n    if (interpolationList.length) {\n        triggerEvent(viewportData.viewport.element, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n    }\n}\nfunction _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {\n    const annotation0 = interpolationData.get(annotationPair[0])[0];\n    const annotation1 = interpolationData.get(annotationPair[1])[0];\n    const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n    const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n    c1Interp.kIndex = annotationPair[0];\n    c2Interp.kIndex = annotationPair[1];\n    indices.forEach(function (index) {\n        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);\n    });\n}\nfunction getPointCount(pointArray) {\n    let sum = 0;\n    for (let i = 0; i < pointArray.I.length; i++) {\n        if (pointArray.I[i]) {\n            sum++;\n        }\n    }\n    return sum;\n}\nfunction _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {\n    const [startIndex, endIndex] = annotationPair;\n    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n    const annotation0 = interpolationData.get(startIndex)[0];\n    const annotation1 = interpolationData.get(endIndex)[0];\n    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);\n    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n    const handlePoints = selectHandles(interpolated3DPoints);\n    if (interpolationData.has(sliceIndex)) {\n        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n    else {\n        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n}\nfunction _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const points = interpolated3DPoints.points;\n    const { viewport } = eventData;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);\n    const viewRef = viewport.getViewReference({ sliceIndex });\n    if (!viewRef) {\n        throw new Error(`Can't find slice ${sliceIndex}`);\n    }\n    Object.assign(interpolatedAnnotation.metadata, viewRef);\n    annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);\n    const { parentAnnotationUID } = referencedToolData;\n    if (parentAnnotationUID) {\n        const parentReferenced = annotationState.state.getAnnotation(parentAnnotationUID);\n        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);\n        createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n    }\n}\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n    const { viewport } = eventData;\n    const annotations = annotationState.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        if (annotation.interpolationUID === referencedToolData.interpolationUID &&\n            annotation.metadata.sliceIndex === sliceIndex) {\n            return annotation;\n        }\n    }\n}\nfunction _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);\n    const points = interpolated3DPoints.points;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);\n    Object.assign(oldAnnotationData, {\n        metadata: interpolatedAnnotation.metadata,\n        data: interpolatedAnnotation.data,\n    });\n}\nfunction _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {\n    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n    const c1 = PointsManager.fromXYZ(c1ir);\n    const c2 = PointsManager.fromXYZ(c2ir);\n    const { length } = c1;\n    const cInterp = PointsManager.create3(length);\n    const vecSubtract = vec3.create();\n    const vecResult = vec3.create();\n    const c1Source = PointsManager.create3(length);\n    c1Source.kIndex = c1ir.kIndex;\n    const c2Source = PointsManager.create3(length);\n    c2Source.kIndex = c2ir.kIndex;\n    for (let i = 0; i < c1ir.x.length; i++) {\n        if (indices[i]) {\n            const c1point = c1.getPoint(i);\n            const c2point = c2.getPoint(i);\n            c1Source.push(c1point);\n            c2Source.push(c2point);\n            vec3.sub(vecSubtract, c2point, c1point);\n            cInterp.push(vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));\n        }\n    }\n    cInterp.sources = [c1Source, c2Source];\n    return cInterp;\n}\nfunction _generateInterpolationContourPair(c1, c2) {\n    const cumPerim1 = _getCumulativePerimeter(c1);\n    const cumPerim2 = _getCumulativePerimeter(c2);\n    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));\n    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n    const numNodes1 = interpNodes + c2.x.length;\n    const numNodes2 = interpNodes + c1.x.length;\n    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n    _shiftSuperSampledContourInPlace(c1i, c2i);\n    return _reduceContoursToOriginNodes(c1i, c2i);\n}\nfunction _reduceContoursToOriginNodes(c1i, c2i) {\n    const c1Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    const c2Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let i = 0; i < c1i.x.length; i++) {\n        if (c1i.I[i] || c2i.I[i]) {\n            c1Interp.x.push(c1i.x[i]);\n            c1Interp.y.push(c1i.y[i]);\n            c1Interp.z.push(c1i.z[i]);\n            c1Interp.I.push(c1i.I[i]);\n            c2Interp.x.push(c2i.x[i]);\n            c2Interp.y.push(c2i.y[i]);\n            c2Interp.z.push(c2i.z[i]);\n            c2Interp.I.push(c2i.I[i]);\n        }\n    }\n    return {\n        c1Interp,\n        c2Interp,\n    };\n}\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n    const c1iLength = c1i.x.length;\n    const optimal = {\n        startingNode: 0,\n        totalSquaredXYLengths: Infinity,\n    };\n    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n        let node = startingNode;\n        let totalSquaredXYLengths = 0;\n        for (let iteration = 0; iteration < c1iLength; iteration++) {\n            totalSquaredXYLengths +=\n                (c1i.x[node] - c2i.x[iteration]) ** 2 +\n                    (c1i.y[node] - c2i.y[iteration]) ** 2 +\n                    (c1i.z[node] - c2i.z[iteration]) ** 2;\n            node++;\n            if (node === c1iLength) {\n                node = 0;\n            }\n        }\n        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n            optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n            optimal.startingNode = startingNode;\n        }\n    }\n    const node = optimal.startingNode;\n    _shiftCircularArray(c1i.x, node);\n    _shiftCircularArray(c1i.y, node);\n    _shiftCircularArray(c1i.z, node);\n    _shiftCircularArray(c1i.I, node);\n}\nfunction _shiftCircularArray(arr, count) {\n    count -= arr.length * Math.floor(count / arr.length);\n    const slicedArray = arr.splice(0, count);\n    arr.push(...slicedArray);\n    return arr;\n}\nfunction _getSuperSampledContour(c, nodesPerSegment) {\n    const ci = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let n = 0; n < c.x.length - 1; n++) {\n        ci.x.push(c.x[n]);\n        ci.y.push(c.y[n]);\n        ci.z.push(c.z[n]);\n        ci.I.push(true);\n        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n            ci.I.push(false);\n        }\n    }\n    return ci;\n}\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n    const idx = [];\n    for (let i = 0; i < perimInterp.length; ++i) {\n        idx[i] = i;\n    }\n    idx.sort(function (a, b) {\n        return perimInterp[a] < perimInterp[b] ? -1 : 1;\n    });\n    const perimIndSorted = [];\n    for (let i = 0; i < perimInd.length; i++) {\n        perimIndSorted.push(perimInd[idx[i]]);\n    }\n    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {\n        if (elementValue) {\n            arr.push(i);\n        }\n        return arr;\n    }, []);\n    const nodesPerSegment = [];\n    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n    }\n    return nodesPerSegment;\n}\nfunction _getIndicatorArray(numFalse, numTrue) {\n    const perimInd = new Array(numFalse + numTrue);\n    perimInd.fill(false, 0, numFalse);\n    perimInd.fill(true, numFalse, numFalse + numTrue);\n    return perimInd;\n}\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n    const diff = 1 / (numNodes - 1);\n    const linspace = [diff];\n    for (let i = 1; i < numNodes - 2; i++) {\n        linspace.push(linspace[linspace.length - 1] + diff);\n    }\n    return linspace.concat(cumPerimNorm);\n}\nfunction _normalisedCumulativePerimeter(cumPerim) {\n    const cumPerimNorm = [];\n    for (let i = 0; i < cumPerim.length; i++) {\n        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n    }\n    return cumPerimNorm;\n}\nfunction _getCumulativePerimeter(contour) {\n    const cumulativePerimeter = [0];\n    for (let i = 1; i < contour.x.length; i++) {\n        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +\n            (contour.y[i] - contour.y[i - 1]) ** 2 +\n            (contour.z[i] - contour.z[i - 1]) ** 2);\n        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n    }\n    return cumulativePerimeter;\n}\nfunction _generateClosedContour(points) {\n    const c = {\n        x: [],\n        y: [],\n        z: [],\n    };\n    for (let i = 0; i < points.length; i++) {\n        c.x[i] = points[i][0];\n        c.y[i] = points[i][1];\n        c.z[i] = points[i][2];\n    }\n    c.x.push(c.x[0]);\n    c.y.push(c.y[0]);\n    c.z.push(c.z[0]);\n    return c;\n}\nexport default interpolate;\n","import * as annotationState from '../../../stateManagement/annotation';\nexport default function updateChildInterpolationUID(annotation) {\n    const { parentAnnotationUID, annotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return annotation.interpolationUID;\n    }\n    const parentAnnotation = annotationState.state.getAnnotation(parentAnnotationUID);\n    const { interpolationUID } = parentAnnotation;\n    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n    annotation.interpolationUID = `${interpolationUID}-${index}`;\n    return annotation.interpolationUID;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { Calculator, InstanceCalculator } from './Calculator';\nconst { PointsManager } = utilities;\nfunction createBasicStatsState(storePointData) {\n    return {\n        max: [-Infinity],\n        min: [Infinity],\n        sum: [0],\n        count: 0,\n        maxIJK: null,\n        maxLPS: null,\n        minIJK: null,\n        minLPS: null,\n        runMean: [0],\n        m2: [0],\n        m3: [0],\n        m4: [0],\n        allValues: [[]],\n        pointsInShape: storePointData ? PointsManager.create3(1024) : null,\n        sumLPS: [0, 0, 0],\n    };\n}\nfunction basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {\n    if (Array.isArray(newValue) &&\n        newValue.length > 1 &&\n        state.max.length === 1) {\n        state.max.push(state.max[0], state.max[0]);\n        state.min.push(state.min[0], state.min[0]);\n        state.sum.push(state.sum[0], state.sum[0]);\n        state.runMean.push(0, 0);\n        state.m2.push(state.m2[0], state.m2[0]);\n        state.m3.push(state.m3[0], state.m3[0]);\n        state.m4.push(state.m4[0], state.m4[0]);\n        state.allValues.push([], []);\n    }\n    if (state?.pointsInShape && pointLPS) {\n        state.pointsInShape.push(pointLPS);\n    }\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    state.count += 1;\n    if (pointLPS) {\n        state.sumLPS[0] += pointLPS[0];\n        state.sumLPS[1] += pointLPS[1];\n        state.sumLPS[2] += pointLPS[2];\n    }\n    state.max.forEach((it, idx) => {\n        const value = newArray[idx];\n        state.allValues[idx].push(value);\n        const n = state.count;\n        const delta = value - state.runMean[idx];\n        const delta_n = delta / n;\n        const term1 = delta * delta_n * (n - 1);\n        state.sum[idx] += value;\n        state.runMean[idx] += delta_n;\n        state.m4[idx] +=\n            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +\n                6 * delta_n * delta_n * state.m2[idx] -\n                4 * delta_n * state.m3[idx];\n        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];\n        state.m2[idx] += term1;\n        if (value < state.min[idx]) {\n            state.min[idx] = value;\n            if (idx === 0) {\n                state.minIJK = pointIJK ? [...pointIJK] : null;\n                state.minLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n        if (value > state.max[idx]) {\n            state.max[idx] = value;\n            if (idx === 0) {\n                state.maxIJK = pointIJK ? [...pointIJK] : null;\n                state.maxLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n    });\n}\nfunction calculateMedian(values) {\n    if (values.length === 0) {\n        return 0;\n    }\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    else {\n        return sorted[mid];\n    }\n}\nfunction basicGetStatistics(state, unit) {\n    const mean = state.sum.map((sum) => sum / state.count);\n    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));\n    const center = state.sumLPS.map((sum) => sum / state.count);\n    const skewness = state.m3.map((m3, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m3 / (state.count * Math.pow(variance, 1.5));\n    });\n    const kurtosis = state.m4.map((m4, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m4 / (state.count * variance * variance) - 3;\n    });\n    const median = state.allValues.map((values) => calculateMedian(values));\n    const named = {\n        max: {\n            name: 'max',\n            label: 'Max Pixel',\n            value: state.max.length === 1 ? state.max[0] : state.max,\n            unit,\n            pointIJK: state.maxIJK ? [...state.maxIJK] : null,\n            pointLPS: state.maxLPS ? [...state.maxLPS] : null,\n        },\n        min: {\n            name: 'min',\n            label: 'Min Pixel',\n            value: state.min.length === 1 ? state.min[0] : state.min,\n            unit,\n            pointIJK: state.minIJK ? [...state.minIJK] : null,\n            pointLPS: state.minLPS ? [...state.minLPS] : null,\n        },\n        mean: {\n            name: 'mean',\n            label: 'Mean Pixel',\n            value: mean.length === 1 ? mean[0] : mean,\n            unit,\n        },\n        stdDev: {\n            name: 'stdDev',\n            label: 'Standard Deviation',\n            value: stdDev.length === 1 ? stdDev[0] : stdDev,\n            unit,\n        },\n        count: {\n            name: 'count',\n            label: 'Voxel Count',\n            value: state.count,\n            unit: null,\n        },\n        median: {\n            name: 'median',\n            label: 'Median',\n            value: median.length === 1 ? median[0] : median,\n            unit,\n        },\n        skewness: {\n            name: 'skewness',\n            label: 'Skewness',\n            value: skewness.length === 1 ? skewness[0] : skewness,\n            unit: null,\n        },\n        kurtosis: {\n            name: 'kurtosis',\n            label: 'Kurtosis',\n            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,\n            unit: null,\n        },\n        maxLPS: {\n            name: 'maxLPS',\n            label: 'Max LPS',\n            value: state.maxLPS ? Array.from(state.maxLPS) : null,\n            unit: null,\n        },\n        minLPS: {\n            name: 'minLPS',\n            label: 'Min LPS',\n            value: state.minLPS ? Array.from(state.minLPS) : null,\n            unit: null,\n        },\n        pointsInShape: state.pointsInShape,\n        center: {\n            name: 'center',\n            label: 'Center',\n            value: center ? [...center] : null,\n            unit: null,\n        },\n        array: [],\n    };\n    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);\n    if (named.center.value) {\n        named.array.push(named.center);\n    }\n    const store = state.pointsInShape !== null;\n    const freshState = createBasicStatsState(store);\n    state.max = freshState.max;\n    state.min = freshState.min;\n    state.sum = freshState.sum;\n    state.count = freshState.count;\n    state.maxIJK = freshState.maxIJK;\n    state.maxLPS = freshState.maxLPS;\n    state.minIJK = freshState.minIJK;\n    state.minLPS = freshState.minLPS;\n    state.runMean = freshState.runMean;\n    state.m2 = freshState.m2;\n    state.m3 = freshState.m3;\n    state.m4 = freshState.m4;\n    state.allValues = freshState.allValues;\n    state.pointsInShape = freshState.pointsInShape;\n    state.sumLPS = freshState.sumLPS;\n    return named;\n}\nexport class BasicStatsCalculator extends Calculator {\n    static { this.state = createBasicStatsState(true); }\n    static statsInit(options) {\n        if (!options.storePointData) {\n            this.state.pointsInShape = null;\n        }\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {\n        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);\n    }; }\n    static { this.getStatistics = (options) => {\n        return basicGetStatistics(this.state, options?.unit);\n    }; }\n}\nexport class InstanceBasicStatsCalculator extends InstanceCalculator {\n    constructor(options) {\n        super(options);\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsInit(options) {\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsCallback(data) {\n        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);\n    }\n    getStatistics(options) {\n        return basicGetStatistics(this.state, options?.unit);\n    }\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End, infinite = false) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    if (infinite) {\n        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (Math.abs(denom) < 1e-10) {\n            return undefined;\n        }\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        const x = x1 + t * (x2 - x1);\n        const y = y1 + t * (y2 - y1);\n        return [x, y];\n    }\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return undefined;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return undefined;\n    }\n    const denomSegment = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denomSegment;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denomSegment;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n","import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldSmooth(configuration, annotation) {\n    if (annotation?.autoGenerated) {\n        return false;\n    }\n    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||\n        configuration?.smoothing?.smoothOnEdit === true;\n    return shouldSmooth;\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation, smoothing } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n","import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {\n    if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        if (!imageId) {\n            return [];\n        }\n        const colonIndex = imageId.indexOf(':');\n        filterOptions.imageURI = imageId.substring(colonIndex + 1);\n    }\n    return annotations.filter((annotation) => {\n        if (!annotation.isVisible) {\n            return false;\n        }\n        if (annotation.data.isCanvasAnnotation) {\n            return true;\n        }\n        return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n    });\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport function filterAnnotationsWithinSamePlane(annotations, camera) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    return annotationsWithParallelNormals;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        const { planeRestriction, referencedImageId } = td.metadata;\n        let { viewPlaneNormal: annotationViewPlaneNormal } = td.metadata;\n        if (planeRestriction) {\n            const { inPlaneVector1, inPlaneVector2 } = planeRestriction;\n            if (inPlaneVector1 &&\n                !isEqual(0, vec3.dot(viewPlaneNormal, inPlaneVector1))) {\n                return false;\n            }\n            if (inPlaneVector2 &&\n                !isEqual(0, vec3.dot(viewPlaneNormal, inPlaneVector2))) {\n                return false;\n            }\n            return true;\n        }\n        if (!td.metadata.referencedImageId &&\n            !annotationViewPlaneNormal &&\n            td.metadata.FrameOfReferenceUID) {\n            for (const point of td.data.handles.points) {\n                const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                const dotProduct = vec3.dot(vector, viewPlaneNormal);\n                if (!isEqual(dotProduct, 0)) {\n                    return false;\n                }\n            }\n            td.metadata.viewPlaneNormal = viewPlaneNormal;\n            td.metadata.cameraFocalPoint = camera.focalPoint;\n            return true;\n        }\n        if (!annotationViewPlaneNormal && referencedImageId) {\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const { data, metadata, isVisible } = annotation;\n        if (!isVisible) {\n            continue;\n        }\n        const point = metadata.planeRestriction?.point ||\n            data.handles.points[0] ||\n            data.contour?.polyline[0];\n        if (!point) {\n            annotationsWithinSlice.push(annotation);\n            continue;\n        }\n        const dir = vec3.sub(vec3.create(), focalPoint, point);\n        const dot = Math.abs(vec3.dot(dir, viewPlaneNormal));\n        if (dot < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const points = getPointsInLineOfSight(viewport, worldPos, {\n        targetVolumeId,\n        stepSize,\n    });\n    let pickedPoint;\n    for (const point of points) {\n        const intensity = viewport.getIntensityFromWorld(point);\n        const pointToPick = criteriaFunction(intensity, point);\n        if (pointToPick) {\n            pickedPoint = pointToPick;\n        }\n    }\n    return pickedPoint;\n}\nexport function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal: normalDirection } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize || 1;\n    const bounds = viewport.getBounds();\n    const points = [];\n    let currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] += normalDirection[0] * step;\n        currentPos[1] += normalDirection[1] * step;\n        currentPos[2] += normalDirection[2] * step;\n    }\n    currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] -= normalDirection[0] * step;\n        currentPos[1] -= normalDirection[1] * step;\n        currentPos[2] -= normalDirection[2] * step;\n    }\n    return points;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    const padding = 10;\n    return (point[0] > xMin + padding &&\n        point[0] < xMax - padding &&\n        point[1] > yMin + padding &&\n        point[1] < yMax - padding &&\n        point[2] > zMin + padding &&\n        point[2] < zMax - padding);\n};\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {\n    const vertices = [\n        vec3.fromValues(minX, minY, minZ),\n        vec3.fromValues(maxX, minY, minZ),\n        vec3.fromValues(minX, maxY, minZ),\n        vec3.fromValues(maxX, maxY, minZ),\n        vec3.fromValues(minX, minY, maxZ),\n        vec3.fromValues(maxX, minY, maxZ),\n        vec3.fromValues(minX, maxY, maxZ),\n        vec3.fromValues(maxX, maxY, maxZ),\n    ];\n    const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n    const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n    const planeDistance = -vec3.dot(normalVec, originVec);\n    let initialSign = null;\n    for (const vertex of vertices) {\n        const distance = vec3.dot(normalVec, vertex) + planeDistance;\n        if (initialSign === null) {\n            initialSign = Math.sign(distance);\n        }\n        else if (Math.sign(distance) !== initialSign) {\n            return true;\n        }\n    }\n    return false;\n};\n","import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport EventTypes from '../../../enums/Events';\nexport default function deleteRelatedAnnotations(viewportData) {\n    const { annotation } = viewportData;\n    const interpolationAnnotations = getInterpolationData(viewportData, [\n        { key: 'interpolationUID', value: viewportData.interpolationUID },\n    ]);\n    const referencedSliceIndex = annotation.metadata.sliceIndex;\n    let minInterpolation = -1;\n    let maxInterpolation = viewportData.sliceData.numberOfSlices;\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);\n        if (!nonInterpolated) {\n            continue;\n        }\n        if (sliceIndex < referencedSliceIndex) {\n            minInterpolation = Math.max(sliceIndex, minInterpolation);\n        }\n        else {\n            maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n        }\n    }\n    const removedAnnotations = [];\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex <= minInterpolation ||\n            sliceIndex >= maxInterpolation ||\n            sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        annotations.forEach((annotationToDelete) => {\n            if (annotationToDelete.autoGenerated) {\n                annotationStateManagement.state.removeAnnotation(annotationToDelete.annotationUID);\n                removedAnnotations.push(annotationToDelete);\n            }\n        });\n    }\n    if (removedAnnotations.length) {\n        const eventDetails = {\n            annotations: removedAnnotations,\n            element: viewportData.viewport.element,\n            viewportId: viewportData.viewport.id,\n            renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n        };\n        triggerEvent(viewportData.viewport.element, EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);\n    }\n    if (minInterpolation >= 0 &&\n        maxInterpolation < viewportData.sliceData.numberOfSlices) {\n        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];\n        const viewportNewData = {\n            viewport: viewportData.viewport,\n            sliceData: {\n                numberOfSlices: viewportData.sliceData.numberOfSlices,\n                imageIndex: nextAnnotation.metadata.sliceIndex,\n            },\n            annotation: nextAnnotation,\n            interpolationUID: nextAnnotation.interpolationUID,\n        };\n        interpolate(viewportNewData);\n    }\n}\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport addRepresentationData from '../../stateManagement/segmentation/internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport debounce from '../debounce';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n","import { SegmentationRepresentations } from '../../enums';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';\nimport { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';\nexport function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {\n    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActive = activeSegmentation?.segmentationId === segmentationId;\n    const style = segmentationStyle.getStyle({\n        viewportId,\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n        segmentIndex,\n    });\n    const mergedConfig = style;\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n    if (autoGenerated) {\n        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    }\n    else if (isActive) {\n        lineWidth = mergedConfig.outlineWidth ?? lineWidth;\n        lineDash = mergedConfig.outlineDash ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    }\n    else {\n        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n        lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {\n        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const isVisible = !hiddenSegments.has(segmentIndex);\n    return {\n        color,\n        fillColor,\n        lineWidth,\n        fillOpacity,\n        lineDash,\n        textbox: {\n            color,\n        },\n        visibility: segmentationVisible && isVisible,\n    };\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n"],"names":["annotationUID","drawingElementType","nodeUID","evt","shiftKey","ctrlKey","ShiftCtrl","altKey","ShiftAlt","metaKey","ShiftMeta","Shift","CtrlAlt","CtrlMeta","Ctrl","AltMeta","Alt","Meta","defaultManager","resetAnnotationManager","setAnnotationManager","setPreprocessingFn","annotation","uid","data","cachedStats","checkAndDefineCachedStatsProperty","handles","textBox","checkAndDefineTextBoxProperty","isLocked","checkAndSetAnnotationLocked","isVisible","checkAndSetAnnotationVisibility","triggerSegmentationAdded","segmentationId","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_ADDED","triggerSegmentationModified","SEGMENTATION_MODIFIED","triggerSegmentationRemoved","SEGMENTATION_REMOVED","triggerSegmentationRepresentationModified","viewportId","type","SEGMENTATION_REPRESENTATION_MODIFIED","triggerSegmentationRepresentationRemoved","SEGMENTATION_REPRESENTATION_REMOVED","internalGetHiddenSegmentIndices","specifier","representation","Set","Object","entries","segments","reduce","acc","segmentIndex","segment","visible","add","Number","MODES","ToolModes","Active","Passive","Enabled","toolName","toolGroups","filter","toolOptions","toolGroupToolNames","keys","i","length","includes","mode","getSubPixelSpacingAndXYDirections","addCanvasPointsToArray","getArea","polyline","activateClosedContourEdit","viewportIdsToRender","this","isEditingClosed","detail","currentPoints","element","canvasPos","canvas","enabledElement","getEnabledElement","viewport","prevCanvasPoints","contour","map","worldToCanvas","spacing","xDir","yDir","configuration","subPixelResolution","editData","editCanvasPoints","startCrossingIndex","undefined","editIndex","commonData","movingTextBox","isInteractingWithTool","addEventListener","MOUSE_UP","mouseUpClosedContourEditCallback","MOUSE_DRAG","mouseDragClosedContourEditCallback","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","hideElementCursor","deactivateClosedContourEdit","removeEventListener","resetElementCursor","worldPos","world","createMemo","lastCanvasPoint","lastWorldPoint","canvasToWorld","worldPosDiff","xDist","Math","abs","yDist","checkAndRemoveCrossesOnEditLine","currentEditIndex","checkForFirstCrossing","snapIndex","findSnapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","checkForSecondCrossing","removePointsAfterSecondCrossing","finishEditAndStartNewEdit","renderingEngine","points","closed","targetWindingDirection","Clockwise","autoGenerated","triggerAnnotationModified","lastEditCanvasPoint","pop","augmentedEditCanvasPoints","lowIndex","highIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","canvasPoint","push","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","doneEditMemo","updatedPoints","decimateConfig","decimate","enabled","epsilon","cancelClosedContourEdit","toolInstance","bind","pointsAreWithinCloseContourProximity","getFirstLineSegmentIntersectionIndexes","activateDraw","isDrawing","contourHoleProcessingEnabled","event","contourHoleAdditionModifierKey","drawData","canvasPoints","polylineIndex","newAnnotation","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","deltaPoints","worldPosDelta","worldPosition","hasMoved","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","invalidated","ChangeTypes","HandlesUpdated","allowOpenContours","firstPoint","lastPoint","closeContourProximity","completeDrawOpenContour","completeDrawClosedContour","options","removeCrossedLinesOnCompleteDraw","minPointsToSave","haltDrawing","updateContourPolyline","triggerContourAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","slice","lineSegment","indexToRemoveUpTo","splice","worldPoints","isOpenUShapeContour","openUShapeContourVectorToPeak","lastPoints","pointsLessLastOne","remainingPoints","newArea","utilities","cancelDrawing","minPoints","max","shouldHaltDrawing","removeAnnotation","isClosedContour","crossedLineSegment","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","distance","index","sort","a","b","twoClosestDistanceIndexPairs","lowestIndex","min","dir","proximity","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","unshift","numPointsToRemove","firstLine","lastLine","didCrossLine","editCanvasPointsLessLastOne","snapCanvasPosition","editIndexCrossed","findOpenUShapedContourVectorToPeak","first","last","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","dist","findOpenUShapedContourVectorToPeakOnRender","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activeHandleIndex","activateOpenContourEndEdit","lastCanvasPos","p1","p2","p3","aDotb","magA","sqrt","magB","acos","PI","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","handle","reverse","_getRenderingOptions","styleSpecifier","toolGroupId","getToolName","id","lineWidth","lineDash","color","fillColor","fillOpacity","getAnnotationStyle","width","closePath","renderContour","svgDrawingHelper","getImageData","renderClosedContour","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","parentAnnotationUID","allContours","drawPath","drawPolyline","alwaysRenderOpenContourHandles","radius","handleGroupUID","handlePoints","shift","drawHandles","handleRadius","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","canvasPolyline","childContours","center","circlePoints","angle","x","cos","y","sin","crosshair","polylineUID","DefaultHistoryMemo","PointsManager","AnnotationTool","A","createAnnotationForViewport","annotationBaseData","createAnnotation","metadata","getViewReference","createAndAddAnnotation","addAnnotation","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","isAnnotationLocked","isAnnotationVisible","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","highlighted","notNearToolAndMarkedActive","isSuvScaled","getTextLines","statsCalculator","getHandleNearImagePoint","isCanvasAnnotation","worldBoundingBox","canvasBoundingBox","topLeft","topRight","bottomLeft","bottomRight","point","annotationCanvasCoordinate","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","shadow","background","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","context","property","locked","angleArcLineDash","markerSize","lineOpacity","textbox","isPointNearTool","createAnnotationState","deleting","cloneData","spline","state","structuredClone","pointsManager","create3","createAnnotationMemo","annotationMemo","restoreMemo","newState","setViewReference","assign","annotationData","segmentation","addContourSegmentationAnnotation","setAnnotationSelected","render","currentAnnotation","getAnnotation","History","console","warn","operationType","memo","startGroupRecording","endGroupRecording","hydrateBase","ToolClass","FrameOfReferenceUID","getFrameOfReferenceUID","camera","getCamera","viewPlaneNormal","viewplaneNormal","viewUp","instance","referencedImageId","finalViewPlaneNormal","finalViewUp","StackViewport","closestImageIndex","getImageIds","Error","getReferencedImageId","ContourBaseTool","renderAnnotation","renderStatus","getRenderingEngine","annotations","getAnnotations","filterInteractableAnnotationsForElement","getTargetId","annotationStyle","annotationRendered","renderAnnotationInstance","interpolationUID","cancelAnnotation","moveAnnotation","getChildAnnotations","forEach","childAnnotation","polylineData","transforms","updateWindingDirection","getPolylinePoints","renderContext","polylineCanvasPoints","getContourHolesDataCanvas","ContourSegmentationBaseTool","PreviewSegmentIndex","interpolation","InterpolationManager","addTool","onSetToolConfiguration","removeTool","isContourSegmentationTool","contourAnnotation","activeSeg","getActiveSegmentation","representationData","Contour","getActiveSegmentIndex","contourSegAnnotation","removeContourSegmentationAnnotation","contourSegmentationStyle","_getContourSegmentationStyle","renderResult","triggerSegmentationDataModified","toolGroupIds","getViewportIdsWithSegmentation","getToolGroupForViewport","triggerAnnotationRenderForToolGroupIds","segmentationRepresentations","getSegmentationRepresentation","segmentationRepresentation","find","rep","SegmentationRepresentations","annotationLocked","getLockedSegmentIndices","getSVGStyleForSegment","defaultContourConfig","renderOutline","outlineWidthAutoGenerated","outlineWidth","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","outlineDash","outlineDashInactive","outlineDashAutoGenerated","activeSegmentOutlineWidthDelta","renderFill","fillAlpha","fillAlphaInactive","fillAlphaAutoGenerated","handleContourSegmentation","geometryIds","annotationUIDsMap","contourRepresentation","size","segmentSpecificMap","Map","geometryId","geometry","getGeometry","Enums","CONTOUR","validateGeometry","segmentSpecificConfig","contourSet","contours","contourSegmentationAnnotation","annotationGroupSelector","set","addContourSetsToElement","removeFromCache","annotationSet","internalCache","load","cfun","ofun","actor","getProperty","setRGBTransferFunction","setScalarOpacity","uuidv4","async","labelMapData","config","getSegmentation","Labelmap","_ensureVolumeHasVolumeId","stackData","imageIds","volumeLoader","_handleMissingVolume","blendMode","MAXIMUM_INTENSITY_BLEND","useIndependentComponents","LABELMAP_EDGE_PROJECTION_BLEND","referenceVolumeId","getVolumeId","baseVolume","segDims","dimensions","refDims","debug","volumeInputs","representationUID","result","defaultActor","getDefaultActor","callback","get","added","volumeInputArray","firstImageVolume","segImageVolume","segData","voxelManager","getCompleteScalarDataArray","imageData","segImageData","baseData","cubeData","Float32Array","getScalarDataLength","dims","getDimensions","z","iTuple","removeActors","oldMapper","getMapper","mapper","convertMapperToNotSharedMapper","setMapper","setBlendMode","arrayAgain","getInputData","getPointData","getArray","onSegmentationDataModified","segVolumeId","segVoxelManager","array","getData","slices","Array","from","_","getAtIndex","setData","modified","setNumberOfComponents","setColorMixPreset","setForceNearestInterpolation","setIndependentComponents","addActor","referencedId","segmentationRepresentationUID","originalBlendMode","getBlendMode","preLoad","addEventListenerDebounced","SEGMENTATION_DATA_MODIFIED","actorEntry","getActor","createVolumeActor","volumeActor","addVolumesAsIndependentComponents","addVolumesToViewports","stackInputs","addImageSlicesToViewports","defaultLabelmapConfig","renderOutlineInactive","renderFillInactive","surface","surfaceActorEntry","surfaceActor","setVisibility","surfaceMapper","currentPolyData","newPoints","newPolys","polys","getPoints","currentPolys","getPolys","polyData","triangles","values","setPolys","setInputData","getRenderer","resetCameraClippingRange","surfacePolyData","setColor","setLineWidth","clippingFilter","resetCamera","filteredSurfaceActors","getActors","startsWith","BrushStrategy","COMPOSITIONS","childFunctions","StrategyCallbacks","OnInteractionStart","addListMethod","Initialize","OnInteractionEnd","Fill","CreateIsInThreshold","addSingletonMethod","Interpolate","AcceptPreview","RejectPreview","INTERNAL_setValue","Preview","ComputeInnerCircleRadius","EnsureSegmentationVolumeFor3DManipulation","EnsureImageVolumeFor3DManipulation","AddPreview","GetStatistics","compositions","name","initializers","_initialize","_fill","_onInteractionStart","fill","operationData","initializedData","initialize","func","segmentationVoxelManager","getArrayOfModifiedSlices","onInteractionStart","call","addPreview","configurationName","initializer","key","strategyFunction","operationName","strategy","imageVoxelManager","segmentationImageData","centerWorld","isInObject","isInObjectBoundsIJK","brushStrategy","createInitialized","listName","args","returnValue","value","isInitialized","previewSegmentIndex","centerIJK","useCenterSegmentIndex","centerSegmentIndexInfo","hasSegmentIndex","hasPreviewIndex","nestedBounds","getBoundsIJK","boundsIJK","existingValue","getAtIJKPoint","threshold","isDynamic","range","oldThreshold","dynamicRadius","useDelta","ijk","idx","Infinity","useDeltaSqr","pointIJK","gray","isArray","dynamicRadiusInCanvas","centerCanvas","clientWidth","clientHeight","radiusInWorld","offSetCenterInWorld","coord","offSetCenterCanvas","activeStrategy","islandRemoval","floodFillSegmentIsland","removeExternalIslands","removeInternalIslands","arrayOfSlices","preview","onInteractionEnd","previewColor","viewportIds","setSegmentIndexColor","changedIndices","labelmapMemo","oldValue","setAtIndex","undoIf","hasPreviewSegmentIndex","segmentsLocked","isWithinThreshold","createIsInThreshold","setValue","addPoint","useSegmentIndex","previewOnHover","centerSegmentIndex","handleUseSegmentCenterIndex","voxelValue","indices","getStatistics","segmentIndices","determineSegmentIndex","dynamicThreshold","erase","regionFill","labelmapStatistics","ensureSegmentationVolumeFor3DManipulation","ensureImageVolumeFor3DManipulation","eraseInsideCircle","eraseInsideSphere","transformWorldToIndex","sphereComposition","baseExtent","canvasCoordinates","p","cornersInWorld","corner","strokeRadius","strokeCenters","strokePointsWorld","baseBounds","baseCenterIJK","boundsToUse","centerPoint","translatedCenterIJK","deltaIJK","translatedBounds","SPHERE_STRATEGY","fillInsideSphere","SPHERE_THRESHOLD_STRATEGY","SPHERE_THRESHOLD_STRATEGY_ISLAND","thresholdInsideSphere","thresholdInsideSphereIsland","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","orderedPoints","pointsArrayWithPrecision","flat","toFixed","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","DEFAULT_CONTOUR_SEG_TOOLNAME","getInterpolationData","viewportData","filterParams","sliceData","interpolationDatas","originalToolName","testToolName","modifiedAnnotations","numberOfSlices","imageAnnotations","sliceIndex","filteredInterpolatedAnnotations","imageAnnotation","every","parent","parentKey","item","getInterpolationDataCollection","interpolatedDataCollection","createPolylineToolData","referencedToolData","childAnnotationUIDs","interpolationSources","sources","_sliceNeedsInterpolating","interpolationData","_appendInterpolationList","contourPair","interpolationList","itemIndex","startIndex","pair","list","_getBoundingPair","sliceRange","annotationPair","canInterpolate","rangeToInterpolate","found","getRangeToInterpolate","sliceEdited","j","_getSlicePositionOfToolData","selectHandles","handleCount","destPoints","sourcePoints","subselect","interval","floor","dotValues","prevVec3","nextVec3","getPoint","prevPoint","nextPoint","dot","createDotValues","minimumRegions","deviation","sum","sumSq","mean","valueDiff","getStats","inflection","minValue","minIndex","findMinimumRegions","lastHandle","thirdInterval","region","start","end","midIndex","ceil","addInterval","firstHandle","indexValue","getPointArray","source","destSourceIndex","finish","count","v","round","dP","_linearlyInterpolateBetween","eventData","annotation0","annotation1","c1","_generateClosedContour","c2","c1Interp","c2Interp","cumPerim1","_getCumulativePerimeter","cumPerim2","interpNodes","cumPerim1Norm","_normalisedCumulativePerimeter","cumPerim2Norm","numNodes1","numNodes2","perim1Interp","_getInterpolatedPerim","perim2Interp","perim1Ind","_getIndicatorArray","perim2Ind","nodesPerSegment1","_getNodesPerSegment","nodesPerSegment2","c1i","_getSuperSampledContour","c2i","c1iLength","optimal","startingNode","totalSquaredXYLengths","node","iteration","_shiftCircularArray","I","_shiftSuperSampledContourInPlace","_reduceContoursToOriginNodes","_generateInterpolationContourPair","kIndex","c1HasMoreNodes","endIndex","zInterp","interpolated3DPoints","c1ir","c2ir","fromXYZ","cInterp","vecSubtract","vecResult","c1Source","c2Source","c1point","c2point","_generateInterpolatedOpenContour","nearestAnnotation","has","oldAnnotationData","_findExistingAnnotation","interpolatedAnnotation","_editInterpolatedContour","viewRef","onInterpolationComplete","parentAnnotation","createPolylineHole","_addInterpolatedContour","_linearlyInterpolateContour","arr","slicedArray","c","nodesPerSegment","ci","n","xSpacing","ySpacing","zSpacing","perimInterp","perimInd","perimIndSorted","indicesOfOriginNodes","elementValue","numFalse","numTrue","numNodes","cumPerimNorm","diff","linspace","concat","cumPerim","cumulativePerimeter","lengthOfSegment","isInterpolationUpdate","queueMicrotask","indexOf","updateChildInterpolationUID","toolType","renderingEngineId","eventDetails","ANNOTATION_INTERPOLATION_PROCESS_COMPLETED","startInterpolation","createBasicStatsState","storePointData","maxIJK","maxLPS","minIJK","minLPS","runMean","m2","m3","m4","allValues","pointsInShape","sumLPS","basicStatsCallback","newValue","pointLPS","newArray","it","delta","delta_n","term1","basicGetStatistics","unit","stdDev","squaredDiffSum","skewness","variance","pow","kurtosis","median","sorted","mid","calculateMedian","named","label","freshState","BasicStatsCalculator","statsInit","statsCallback","InstanceBasicStatsCalculator","distanceToPoint","lineStart","lineEnd","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","infinite","x1","y1","x2","y2","x3","y3","x4","y4","denom","t","a1","b1","r3","r4","a2","b2","r1","r2","denomSegment","num","rect","left","top","height","minDistance","lineSegments","right","bottom","rectToLineSegments","interpolatePoints","originalPoints","knotsIndexes","xInterpolator","k","yInterpolator","zInterpolator","shouldSmooth","smoothing","smoothOnAdd","smoothOnEdit","isEqual","pointA","pointB","followingIndex","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","knotsRatioPercentage","changedIniIndex","changedEndIndex","filterAnnotationsForDisplay","filterOptions","VolumeViewport","spacingInNormalDirection","getCurrentImageId","colonIndex","imageURI","substring","isReferenceViewable","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","filterAnnotationsWithinSamePlane","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","filterAnnotationsWithinSlice","planeRestriction","inPlaneVector1","inPlaneVector2","vector","focalPoint","dotProduct","cameraFocalPoint","halfSpacingInNormalDirection","annotationsWithinSlice","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","getPointsInLineOfSight","pickedPoint","pointToPick","getIntensityFromWorld","normalDirection","step","bounds","getBounds","currentPos","_inBounds","xMin","xMax","yMin","yMax","zMin","zMax","padding","getWorldWidthAndHeightFromCorners","topLeftWorld","bottomRightWorld","viewRight","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getWorldWidthAndHeightFromTwoPoints","worldPos1","worldPos2","isPlaneIntersectingAABB","origin","normal","minX","minY","minZ","maxX","maxY","maxZ","vertices","normalVec","originVec","planeDistance","initialSign","vertex","deleteRelatedAnnotations","interpolationAnnotations","referencedSliceIndex","minInterpolation","maxInterpolation","nonInterpolated","removedAnnotations","annotationToDelete","INTERPOLATED_ANNOTATIONS_REMOVED","nextAnnotation","viewportNewData","imageIndex","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","onComputationComplete","representations","debouncedUpdateFunction","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","segmentColor","getSegmentIndexColor","segmentationVisible","activeSegmentation","isActive","mergedConfig","getViewportIdsWithToolToRender","requireParallelNormals","viewports","getViewports","getViewport","vp"],"sourceRoot":""}