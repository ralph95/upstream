{"version":3,"file":"4113.bundle.bf3151f7c4ef4880bbb4.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/enums.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getRenderableData.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/toolNames.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addSRAnnotation.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/isRehydratable.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/id.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getFilteredCornerstoneToolState.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getLabelFromDCMJSImportedToolData.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/hydrateStructuredReport.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/DICOMSRDisplayTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/SCOORD3DPointTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/SRSCOOR3DProbeMapper.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addToolInstance.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/init.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/onModeEnter.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/modules/dicomSRModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/createReferencedImageDisplaySet.ts"],"sourcesContent":["import { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\r\n\r\nexport const SCOORDTypes = {\r\n  POINT: 'POINT',\r\n  MULTIPOINT: 'MULTIPOINT',\r\n  POLYLINE: 'POLYLINE',\r\n  CIRCLE: 'CIRCLE',\r\n  ELLIPSE: 'ELLIPSE',\r\n};\r\n\r\nexport const CodeNameCodeSequenceValues = {\r\n  ImagingMeasurementReport: '126000',\r\n  ImageLibrary: '111028',\r\n  ImagingMeasurements: '126010',\r\n  MeasurementGroup: '125007',\r\n  ImageLibraryGroup: '126200',\r\n  TrackingUniqueIdentifier: '112040',\r\n  TrackingIdentifier: '112039',\r\n  Finding: '121071',\r\n  FindingSite: 'G-C0E3', // SRT\r\n  FindingSiteSCT: '363698007', // SCT\r\n};\r\n\r\nexport const CodingSchemeDesignators = {\r\n  SRT: 'SRT',\r\n  SCT: 'SCT',\r\n  CornerstoneCodeSchemes: [Cornerstone3DCodeScheme.CodingSchemeDesignator, 'CST4'],\r\n};\r\n\r\nexport const RelationshipType = {\r\n  INFERRED_FROM: 'INFERRED FROM',\r\n  CONTAINS: 'CONTAINS',\r\n};\r\n\r\nconst enums = {\r\n  CodeNameCodeSequenceValues,\r\n  CodingSchemeDesignators,\r\n  RelationshipType,\r\n  SCOORDTypes,\r\n};\r\n\r\nexport default enums;\r\n","import { vec3 } from 'gl-matrix';\r\nimport { metaData, utilities, Types as csTypes } from '@cornerstonejs/core';\r\n\r\nimport { SCOORDTypes } from '../enums';\r\n\r\nconst EPSILON = 1e-4;\r\n\r\nconst getRenderableCoords = ({ GraphicData, ValueType, imageId }) => {\r\n  const renderableData = [];\r\n  if (ValueType === 'SCOORD3D') {\r\n    for (let i = 0; i < GraphicData.length; i += 3) {\r\n      renderableData.push([GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]]);\r\n    }\r\n  } else {\r\n    for (let i = 0; i < GraphicData.length; i += 2) {\r\n      const worldPos = utilities.imageToWorldCoords(imageId, [GraphicData[i], GraphicData[i + 1]]);\r\n      renderableData.push(worldPos);\r\n    }\r\n  }\r\n  return renderableData;\r\n};\r\n\r\nfunction getRenderableData({ GraphicType, GraphicData, ValueType, imageId }) {\r\n  let renderableData = [];\r\n\r\n  switch (GraphicType) {\r\n    case SCOORDTypes.POINT:\r\n    case SCOORDTypes.MULTIPOINT:\r\n    case SCOORDTypes.POLYLINE: {\r\n      renderableData = getRenderableCoords({ GraphicData, ValueType, imageId });\r\n      break;\r\n    }\r\n    case SCOORDTypes.CIRCLE: {\r\n      const pointsWorld: csTypes.Point3[] = getRenderableCoords({\r\n        GraphicData,\r\n        ValueType,\r\n        imageId,\r\n      });\r\n\r\n      if (!imageId) {\r\n        // without the image id it's not possible to perform the calculations below\r\n        // these calculations also do not seem to be needed, since everything works\r\n        // just fine when we skip them. At least for SCOORD3D annotations.\r\n        return pointsWorld;\r\n      }\r\n\r\n      // We do not have an explicit draw circle svg helper in Cornerstone3D at\r\n      // this time, but we can use the ellipse svg helper to draw a circle, so\r\n      // here we reshape the data for that purpose.\r\n      const center = pointsWorld[0];\r\n      const onPerimeter = pointsWorld[1];\r\n      const radius = vec3.distance(center, onPerimeter);\r\n\r\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n      if (!imagePlaneModule) {\r\n        throw new Error('No imagePlaneModule found');\r\n      }\r\n\r\n      const {\r\n        columnCosines,\r\n        rowCosines,\r\n      }: {\r\n        columnCosines: csTypes.Point3;\r\n        rowCosines: csTypes.Point3;\r\n      } = imagePlaneModule;\r\n\r\n      // we need to get major/minor axis (which are both the same size major = minor)\r\n\r\n      const firstAxisStart = vec3.create();\r\n      vec3.scaleAndAdd(firstAxisStart, center, columnCosines, radius);\r\n\r\n      const firstAxisEnd = vec3.create();\r\n      vec3.scaleAndAdd(firstAxisEnd, center, columnCosines, -radius);\r\n\r\n      const secondAxisStart = vec3.create();\r\n      vec3.scaleAndAdd(secondAxisStart, center, rowCosines, radius);\r\n\r\n      const secondAxisEnd = vec3.create();\r\n      vec3.scaleAndAdd(secondAxisEnd, center, rowCosines, -radius);\r\n\r\n      renderableData = [\r\n        firstAxisStart as csTypes.Point3,\r\n        firstAxisEnd as csTypes.Point3,\r\n        secondAxisStart as csTypes.Point3,\r\n        secondAxisEnd as csTypes.Point3,\r\n      ];\r\n\r\n      break;\r\n    }\r\n    case SCOORDTypes.ELLIPSE: {\r\n      // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\r\n      // But Cornerstone3D points are ordered as top, bottom, left, right for the\r\n      // ellipse so we need to identify if the majorAxis is horizontal or vertical\r\n      // and then choose the correct points to use for the ellipse.\r\n      const pointsWorld: csTypes.Point3[] = getRenderableCoords({\r\n        GraphicData,\r\n        ValueType,\r\n        imageId,\r\n      });\r\n\r\n      if (!imageId) {\r\n        // without the image id it's not possible to perform the calculations below\r\n        // these calculations also do not seem to be needed, since everything works\r\n        // just fine when we skip them. At least for SCOORD3D annotations.\r\n        return pointsWorld;\r\n      }\r\n\r\n      const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\r\n      const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\r\n      const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\r\n      const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\r\n\r\n      const majorAxisVec = vec3.create();\r\n      vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\r\n\r\n      // normalize majorAxisVec to avoid scaling issues\r\n      vec3.normalize(majorAxisVec, majorAxisVec);\r\n\r\n      const minorAxisVec = vec3.create();\r\n      vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\r\n      vec3.normalize(minorAxisVec, minorAxisVec);\r\n\r\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n\r\n      if (!imagePlaneModule) {\r\n        throw new Error('imageId does not have imagePlaneModule metadata');\r\n      }\r\n\r\n      const { columnCosines }: { columnCosines: csTypes.Point3 } = imagePlaneModule;\r\n\r\n      // find which axis is parallel to the columnCosines\r\n      const columnCosinesVec = vec3.fromValues(...columnCosines);\r\n\r\n      const projectedMajorAxisOnColVec = Math.abs(vec3.dot(columnCosinesVec, majorAxisVec));\r\n      const projectedMinorAxisOnColVec = Math.abs(vec3.dot(columnCosinesVec, minorAxisVec));\r\n\r\n      const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\r\n      const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\r\n\r\n      renderableData = [];\r\n      if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\r\n        renderableData = [pointsWorld[0], pointsWorld[1], pointsWorld[2], pointsWorld[3]];\r\n      } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\r\n        renderableData = [pointsWorld[2], pointsWorld[3], pointsWorld[0], pointsWorld[1]];\r\n      } else {\r\n        console.warn('OBLIQUE ELLIPSE NOT YET SUPPORTED');\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      console.warn('Unsupported GraphicType:', GraphicType);\r\n  }\r\n\r\n  return renderableData;\r\n}\r\n\r\nexport default getRenderableData;\r\n","const toolNames = {\r\n  DICOMSRDisplay: 'DICOMSRDisplay',\r\n  SRLength: 'SRLength',\r\n  SRBidirectional: 'SRBidirectional',\r\n  SREllipticalROI: 'SREllipticalROI',\r\n  SRCircleROI: 'SRCircleROI',\r\n  SRArrowAnnotate: 'SRArrowAnnotate',\r\n  SRAngle: 'SRAngle',\r\n  SRCobbAngle: 'SRCobbAngle',\r\n  SRRectangleROI: 'SRRectangleROI',\r\n  SRPlanarFreehandROI: 'SRPlanarFreehandROI',\r\n  SRSCOORD3DPoint: 'SRSCOORD3DPoint',\r\n};\r\n\r\nexport default toolNames;\r\n","import { Types, annotation } from '@cornerstonejs/tools';\r\nimport { metaData } from '@cornerstonejs/core';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nimport getRenderableData from './getRenderableData';\r\nimport toolNames from '../tools/toolNames';\r\n\r\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\r\n\r\n/**\r\n * Adds a DICOM SR (Structured Report) annotation to the annotation manager.\r\n * This function processes measurement data from DICOM SR and converts it into\r\n * a format suitable for display in the Cornerstone3D viewer.\r\n *\r\n * @param {Object} params - The parameters object\r\n * @param {Object} params.measurement - The DICOM SR measurement data containing coordinates, labels, and metadata\r\n * @param {Array} params.measurement.coords - Array of coordinate objects with GraphicType, ValueType, and other properties\r\n * @param {string} params.measurement.TrackingUniqueIdentifier - Unique identifier for the measurement\r\n * @param {string} params.measurement.TrackingIdentifier - Tracking identifier for adapter lookup\r\n * @param {Array} [params.measurement.labels] - Optional array of label objects\r\n * @param {string} [params.measurement.displayText] - Optional display text for the annotation\r\n * @param {Object} [params.measurement.textBox] - Optional text box configuration\r\n * @param {string|null} [params.imageId] - Optional image ID for the referenced image (defaults to null)\r\n * @param {number|null} [params.frameNumber] - Optional frame number for multi-frame images (defaults to null)\r\n * @param {Object} params.displaySet - The display set containing the image\r\n * @param {string} params.displaySet.displaySetInstanceUID - Unique identifier for the display set\r\n * @returns {void}\r\n *\r\n * @example\r\n * ```typescript\r\n * addSRAnnotation({\r\n *   measurement: {\r\n *     TrackingUniqueIdentifier: '1.2.3.4.5',\r\n *     TrackingIdentifier: 'POINT',\r\n *     coords: [{\r\n *       GraphicType: 'POINT',\r\n *       ValueType: 'SCOORD',\r\n *       // ... other coordinate properties\r\n *     }],\r\n *     labels: [{ value: 'Measurement Point' }],\r\n *     displayText: 'Point measurement'\r\n *   },\r\n *   imageId: 'wadouri:file://path/to/image.dcm', // Optional\r\n *   frameNumber: 0, // Optional\r\n *   displaySet: { displaySetInstanceUID: '1.2.3.4' }\r\n * });\r\n * ```\r\n */\r\nexport default function addSRAnnotation({ measurement, imageId = null, frameNumber = null, displaySet }) {\r\n  /** @type {string} The tool name to use for the annotation, defaults to DICOMSRDisplay */\r\n  let toolName = toolNames.DICOMSRDisplay;\r\n  \r\n  /** \r\n   * @type {Object} Renderable data organized by graphic type\r\n   * Groups coordinate data by GraphicType for efficient rendering\r\n   */\r\n  const renderableData = measurement.coords.reduce((acc, coordProps) => {\r\n    acc[coordProps.GraphicType] = acc[coordProps.GraphicType] || [];\r\n    acc[coordProps.GraphicType].push(getRenderableData({ ...coordProps, imageId }));\r\n    return acc;\r\n  }, {});\r\n\r\n  const { TrackingUniqueIdentifier } = measurement;\r\n  const { ValueType: valueType, GraphicType: graphicType } = measurement.coords[0];\r\n  const graphicTypePoints = renderableData[graphicType];\r\n\r\n  /** TODO: Read the tool name from the DICOM SR identification type in the future. */\r\n  let frameOfReferenceUID = null;\r\n  let planeRestriction = null;\r\n\r\n  if (imageId) {\r\n    const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n    frameOfReferenceUID = imagePlaneModule?.frameOfReferenceUID;\r\n  }\r\n\r\n  if (valueType === 'SCOORD3D') {\r\n    const adapter = MeasurementReport.getAdapterForTrackingIdentifier(\r\n      measurement.TrackingIdentifier\r\n    );\r\n    if (!adapter) {\r\n      toolName = toolNames.SRSCOORD3DPoint;\r\n    }\r\n\r\n    // get the ReferencedFrameOfReferenceUID from the measurement\r\n    frameOfReferenceUID = measurement.coords[0].ReferencedFrameOfReferenceSequence;\r\n\r\n    planeRestriction = {\r\n      FrameOfReferenceUID: frameOfReferenceUID,\r\n      point: graphicTypePoints[0][0],\r\n    };\r\n  }\r\n\r\n  // Store the view reference for use in initial navigation\r\n  measurement.viewReference = {\r\n    planeRestriction,\r\n    FrameOfReferenceUID: frameOfReferenceUID,\r\n    referencedImageId: imageId,\r\n  };\r\n\r\n  /**\r\n   * @type {Types.Annotation} The annotation object to be added to the annotation manager\r\n   * Contains all necessary metadata and data for rendering the DICOM SR measurement\r\n   */\r\n  const SRAnnotation: Types.Annotation = {\r\n    annotationUID: TrackingUniqueIdentifier,\r\n    highlighted: false,\r\n    isLocked: false,\r\n    isPreview: toolName === toolNames.DICOMSRDisplay,\r\n    invalidated: false,\r\n    metadata: {\r\n      toolName,\r\n      planeRestriction,\r\n      valueType,\r\n      graphicType,\r\n      FrameOfReferenceUID: frameOfReferenceUID,\r\n      referencedImageId: imageId,\r\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\r\n    },\r\n    data: {\r\n      label: measurement.labels?.[0]?.value || undefined,\r\n      displayText: measurement.displayText || undefined,\r\n      handles: {\r\n        textBox: measurement.textBox ?? {},\r\n        points: graphicTypePoints[0],\r\n      },\r\n      cachedStats: {},\r\n      frameNumber,\r\n      renderableData,\r\n      TrackingUniqueIdentifier,\r\n      labels: measurement.labels,\r\n    },\r\n  };\r\n\r\n  /**\r\n   * Add the annotation to the annotation state manager.\r\n   * Note: Using annotation.state.addAnnotation() instead of annotationManager.addAnnotation()\r\n   * because the latter was not triggering annotation_added events properly.\r\n   * \r\n   * @param {Types.Annotation} SRAnnotation - The annotation to add\r\n   */\r\n  annotation.state.addAnnotation(SRAnnotation);\r\n}\r\n","import { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\r\n\r\n/**\r\n * Checks if the given `displaySet`can be rehydrated into the `measurementService`.\r\n *\r\n * @param {object} displaySet The SR `displaySet` to check.\r\n * @param {object[]} mappings The CornerstoneTools 4 mappings to the `measurementService`.\r\n * @returns {boolean} True if the SR can be rehydrated into the `measurementService`.\r\n */\r\nexport default function isRehydratable(displaySet, mappings) {\r\n  if (!mappings || !mappings.length) {\r\n    return false;\r\n  }\r\n\r\n  const mappingDefinitions = new Set<string>();\r\n  for (const m of mappings) {\r\n    mappingDefinitions.add(m.annotationType);\r\n  }\r\n\r\n  const { measurements } = displaySet;\r\n\r\n  for (let i = 0; i < measurements.length; i++) {\r\n    const measurement = measurements[i];\r\n    if (!measurement) {\r\n      continue;\r\n    }\r\n    const { TrackingIdentifier = '', graphicType, graphicCode, pointsLength } = measurement;\r\n    if (!TrackingIdentifier && !graphicType) {\r\n      console.warn('No tracking identifier  or graphicType for measurement ', measurement);\r\n      continue;\r\n    }\r\n    const adapter = MeasurementReport.getAdapterForTrackingIdentifier(TrackingIdentifier);\r\n    const adapters = MeasurementReport.getAdaptersForTypes(graphicCode, graphicType, pointsLength);\r\n    const hydratable =\r\n      (adapter && mappingDefinitions.has(adapter.toolType)) ||\r\n      (adapters && adapters.some(adapter => mappingDefinitions.has(adapter.toolType)));\r\n\r\n    if (hydratable) {\r\n      return true;\r\n    }\r\n    console.log('Measurement is not rehydratable', TrackingIdentifier, measurements[i]);\r\n  }\r\n\r\n  console.log('No measurements found which were rehydratable');\r\n  return false;\r\n}\r\n","import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\n\r\nconst SOPClassHandlerName = 'dicom-sr';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nconst SOPClassHandlerName3D = 'dicom-sr-3d';\r\nconst SOPClassHandlerId3D = `${id}.sopClassHandlerModule.${SOPClassHandlerName3D}`;\r\n\r\nexport { SOPClassHandlerName, SOPClassHandlerId, SOPClassHandlerName3D, SOPClassHandlerId3D, id };\r\n","import { utils, classes, DisplaySetService, Types as OhifTypes } from '@ohif/core';\r\nimport i18n from '@ohif/i18n';\r\nimport { Enums as CSExtensionEnums } from '@ohif/extension-cornerstone';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nimport addSRAnnotation from './utils/addSRAnnotation';\r\nimport isRehydratable from './utils/isRehydratable';\r\nimport {\r\n  SOPClassHandlerName,\r\n  SOPClassHandlerId,\r\n  SOPClassHandlerId3D,\r\n  SOPClassHandlerName3D,\r\n} from './id';\r\nimport { CodeNameCodeSequenceValues, CodingSchemeDesignators } from './enums';\r\n\r\nconst { sopClassDictionary } = utils;\r\nconst { CORNERSTONE_3D_TOOLS_SOURCE_NAME, CORNERSTONE_3D_TOOLS_SOURCE_VERSION } = CSExtensionEnums;\r\nconst { MetadataProvider: metadataProvider } = classes;\r\nconst {\r\n  TEXT_ANNOTATION_POSITION,\r\n  COMMENT_CODE,\r\n  CodeScheme: Cornerstone3DCodeScheme,\r\n} = adaptersSR.Cornerstone3D;\r\n\r\ntype InstanceMetadata = OhifTypes.InstanceMetadata;\r\n\r\n/**\r\n * TODO\r\n * - [ ] Add SR thumbnail\r\n * - [ ] Make viewport\r\n * - [ ] Get stacks from referenced displayInstanceUID and load into wrapped CornerStone viewport\r\n */\r\n\r\nconst sopClassUids = [\r\n  sopClassDictionary.BasicTextSR,\r\n  sopClassDictionary.EnhancedSR,\r\n  sopClassDictionary.ComprehensiveSR,\r\n  sopClassDictionary.Comprehensive3DSR,\r\n];\r\n\r\nconst validateSameStudyUID = (uid: string, instances): void => {\r\n  instances.forEach(it => {\r\n    if (it.StudyInstanceUID !== uid) {\r\n      console.warn('Not all instances have the same UID', uid, it);\r\n      throw new Error(`Instances ${it.SOPInstanceUID} does not belong to ${uid}`);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Adds instances to the DICOM SR series, rather than creating a new\r\n * series, so that as SR's are saved, they append to the series, and the\r\n * key image display set gets updated as well, containing just the new series.\r\n * @param instances is a list of instances from THIS series that are not\r\n *     in this DICOM SR Display Set already.\r\n */\r\nfunction addInstances(instances: InstanceMetadata[], _displaySetService: DisplaySetService) {\r\n  this.instances.push(...instances);\r\n  utils.sortStudyInstances(this.instances);\r\n  // The last instance is the newest one, so is the one most interesting.\r\n  // Eventually, the SR viewer should have the ability to choose which SR\r\n  // gets loaded, and to navigate among them.\r\n  this.instance = this.instances[this.instances.length - 1];\r\n  this.isLoaded = false;\r\n  return this;\r\n}\r\n\r\n/**\r\n * DICOM SR SOP Class Handler\r\n * For all referenced images in the TID 1500/300 sections, add an image to the\r\n * display.\r\n * @param {InstanceMetadata[]} instances - A set of instances all from the same series\r\n * @param {AppTypes.ServicesManager} servicesManager - The services that can be used for creating\r\n * @param {AppTypes.ExtensionManager} extensionManager - The extension manager\r\n * @returns {Types.DisplaySet[]} The list of display sets created for the given instances object\r\n */\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager\r\n) {\r\n  // If the series has no instances, stop here\r\n  if (!instances || !instances.length) {\r\n    throw new Error('No instances were provided');\r\n  }\r\n\r\n  utils.sortStudyInstances(instances);\r\n  // The last instance is the newest one, so is the one most interesting.\r\n  // Eventually, the SR viewer should have the ability to choose which SR\r\n  // gets loaded, and to navigate among them.\r\n  const instance = instances[instances.length - 1];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SeriesTime,\r\n    ConceptNameCodeSequence,\r\n    SOPClassUID,\r\n  } = instance;\r\n  validateSameStudyUID(instance.StudyInstanceUID, instances);\r\n\r\n  const is3DSR = SOPClassUID === sopClassDictionary.Comprehensive3DSR;\r\n\r\n  const isImagingMeasurementReport =\r\n    ConceptNameCodeSequence?.CodeValue === CodeNameCodeSequenceValues.ImagingMeasurementReport;\r\n\r\n  const displaySet = {\r\n    Modality: 'SR',\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SeriesTime,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId: is3DSR ? SOPClassHandlerId3D : SOPClassHandlerId,\r\n    SOPClassUID,\r\n    instances,\r\n    referencedImages: null,\r\n    measurements: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isImagingMeasurementReport,\r\n    sopClassUids,\r\n    instance,\r\n    addInstances,\r\n    label: SeriesDescription || `${i18n.t('Series')} ${SeriesNumber} - ${i18n.t('SR')}`,\r\n  };\r\n\r\n  displaySet.load = () => _load(displaySet, servicesManager, extensionManager);\r\n\r\n  return [displaySet];\r\n}\r\n\r\n/**\r\n * Loads the display set with the given services and extension manager.\r\n * @param srDisplaySet - The display set to load.\r\n * @param servicesManager - The services manager containing displaySetService and measurementService.\r\n * @param extensionManager - The extension manager containing data sources.\r\n */\r\nasync function _load(\r\n  srDisplaySet: OhifTypes.DisplaySet,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager: AppTypes.ExtensionManager\r\n) {\r\n  const { displaySetService, measurementService } = servicesManager.services;\r\n  const dataSources = extensionManager.getDataSources();\r\n  const dataSource = dataSources[0];\r\n  const { ContentSequence } = srDisplaySet.instance;\r\n\r\n  async function retrieveBulkData(obj, parentObj = null, key = null) {\r\n    for (const prop in obj) {\r\n      if (typeof obj[prop] === 'object' && obj[prop] !== null) {\r\n        await retrieveBulkData(obj[prop], obj, prop);\r\n      } else if (Array.isArray(obj[prop])) {\r\n        await Promise.all(obj[prop].map(item => retrieveBulkData(item, obj, prop)));\r\n      } else if (prop === 'BulkDataURI') {\r\n        const value = await dataSource.retrieve.bulkDataURI({\r\n          BulkDataURI: obj[prop],\r\n          StudyInstanceUID: srDisplaySet.instance.StudyInstanceUID,\r\n          SeriesInstanceUID: srDisplaySet.instance.SeriesInstanceUID,\r\n          SOPInstanceUID: srDisplaySet.instance.SOPInstanceUID,\r\n        });\r\n        if (parentObj && key) {\r\n          parentObj[key] = new Float32Array(value);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (srDisplaySet.isLoaded !== true) {\r\n    await retrieveBulkData(ContentSequence);\r\n  }\r\n\r\n  if (srDisplaySet.isImagingMeasurementReport) {\r\n    srDisplaySet.referencedImages = _getReferencedImagesList(ContentSequence);\r\n    srDisplaySet.measurements = _getMeasurements(ContentSequence);\r\n  } else {\r\n    srDisplaySet.referencedImages = [];\r\n    srDisplaySet.measurements = [];\r\n  }\r\n\r\n  const mappings = measurementService.getSourceMappings(\r\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n  );\r\n\r\n  srDisplaySet.isHydrated = false;\r\n  srDisplaySet.isRehydratable = isRehydratable(srDisplaySet, mappings);\r\n  srDisplaySet.isLoaded = true;\r\n\r\n  /** Check currently added displaySets and add measurements if the sources exist */\r\n  displaySetService.activeDisplaySets.forEach(activeDisplaySet => {\r\n    _checkIfCanAddMeasurementsToDisplaySet(\r\n      srDisplaySet,\r\n      activeDisplaySet,\r\n      dataSource,\r\n      servicesManager\r\n    );\r\n  });\r\n\r\n  /** Subscribe to new displaySets as the source may come in after */\r\n  displaySetService.subscribe(displaySetService.EVENTS.DISPLAY_SETS_ADDED, data => {\r\n    const { displaySetsAdded } = data;\r\n    /**\r\n     * If there are still some measurements that have not yet been loaded into cornerstone,\r\n     * See if we can load them onto any of the new displaySets.\r\n     */\r\n    displaySetsAdded.forEach(newDisplaySet => {\r\n      _checkIfCanAddMeasurementsToDisplaySet(\r\n        srDisplaySet,\r\n        newDisplaySet,\r\n        dataSource,\r\n        servicesManager\r\n      );\r\n    });\r\n  });\r\n}\r\n\r\nfunction _measurementBelongsToDisplaySet({ measurement, displaySet }) {\r\n  return (\r\n    measurement.coords[0].ReferencedFrameOfReferenceSequence === displaySet.FrameOfReferenceUID\r\n  );\r\n}\r\n\r\nfunction _checkIfCanAddMeasurementsToDisplaySet(\r\n  srDisplaySet: OhifTypes.DisplaySet,\r\n  newDisplaySet: OhifTypes.DisplaySet,\r\n  dataSource,\r\n  servicesManager: AppTypes.ServicesManager\r\n) {\r\n  const { customizationService } = servicesManager.services;\r\n\r\n  const unloadedMeasurements = srDisplaySet.measurements.filter(\r\n    measurement => measurement.loaded === false\r\n  );\r\n\r\n  if (!unloadedMeasurements.length || newDisplaySet.unsupported) {\r\n    return;\r\n  }\r\n\r\n  // Create a Map to efficiently look up ImageIds by SOPInstanceUID and frame number\r\n  const imageIdMap = new Map<string, string>();\r\n  const imageIds = dataSource.getImageIdsForDisplaySet(newDisplaySet);\r\n\r\n  for (const imageId of imageIds) {\r\n    const { SOPInstanceUID, frameNumber } = metadataProvider.getUIDsFromImageID(imageId);\r\n    const key = `${SOPInstanceUID}:${frameNumber || 1}`;\r\n    imageIdMap.set(key, imageId);\r\n  }\r\n\r\n  if (!unloadedMeasurements?.length) {\r\n    return;\r\n  }\r\n\r\n  const is3DSR = srDisplaySet.SOPClassUID === sopClassDictionary.Comprehensive3DSR;\r\n\r\n  for (let j = unloadedMeasurements.length - 1; j >= 0; j--) {\r\n    let measurement = unloadedMeasurements[j];\r\n    const is3DMeasurement = measurement.coords?.[0]?.ValueType === 'SCOORD3D';\r\n\r\n    const onBeforeSRAddMeasurement = customizationService.getCustomization(\r\n      'onBeforeSRAddMeasurement'\r\n    );\r\n\r\n    if (typeof onBeforeSRAddMeasurement === 'function') {\r\n      measurement = onBeforeSRAddMeasurement({\r\n        measurement,\r\n        StudyInstanceUID: srDisplaySet.StudyInstanceUID,\r\n        SeriesInstanceUID: srDisplaySet.SeriesInstanceUID,\r\n      });\r\n    }\r\n\r\n    // if it is 3d SR we can just add the SR annotation\r\n    if (\r\n      is3DSR &&\r\n      is3DMeasurement &&\r\n      _measurementBelongsToDisplaySet({ measurement, displaySet: newDisplaySet })\r\n    ) {\r\n      addSRAnnotation({ measurement, displaySet: newDisplaySet });\r\n      measurement.loaded = true;\r\n      measurement.displaySetInstanceUID = newDisplaySet.displaySetInstanceUID;\r\n      unloadedMeasurements.splice(j, 1);\r\n      continue;\r\n    }\r\n\r\n    const referencedSOPSequence = measurement.coords[0].ReferencedSOPSequence;\r\n    if (!referencedSOPSequence) {\r\n      continue;\r\n    }\r\n\r\n    const { ReferencedSOPInstanceUID } = referencedSOPSequence;\r\n    const frame = referencedSOPSequence.ReferencedFrameNumber || 1;\r\n    const key = `${ReferencedSOPInstanceUID}:${frame}`;\r\n    const imageId = imageIdMap.get(key);\r\n\r\n    if (\r\n      imageId &&\r\n      _measurementReferencesSOPInstanceUID(measurement, ReferencedSOPInstanceUID, frame)\r\n    ) {\r\n      addSRAnnotation({ measurement, imageId, frameNumber: frame, displaySet: newDisplaySet });\r\n      measurement.loaded = true;\r\n      measurement.imageId = imageId;\r\n      measurement.displaySetInstanceUID = newDisplaySet.displaySetInstanceUID;\r\n      measurement.ReferencedSOPInstanceUID = ReferencedSOPInstanceUID;\r\n      measurement.frameNumber = frame;\r\n      unloadedMeasurements.splice(j, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a measurement references a specific SOP Instance UID.\r\n * @param {any} measurement - The measurement object.\r\n * @param {string} sopInstanceUID - The SOP Instance UID to check against.\r\n * @param {number} frameNumber - The frame number to check against (optional).\r\n * @returns {boolean} True if the measurement references the specified SOP Instance UID, false otherwise.\r\n */\r\nfunction _measurementReferencesSOPInstanceUID(measurement, SOPInstanceUID, frameNumber) {\r\n  const { coords } = measurement;\r\n\r\n  /**\r\n   * NOTE: The ReferencedFrameNumber can be multiple values according to the DICOM\r\n   * Standard. But for now, we will support only one ReferenceFrameNumber.\r\n   */\r\n  const ReferencedFrameNumber =\r\n    (measurement.coords[0].ReferencedSOPSequence &&\r\n      measurement.coords[0].ReferencedSOPSequence?.ReferencedFrameNumber) ||\r\n    1;\r\n\r\n  if (frameNumber && Number(frameNumber) !== Number(ReferencedFrameNumber)) {\r\n    return false;\r\n  }\r\n\r\n  for (let j = 0; j < coords.length; j++) {\r\n    const coord = coords[j];\r\n    const { ReferencedSOPInstanceUID } = coord.ReferencedSOPSequence;\r\n    if (ReferencedSOPInstanceUID === SOPInstanceUID) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Retrieves the SOP class handler module.\r\n *\r\n * @param {OhifTypes.Extensions.ExtensionParams} params - The extension parameters.\r\n * @returns {Array} An array containing the SOP class handler modules.\r\n */\r\nfunction getSopClassHandlerModule(params: OhifTypes.Extensions.ExtensionParams) {\r\n  const { servicesManager, extensionManager } = params;\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\r\n  };\r\n  return [\r\n    {\r\n      name: SOPClassHandlerName,\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n    {\r\n      name: SOPClassHandlerName3D,\r\n      sopClassUids: [sopClassDictionary.Comprehensive3DSR],\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n * Retrieves the measurements from the ImagingMeasurementReportContentSequence.\r\n *\r\n * @param {any[]} imagingMeasurementReportContentSequence - The ImagingMeasurementReportContentSequence array.\r\n * @returns {any[]} The array of measurements.\r\n */\r\nfunction _getMeasurements(ImagingMeasurementReportContentSequence) {\r\n  const ImagingMeasurements = ImagingMeasurementReportContentSequence.find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImagingMeasurements\r\n  );\r\n\r\n  if (!ImagingMeasurements) {\r\n    return [];\r\n  }\r\n\r\n  const MeasurementGroups = _getSequenceAsArray(ImagingMeasurements.ContentSequence).filter(\r\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.MeasurementGroup\r\n  );\r\n\r\n  const mergedContentSequencesByTrackingUniqueIdentifiers =\r\n    _getMergedContentSequencesByTrackingUniqueIdentifiers(MeasurementGroups);\r\n  const measurements = [];\r\n\r\n  Object.keys(mergedContentSequencesByTrackingUniqueIdentifiers).forEach(\r\n    trackingUniqueIdentifier => {\r\n      const mergedContentSequence =\r\n        mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier];\r\n\r\n      const measurement = _processMeasurement(mergedContentSequence);\r\n      if (measurement) {\r\n        measurements.push(measurement);\r\n      }\r\n    }\r\n  );\r\n\r\n  return measurements;\r\n}\r\n\r\n/**\r\n * Retrieves merged content sequences by tracking unique identifiers.\r\n *\r\n * @param {any[]} measurementGroups - The measurement groups.\r\n * @returns {Object} The merged content sequences by tracking unique identifiers.\r\n */\r\nfunction _getMergedContentSequencesByTrackingUniqueIdentifiers(MeasurementGroups) {\r\n  const mergedContentSequencesByTrackingUniqueIdentifiers = {};\r\n\r\n  MeasurementGroups.forEach(MeasurementGroup => {\r\n    const ContentSequence = _getSequenceAsArray(MeasurementGroup.ContentSequence);\r\n\r\n    const TrackingUniqueIdentifierItem = ContentSequence.find(\r\n      item =>\r\n        item.ConceptNameCodeSequence.CodeValue ===\r\n        CodeNameCodeSequenceValues.TrackingUniqueIdentifier\r\n    );\r\n    if (!TrackingUniqueIdentifierItem) {\r\n      console.warn('No Tracking Unique Identifier, skipping ambiguous measurement.');\r\n    }\r\n\r\n    const trackingUniqueIdentifier = TrackingUniqueIdentifierItem.UID;\r\n\r\n    if (mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier] === undefined) {\r\n      // Add the full ContentSequence\r\n      mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier] = [\r\n        ...ContentSequence,\r\n      ];\r\n    } else {\r\n      // Add the ContentSequence minus the tracking identifier, as we have this\r\n      // Information in the merged ContentSequence anyway.\r\n      ContentSequence.forEach(item => {\r\n        if (\r\n          item.ConceptNameCodeSequence.CodeValue !==\r\n          CodeNameCodeSequenceValues.TrackingUniqueIdentifier\r\n        ) {\r\n          mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier].push(item);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return mergedContentSequencesByTrackingUniqueIdentifiers;\r\n}\r\n\r\n/**\r\n * Processes the measurement based on the merged content sequence.\r\n * If the merged content sequence contains SCOORD or SCOORD3D value types,\r\n * it calls the _processTID1410Measurement function.\r\n * Otherwise, it calls the _processNonGeometricallyDefinedMeasurement function.\r\n *\r\n * @param {any[]} mergedContentSequence - The merged content sequence to process.\r\n * @returns {any} The processed measurement result.\r\n */\r\nfunction _processMeasurement(mergedContentSequence) {\r\n  if (mergedContentSequence.some(group => isScoordOr3d(group) && !isTextPosition(group))) {\r\n    return _processTID1410Measurement(mergedContentSequence);\r\n  }\r\n\r\n  return _processNonGeometricallyDefinedMeasurement(mergedContentSequence);\r\n}\r\n\r\n/**\r\n * Processes TID 1410 style measurements from the mergedContentSequence.\r\n * TID 1410 style measurements have a SCOORD or SCOORD3D at the top level,\r\n * and non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D.\r\n *\r\n * @param {any[]} mergedContentSequence - The merged content sequence containing the measurements.\r\n * @returns {any} The measurement object containing the loaded status, labels, coordinates, tracking unique identifier, and tracking identifier.\r\n */\r\nfunction _processTID1410Measurement(mergedContentSequence) {\r\n  // Need to deal with TID 1410 style measurements, which will have a SCOORD or SCOORD3D at the top level,\r\n  // And non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D\r\n\r\n  const graphicItem = mergedContentSequence.find(\r\n    group => group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D'\r\n  );\r\n\r\n  const UIDREFContentItem = mergedContentSequence.find(group => group.ValueType === 'UIDREF');\r\n\r\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\r\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.TrackingIdentifier\r\n  );\r\n\r\n  if (!graphicItem) {\r\n    console.warn(\r\n      `graphic ValueType ${graphicItem.ValueType} not currently supported, skipping annotation.`\r\n    );\r\n    return;\r\n  }\r\n\r\n  const NUMContentItems = mergedContentSequence.filter(group => group.ValueType === 'NUM');\r\n\r\n  const { ConceptNameCodeSequence: conceptNameItem } = graphicItem;\r\n  const { CodeValue: graphicValue, CodingSchemeDesignator: graphicDesignator } = conceptNameItem;\r\n  const graphicCode = `${graphicDesignator}:${graphicValue}`;\r\n\r\n  const pointDataItem = _getCoordsFromSCOORDOrSCOORD3D(graphicItem);\r\n  const is3DMeasurement = pointDataItem.ValueType === 'SCOORD3D';\r\n  const pointLength = is3DMeasurement ? 3 : 2;\r\n  const pointsLength = pointDataItem.GraphicData.length / pointLength;\r\n\r\n  const measurement = {\r\n    loaded: false,\r\n    labels: [],\r\n    coords: [pointDataItem],\r\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\r\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\r\n    graphicCode,\r\n    is3DMeasurement,\r\n    pointsLength,\r\n    graphicType: pointDataItem.GraphicType,\r\n  };\r\n\r\n  NUMContentItems.forEach(item => {\r\n    const { ConceptNameCodeSequence, MeasuredValueSequence } = item;\r\n    if (MeasuredValueSequence) {\r\n      measurement.labels.push(\r\n        _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence)\r\n      );\r\n    }\r\n  });\r\n\r\n  const findingSites = mergedContentSequence.filter(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === CodingSchemeDesignators.SCT &&\r\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.FindingSiteSCT\r\n  );\r\n  if (findingSites.length) {\r\n    measurement.labels.push({\r\n      label: CodeNameCodeSequenceValues.FindingSiteSCT,\r\n      value: findingSites[0].ConceptCodeSequence.CodeMeaning,\r\n    });\r\n  }\r\n\r\n  return measurement;\r\n}\r\n\r\n/**\r\n * Processes the non-geometrically defined measurement from the merged content sequence.\r\n *\r\n * @param {any[]} mergedContentSequence The merged content sequence containing the measurement data.\r\n * @returns {any} The processed measurement object.\r\n */\r\nfunction _processNonGeometricallyDefinedMeasurement(mergedContentSequence) {\r\n  const NUMContentItems = mergedContentSequence.filter(group => group.ValueType === 'NUM');\r\n  const UIDREFContentItem = mergedContentSequence.find(group => group.ValueType === 'UIDREF');\r\n\r\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\r\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.TrackingIdentifier\r\n  );\r\n\r\n  const finding = mergedContentSequence.find(\r\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.Finding\r\n  );\r\n\r\n  const findingSites = mergedContentSequence.filter(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === CodingSchemeDesignators.SRT &&\r\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.FindingSite\r\n  );\r\n\r\n  const commentSites = mergedContentSequence.filter(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === COMMENT_CODE.schemeDesignator &&\r\n      item.ConceptNameCodeSequence.CodeValue === COMMENT_CODE.value\r\n  );\r\n\r\n  const measurement = {\r\n    loaded: false,\r\n    labels: [],\r\n    coords: [],\r\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\r\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\r\n  };\r\n\r\n  if (commentSites) {\r\n    for (const group of commentSites) {\r\n      if (group.TextValue) {\r\n        measurement.labels.push({ label: group.TextValue, value: '' });\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    finding &&\r\n    CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\r\n      finding.ConceptCodeSequence.CodingSchemeDesignator\r\n    ) &&\r\n    finding.ConceptCodeSequence.CodeValue === Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT\r\n  ) {\r\n    measurement.labels.push({\r\n      label: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT,\r\n      value: finding.ConceptCodeSequence.CodeMeaning,\r\n    });\r\n  }\r\n\r\n  // TODO -> Eventually hopefully support SNOMED or some proper code library, just free text for now.\r\n  if (findingSites.length) {\r\n    const cornerstoneFreeTextFindingSite = findingSites.find(\r\n      FindingSite =>\r\n        CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\r\n          FindingSite.ConceptCodeSequence.CodingSchemeDesignator\r\n        ) &&\r\n        FindingSite.ConceptCodeSequence.CodeValue ===\r\n          Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT\r\n    );\r\n\r\n    if (cornerstoneFreeTextFindingSite) {\r\n      measurement.labels.push({\r\n        label: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT,\r\n        value: cornerstoneFreeTextFindingSite.ConceptCodeSequence.CodeMeaning,\r\n      });\r\n    }\r\n  }\r\n\r\n  NUMContentItems.forEach(item => {\r\n    const { ConceptNameCodeSequence, ContentSequence, MeasuredValueSequence } = item;\r\n\r\n    const { ValueType } = ContentSequence;\r\n    if (!ValueType === 'SCOORD') {\r\n      console.warn(`Graphic ${ValueType} not currently supported, skipping annotation.`);\r\n      return;\r\n    }\r\n\r\n    const coords = _getCoordsFromSCOORDOrSCOORD3D(ContentSequence);\r\n    if (coords) {\r\n      measurement.coords.push(coords);\r\n    }\r\n\r\n    if (MeasuredValueSequence) {\r\n      measurement.labels.push(\r\n        _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence)\r\n      );\r\n    }\r\n  });\r\n\r\n  return measurement;\r\n}\r\n\r\n/**\r\n * Extracts coordinates from a graphic item of type SCOORD or SCOORD3D.\r\n * @param {any} graphicItem - The graphic item containing the coordinates.\r\n * @returns {any} The extracted coordinates.\r\n */\r\nconst _getCoordsFromSCOORDOrSCOORD3D = graphicItem => {\r\n  const { ValueType, GraphicType, GraphicData } = graphicItem;\r\n  const coords = { ValueType, GraphicType, GraphicData };\r\n  coords.ReferencedSOPSequence = graphicItem.ContentSequence?.ReferencedSOPSequence;\r\n  coords.ReferencedFrameOfReferenceSequence =\r\n    graphicItem.ReferencedFrameOfReferenceUID ||\r\n    graphicItem.ContentSequence?.ReferencedFrameOfReferenceSequence;\r\n  return coords;\r\n};\r\n\r\n/**\r\n * Retrieves the label and value from the provided ConceptNameCodeSequence and MeasuredValueSequence.\r\n * @param {any} conceptNameCodeSequence - The ConceptNameCodeSequence object.\r\n * @param {any} measuredValueSequence - The MeasuredValueSequence object.\r\n * @returns {Object} An object containing the label and value.\r\n *                    The label represents the CodeMeaning from the ConceptNameCodeSequence.\r\n *                    The value represents the formatted NumericValue and CodeValue from the MeasuredValueSequence.\r\n *                    Example: { label: 'Long Axis', value: '31.00 mm' }\r\n */\r\nfunction _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence) {\r\n  const { CodeMeaning } = ConceptNameCodeSequence;\r\n  const { NumericValue, MeasurementUnitsCodeSequence } = MeasuredValueSequence;\r\n  const { CodeValue } = MeasurementUnitsCodeSequence;\r\n  const formatedNumericValue = NumericValue ? Number(NumericValue).toFixed(2) : '';\r\n  return {\r\n    label: CodeMeaning,\r\n    value: `${formatedNumericValue} ${CodeValue}`,\r\n  }; // E.g. Long Axis: 31.0 mm\r\n}\r\n\r\n/**\r\n * Retrieves a list of referenced images from the Imaging Measurement Report Content Sequence.\r\n *\r\n * @param {any[]} imagingMeasurementReportContentSequence - The Imaging Measurement Report Content Sequence.\r\n * @returns {any[]} The list of referenced images.\r\n */\r\nfunction _getReferencedImagesList(ImagingMeasurementReportContentSequence) {\r\n  const ImageLibrary = ImagingMeasurementReportContentSequence.find(\r\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImageLibrary\r\n  );\r\n\r\n  if (!ImageLibrary) {\r\n    return [];\r\n  }\r\n\r\n  const ImageLibraryGroup = _getSequenceAsArray(ImageLibrary.ContentSequence).find(\r\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImageLibraryGroup\r\n  );\r\n  if (!ImageLibraryGroup) {\r\n    return [];\r\n  }\r\n\r\n  const referencedImages = [];\r\n\r\n  _getSequenceAsArray(ImageLibraryGroup.ContentSequence).forEach(item => {\r\n    const { ReferencedSOPSequence } = item;\r\n    if (!ReferencedSOPSequence) {\r\n      return;\r\n    }\r\n    for (const ref of _getSequenceAsArray(ReferencedSOPSequence)) {\r\n      if (ref.ReferencedSOPClassUID) {\r\n        const { ReferencedSOPClassUID, ReferencedSOPInstanceUID } = ref;\r\n\r\n        referencedImages.push({\r\n          ReferencedSOPClassUID,\r\n          ReferencedSOPInstanceUID,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return referencedImages;\r\n}\r\n\r\n/**\r\n * Converts a DICOM sequence to an array.\r\n * If the sequence is null or undefined, an empty array is returned.\r\n * If the sequence is already an array, it is returned as is.\r\n * Otherwise, the sequence is wrapped in an array and returned.\r\n *\r\n * @param {any} sequence - The DICOM sequence to convert.\r\n * @returns {any[]} The converted array.\r\n */\r\nfunction _getSequenceAsArray(sequence) {\r\n  if (!sequence) {\r\n    return [];\r\n  }\r\n  return Array.isArray(sequence) ? sequence : [sequence];\r\n}\r\n\r\nfunction isScoordOr3d(group) {\r\n  return group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D';\r\n}\r\n\r\nfunction isTextPosition(group) {\r\n  const concept = group.ConceptNameCodeSequence[0];\r\n  return (\r\n    concept &&\r\n    concept.CodeValue === TEXT_ANNOTATION_POSITION.value &&\r\n    concept.CodingSchemeDesignator === TEXT_ANNOTATION_POSITION.schemeDesignator\r\n  );\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import { Types } from '@ohif/core';\r\n\r\nconst srProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/sr',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  name: 'SR Key Images',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'srDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    srDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SR',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'SR Key Images',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: { allowUnmatchedView: true },\r\n          displaySets: [\r\n            {\r\n              id: 'srDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: srProtocol.id,\r\n      protocol: srProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { srProtocol };\r\n","import { annotation } from '@cornerstonejs/tools';\r\nimport { NO_IMAGE_ID } from '@cornerstonejs/adapters';\r\n\r\nfunction getFilteredCornerstoneToolState(measurementData, additionalFindingTypes) {\r\n  const filteredToolState = {};\r\n\r\n  function addToFilteredToolState(annotation, toolType) {\r\n    const imageId = annotation.metadata?.referencedImageId ?? NO_IMAGE_ID;\r\n\r\n    if (!filteredToolState[imageId]) {\r\n      filteredToolState[imageId] = {};\r\n    }\r\n\r\n    const imageIdSpecificToolState = filteredToolState[imageId];\r\n\r\n    if (!imageIdSpecificToolState[toolType]) {\r\n      imageIdSpecificToolState[toolType] = {\r\n        data: [],\r\n      };\r\n    }\r\n\r\n    const measurementDataI = measurementData.find(md => md.uid === annotation.annotationUID);\r\n    const toolData = imageIdSpecificToolState[toolType].data;\r\n\r\n    let { finding } = measurementDataI;\r\n    const findingSites = [];\r\n\r\n    // NOTE -> We use the CORNERSTONEJS coding schemeDesignator which we have\r\n    // defined in the @cornerstonejs/adapters\r\n    if (measurementDataI.label) {\r\n      if (additionalFindingTypes.includes(toolType)) {\r\n        finding = {\r\n          CodeValue: 'CORNERSTONEFREETEXT',\r\n          CodingSchemeDesignator: 'CORNERSTONEJS',\r\n          CodeMeaning: measurementDataI.label,\r\n        };\r\n      } else {\r\n        findingSites.push({\r\n          CodeValue: 'CORNERSTONEFREETEXT',\r\n          CodingSchemeDesignator: 'CORNERSTONEJS',\r\n          CodeMeaning: measurementDataI.label,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (measurementDataI.findingSites) {\r\n      findingSites.push(...measurementDataI.findingSites);\r\n    }\r\n\r\n    const measurement = Object.assign({}, annotation, {\r\n      finding,\r\n      findingSites,\r\n    });\r\n\r\n    toolData.push(measurement);\r\n  }\r\n\r\n  const uidFilter = measurementData.map(md => md.uid);\r\n  const uids = uidFilter.slice();\r\n\r\n  const annotationManager = annotation.state.getAnnotationManager();\r\n  const framesOfReference = annotationManager.getFramesOfReference();\r\n\r\n  for (let i = 0; i < framesOfReference.length; i++) {\r\n    const frameOfReference = framesOfReference[i];\r\n\r\n    const frameOfReferenceAnnotations = annotationManager.getAnnotations(frameOfReference);\r\n\r\n    const toolTypes = Object.keys(frameOfReferenceAnnotations);\r\n\r\n    for (let j = 0; j < toolTypes.length; j++) {\r\n      const toolType = toolTypes[j];\r\n\r\n      const annotations = frameOfReferenceAnnotations[toolType];\r\n\r\n      if (annotations) {\r\n        for (let k = 0; k < annotations.length; k++) {\r\n          const annotation = annotations[k];\r\n          const uidIndex = uids.findIndex(uid => uid === annotation.annotationUID);\r\n\r\n          if (uidIndex !== -1) {\r\n            addToFilteredToolState(annotation, toolType);\r\n            uids.splice(uidIndex, 1);\r\n\r\n            if (!uids.length) {\r\n              return filteredToolState;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return filteredToolState;\r\n}\r\n\r\nexport default getFilteredCornerstoneToolState;\r\n","import { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\r\n\r\n/**\r\n * Extracts the label from the toolData imported from dcmjs. We need to do this\r\n * as dcmjs does not depeend on OHIF/the measurementService, it just produces data for cornestoneTools.\r\n * This optional data is available for the consumer to process if they wish to.\r\n * @param {object} toolData The tooldata relating to the\r\n *\r\n * @returns {string} The extracted label.\r\n */\r\nexport default function getLabelFromDCMJSImportedToolData(toolData) {\r\n  const { findingSites = [], finding, annotation } = toolData;\r\n\r\n  if (annotation.data.label) {\r\n    return annotation.data.label;\r\n  }\r\n\r\n  let freeTextLabel = findingSites.find(\r\n    fs => fs.CodeValue === Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT\r\n  );\r\n\r\n  if (freeTextLabel) {\r\n    return freeTextLabel.CodeMeaning;\r\n  }\r\n\r\n  if (finding && finding.CodeValue === Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT) {\r\n    return finding.CodeMeaning;\r\n  }\r\n}\r\n","import { utilities, metaData, type Types } from '@cornerstonejs/core';\r\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\r\nimport { vec3 } from 'gl-matrix';\r\n\r\nimport getLabelFromDCMJSImportedToolData from './getLabelFromDCMJSImportedToolData';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\nimport { annotation as CsAnnotation, type Types as ToolTypes } from '@cornerstonejs/tools';\r\nimport { Enums as CSExtensionEnums } from '@ohif/extension-cornerstone';\r\n\r\nconst { locking } = CsAnnotation;\r\nconst { guid } = OHIF.utils;\r\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\r\nconst { CORNERSTONE_3D_TOOLS_SOURCE_NAME, CORNERSTONE_3D_TOOLS_SOURCE_VERSION } = CSExtensionEnums;\r\n\r\nconst convertCode = (codingValues, code) => {\r\n  if (!code || code.CodingSchemeDesignator === 'CORNERSTONEJS') {\r\n    return;\r\n  }\r\n  const ref = `${code.CodingSchemeDesignator}:${code.CodeValue}`;\r\n  const ret = { ...codingValues[ref], ref, ...code, text: code.CodeMeaning };\r\n  return ret;\r\n};\r\n\r\nconst convertSites = (codingValues, sites) => {\r\n  if (!sites || !sites.length) {\r\n    return;\r\n  }\r\n  const ret = [];\r\n  // Do as a loop to convert away from Proxy instances\r\n  for (let i = 0; i < sites.length; i++) {\r\n    // Deal with irregular conversion from dcmjs\r\n    const site = convertCode(codingValues, sites[i][0] || sites[i]);\r\n    if (site) {\r\n      ret.push(site);\r\n    }\r\n  }\r\n  return (ret.length && ret) || undefined;\r\n};\r\n\r\n/**\r\n * Hydrates a structured report\r\n * Handles 2d and 3d hydration from SCOORD and SCOORD3D points\r\n * For 3D hydration, chooses a volume display set to display with\r\n * FOr 2D hydration, chooses the (first) display set containing the referenced image.\r\n */\r\nexport default function hydrateStructuredReport(\r\n  { servicesManager, extensionManager, commandsManager }: withAppTypes,\r\n  displaySetInstanceUID\r\n) {\r\n  const dataSource = extensionManager.getActiveDataSource()[0];\r\n  const { measurementService, displaySetService, customizationService } = servicesManager.services;\r\n\r\n  const codingValues = customizationService.getCustomization('codingValues');\r\n  const disableEditing = customizationService.getCustomization('panelMeasurement.disableEditing');\r\n\r\n  const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n  // TODO -> We should define a strict versioning somewhere.\r\n  const mappings = measurementService.getSourceMappings(\r\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n  );\r\n\r\n  if (!mappings || !mappings.length) {\r\n    throw new Error(\r\n      `Attempting to hydrate measurements service when no mappings present. This shouldn't be reached.`\r\n    );\r\n  }\r\n\r\n  const instance = DicomMetadataStore.getInstance(\r\n    displaySet.StudyInstanceUID,\r\n    displaySet.SeriesInstanceUID,\r\n    displaySet.SOPInstanceUID\r\n  );\r\n\r\n  const sopInstanceUIDToImageId = {};\r\n\r\n  displaySet.measurements.forEach(measurement => {\r\n    const { ReferencedSOPInstanceUID, imageId, frameNumber=1 } = measurement;\r\n    const key = `${ReferencedSOPInstanceUID}:${frameNumber}`;\r\n\r\n    if (!sopInstanceUIDToImageId[key]) {\r\n      sopInstanceUIDToImageId[key] = imageId;\r\n    }\r\n  });\r\n\r\n  // Mapping of legacy datasets is now directly handled by adapters module\r\n  const datasetToUse = instance;\r\n\r\n  // Use CS3D adapters to generate toolState.\r\n  let storedMeasurementByAnnotationType = MeasurementReport.generateToolState(\r\n    datasetToUse,\r\n    // NOTE: we need to pass in the imageIds to dcmjs since the we use them\r\n    // for the imageToWorld transformation. The following assumes that the order\r\n    // that measurements were added to the display set are the same order as\r\n    // the measurementGroups in the instance.\r\n    sopInstanceUIDToImageId,\r\n    metaData\r\n  );\r\n\r\n  const onBeforeSRHydration = customizationService.getCustomization('onBeforeSRHydration')?.value;\r\n\r\n  if (typeof onBeforeSRHydration === 'function') {\r\n    storedMeasurementByAnnotationType = onBeforeSRHydration({\r\n      storedMeasurementByAnnotationType,\r\n      displaySet,\r\n    });\r\n  }\r\n\r\n  // Filter what is found by DICOM SR to measurements we support.\r\n  const mappingDefinitions = mappings.map(m => m.annotationType);\r\n  const hydratableMeasurementsInSR = {};\r\n\r\n  Object.keys(storedMeasurementByAnnotationType).forEach(key => {\r\n    if (mappingDefinitions.includes(key)) {\r\n      hydratableMeasurementsInSR[key] = storedMeasurementByAnnotationType[key];\r\n    }\r\n  });\r\n\r\n  // Set the series touched as tracked.\r\n  const imageIds = [];\r\n\r\n  // TODO: notification if no hydratable?\r\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\r\n    const toolDataForAnnotationType = hydratableMeasurementsInSR[annotationType];\r\n\r\n    toolDataForAnnotationType.forEach(toolData => {\r\n      // Add the measurement to toolState\r\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\r\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\r\n      // in the wrong value.\r\n      const frameNumber = toolData.annotation.data?.frameNumber || 1;\r\n      const imageId = sopInstanceUIDToImageId[`${toolData.sopInstanceUid}:${frameNumber}`];\r\n\r\n      if (!imageIds.includes(imageId)) {\r\n        imageIds.push(imageId);\r\n      }\r\n    });\r\n  });\r\n\r\n  let targetStudyInstanceUID;\r\n  const SeriesInstanceUIDs = [];\r\n\r\n  for (let i = 0; i < imageIds.length; i++) {\r\n    const imageId = imageIds[i];\r\n    if (!imageId) {\r\n      continue;\r\n    }\r\n    const { SeriesInstanceUID, StudyInstanceUID } = metaData.get('instance', imageId);\r\n\r\n    if (!SeriesInstanceUIDs.includes(SeriesInstanceUID)) {\r\n      SeriesInstanceUIDs.push(SeriesInstanceUID);\r\n    }\r\n\r\n    if (!targetStudyInstanceUID) {\r\n      targetStudyInstanceUID = StudyInstanceUID;\r\n    } else if (targetStudyInstanceUID !== StudyInstanceUID) {\r\n      console.warn('NO SUPPORT FOR SRs THAT HAVE MEASUREMENTS FROM MULTIPLE STUDIES.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets reference data for what frame of reference and the referenced\r\n   * image id, or for 3d measurements, the volumeId to apply this annotation to.\r\n   */\r\n  function getReferenceData(toolData): ToolTypes.AnnotationMetadata {\r\n    // Add the measurement to toolState\r\n    // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\r\n    // files, and looking up the imageId from sopInstanceUIDToImageId results\r\n    // in the wrong value.\r\n    const frameNumber = (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\r\n    const imageId = sopInstanceUIDToImageId[`${toolData.sopInstanceUid}:${frameNumber}`];\r\n\r\n    if (!imageId) {\r\n      return getReferenceData3D(toolData, servicesManager);\r\n    }\r\n\r\n    const instance = metaData.get('instance', imageId);\r\n    const {\r\n      FrameOfReferenceUID,\r\n      // SOPInstanceUID,\r\n      // SeriesInstanceUID,\r\n      // StudyInstanceUID,\r\n    } = instance;\r\n\r\n    return {\r\n      referencedImageId: imageId,\r\n      FrameOfReferenceUID,\r\n    };\r\n  }\r\n\r\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\r\n    const toolDataForAnnotationType = hydratableMeasurementsInSR[annotationType];\r\n\r\n    toolDataForAnnotationType.forEach(toolData => {\r\n      toolData.uid = guid();\r\n      const referenceData = getReferenceData(toolData);\r\n      const { imageId } = referenceData;\r\n\r\n      const annotation = {\r\n        annotationUID: toolData.annotation.annotationUID,\r\n        data: toolData.annotation.data,\r\n        metadata: {\r\n          ...referenceData,\r\n          toolName: annotationType,\r\n        },\r\n      };\r\n      utilities.updatePlaneRestriction(annotation.data.handles.points, annotation.metadata);\r\n\r\n      const source = measurementService.getSource(\r\n        CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n        CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n      );\r\n      annotation.data.label = getLabelFromDCMJSImportedToolData(toolData);\r\n      annotation.data.finding = convertCode(codingValues, toolData.finding?.[0]);\r\n      annotation.data.findingSites = convertSites(codingValues, toolData.findingSites);\r\n      annotation.data.findingSites?.forEach(site => {\r\n        if (site.type) {\r\n          annotation.data[site.type] = site;\r\n        }\r\n      });\r\n\r\n      const matchingMapping = mappings.find(m => m.annotationType === annotationType);\r\n\r\n      const newAnnotationUID = measurementService.addRawMeasurement(\r\n        source,\r\n        annotationType,\r\n        { annotation },\r\n        matchingMapping.toMeasurementSchema,\r\n        dataSource\r\n      );\r\n\r\n      commandsManager.runCommand('updateMeasurement', {\r\n        uid: newAnnotationUID,\r\n        code: annotation.data.finding,\r\n      });\r\n\r\n      if (disableEditing) {\r\n        locking.setAnnotationLocked(newAnnotationUID, true);\r\n      }\r\n\r\n      if (imageId && !imageIds.includes(imageId)) {\r\n        imageIds.push(imageId);\r\n      }\r\n    });\r\n  });\r\n\r\n  displaySet.isHydrated = true;\r\n\r\n  return {\r\n    StudyInstanceUID: targetStudyInstanceUID,\r\n    SeriesInstanceUIDs,\r\n  };\r\n}\r\n\r\n/**\r\n * For 3d annotations, there are often several display sets which could\r\n * be used to display the annotation.  Choose the first annotation with the\r\n * same frame of reference that is reconstructable, or the first display set\r\n * otherwise.\r\n */\r\nfunction chooseDisplaySet(displaySets, annotation) {\r\n  if (!displaySets?.length) {\r\n    console.warn('No display set found for', annotation);\r\n    return;\r\n  }\r\n  if (displaySets.length === 1) {\r\n    return displaySets[0];\r\n  }\r\n  const volumeDs = displaySets.find(ds => ds.isReconstructable);\r\n  if (volumeDs) {\r\n    return volumeDs;\r\n  }\r\n  return displaySets[0];\r\n}\r\n\r\n/**\r\n * Gets the additional reference data appropriate for a 3d reference.\r\n * This will choose a volume id, frame of reference and a plane restriction.\r\n */\r\nfunction getReferenceData3D(toolData, servicesManager: Types.ServicesManager) {\r\n  const { FrameOfReferenceUID } = toolData.annotation.metadata;\r\n  const { points } = toolData.annotation.data.handles;\r\n  const { displaySetService } = servicesManager.services;\r\n  const displaySetsFOR = displaySetService.getDisplaySetsBy(\r\n    ds => ds.FrameOfReferenceUID === FrameOfReferenceUID\r\n  );\r\n  if (!displaySetsFOR.length || !points?.length) {\r\n    return {\r\n      FrameOfReferenceUID,\r\n    };\r\n  }\r\n  const ds = chooseDisplaySet(displaySetsFOR, toolData.annotation);\r\n  const cameraView = chooseCameraView(ds, points);\r\n\r\n  const viewReference = {\r\n    ...cameraView,\r\n    volumeId: ds.displaySetInstanceUID,\r\n    FrameOfReferenceUID,\r\n  };\r\n  utilities.updatePlaneRestriction(points, viewReference);\r\n  return viewReference;\r\n}\r\n\r\n/**\r\n * Chooses a possible camera view - right now this is fairly basic,\r\n * just setting the unknowns to null.\r\n */\r\nfunction chooseCameraView(_ds, points) {\r\n  const selectedPoints = choosePoints(points);\r\n  const cameraFocalPoint = <Point3>centerOf(selectedPoints);\r\n  // These are sufficient to be null for now and can be set on first view\r\n  let viewPlaneNormal: Types.Point3 = null;\r\n  let viewUp: Types.Point3 = null;\r\n\r\n  return {\r\n    cameraFocalPoint,\r\n    viewPlaneNormal,\r\n    viewUp,\r\n  };\r\n}\r\n\r\nfunction centerOf(points) {\r\n  const scale = 1 / points.length;\r\n  const center = vec3.create();\r\n  for (const point of points) {\r\n    vec3.scaleAndAdd(center, center, point, scale);\r\n  }\r\n  return center;\r\n}\r\n\r\nfunction choosePoints(points) {\r\n  if (points.length === 1 || points.length === 2) {\r\n    return points;\r\n  }\r\n  const firstIndex = 0;\r\n  const secondIndex = Math.ceil(points.length / 4);\r\n  const thirdIndex = Math.ceil(points.length / 2);\r\n  // TODO - check if colinear, if so try to find another 3 points.\r\n\r\n  const newPoints = [points[firstIndex], points[secondIndex], points[thirdIndex]];\r\n  return newPoints;\r\n}\r\n","import { metaData, utilities } from '@cornerstonejs/core';\r\n\r\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\r\nimport dcmjs from 'dcmjs';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nimport getFilteredCornerstoneToolState from './utils/getFilteredCornerstoneToolState';\r\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\r\n\r\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\r\nconst { log } = OHIF;\r\n\r\ninterface Options {\r\n  SeriesDescription?: string;\r\n  SeriesInstanceUID?: string;\r\n  SeriesNumber?: number;\r\n  InstanceNumber?: number;\r\n  SeriesDate?: string;\r\n  SeriesTime?: string;\r\n}\r\n\r\n/**\r\n * @param measurementData An array of measurements from the measurements service\r\n * that you wish to serialize.\r\n * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\r\n * @param options Naturalized DICOM JSON headers to merge into the displaySet.\r\n *\r\n */\r\nconst _generateReport = (measurementData, additionalFindingTypes, options: Options = {}) => {\r\n  const filteredToolState = getFilteredCornerstoneToolState(\r\n    measurementData,\r\n    additionalFindingTypes\r\n  );\r\n\r\n  const report = MeasurementReport.generateReport(filteredToolState, metaData, options);\r\n\r\n  const { dataset } = report;\r\n\r\n  // Set the default character set as UTF-8\r\n  // https://dicom.innolitics.com/ciods/nm-image/sop-common/00080005\r\n  if (typeof dataset.SpecificCharacterSet === 'undefined') {\r\n    dataset.SpecificCharacterSet = 'ISO_IR 192';\r\n  }\r\n\r\n  dataset.InstanceNumber = options.InstanceNumber ?? 1;\r\n\r\n  return dataset;\r\n};\r\n\r\nconst commandsModule = (props: withAppTypes) => {\r\n  const { servicesManager, extensionManager, commandsManager } = props;\r\n  const { customizationService } = servicesManager.services;\r\n\r\n  const actions = {\r\n    changeColorMeasurement: ({ uid }) => {\r\n      // When this gets supported, it probably belongs in cornerstone, not sr\r\n      throw new Error('Unsupported operation: changeColorMeasurement');\r\n      // const { color } = measurementService.getMeasurement(uid);\r\n      // const rgbaColor = {\r\n      //   r: color[0],\r\n      //   g: color[1],\r\n      //   b: color[2],\r\n      //   a: color[3] / 255.0,\r\n      // };\r\n      // colorPickerDialog(uiDialogService, rgbaColor, (newRgbaColor, actionId) => {\r\n      //   if (actionId === 'cancel') {\r\n      //     return;\r\n      //   }\r\n\r\n      //   const color = [newRgbaColor.r, newRgbaColor.g, newRgbaColor.b, newRgbaColor.a * 255.0];\r\n      // segmentationService.setSegmentColor(viewportId, segmentationId, segmentIndex, color);\r\n      // });\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param measurementData An array of measurements from the measurements service\r\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\r\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\r\n     * as opposed to Finding Sites.\r\n     * that you wish to serialize.\r\n     */\r\n    downloadReport: ({ measurementData, additionalFindingTypes, options = {} }) => {\r\n      const srDataset = _generateReport(measurementData, additionalFindingTypes, options);\r\n      const reportBlob = dcmjs.data.datasetToBlob(srDataset);\r\n\r\n      //Create a URL for the binary.\r\n      const objectUrl = URL.createObjectURL(reportBlob);\r\n      window.location.assign(objectUrl);\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param measurementData An array of measurements from the measurements service\r\n     * that you wish to serialize.\r\n     * @param dataSource The dataSource that you wish to use to persist the data.\r\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\r\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\r\n     * @return The naturalized report\r\n     */\r\n    storeMeasurements: async ({\r\n      measurementData,\r\n      dataSource,\r\n      additionalFindingTypes,\r\n      options = {},\r\n    }) => {\r\n      // Use the @cornerstonejs adapter for converting to/from DICOM\r\n      // But it is good enough for now whilst we only have cornerstone as a datasource.\r\n      log.info('[DICOMSR] storeMeasurements');\r\n\r\n      if (!dataSource || !dataSource.store || !dataSource.store.dicom) {\r\n        log.error('[DICOMSR] datasource has no dataSource.store.dicom endpoint!');\r\n        return Promise.reject({});\r\n      }\r\n\r\n      try {\r\n        const naturalizedReport = _generateReport(measurementData, additionalFindingTypes, options);\r\n\r\n        const { StudyInstanceUID, ContentSequence } = naturalizedReport;\r\n        // The content sequence has 5 or more elements, of which\r\n        // the `[4]` element contains the annotation data, so this is\r\n        // checking that there is some annotation data present.\r\n        if (!ContentSequence?.[4].ContentSequence?.length) {\r\n          console.log('naturalizedReport missing imaging content', naturalizedReport);\r\n          throw new Error('Invalid report, no content');\r\n        }\r\n        if (!naturalizedReport.SOPClassUID) {\r\n          throw new Error('No sop class uid');\r\n        }\r\n\r\n        const onBeforeDicomStore = customizationService.getCustomization('onBeforeDicomStore');\r\n\r\n        let dicomDict;\r\n        if (typeof onBeforeDicomStore === 'function') {\r\n          dicomDict = onBeforeDicomStore({ dicomDict, measurementData, naturalizedReport });\r\n        }\r\n\r\n        await dataSource.store.dicom(naturalizedReport, null, dicomDict);\r\n\r\n        if (StudyInstanceUID) {\r\n          dataSource.deleteStudyMetadataPromise(StudyInstanceUID);\r\n        }\r\n\r\n        // The \"Mode\" route listens for DicomMetadataStore changes\r\n        // When a new instance is added, it listens and\r\n        // automatically calls makeDisplaySets\r\n        DicomMetadataStore.addInstances([naturalizedReport], true);\r\n\r\n        return naturalizedReport;\r\n      } catch (error) {\r\n        console.warn(error);\r\n        log.error(`[DICOMSR] Error while saving the measurements: ${error.message}`);\r\n        throw new Error(error.message || 'Error while saving the measurements.');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Loads measurements by hydrating and loading the SR for the given display set instance UID\r\n     * and displays it in the active viewport.\r\n     */\r\n    hydrateStructuredReport: ({ displaySetInstanceUID }) => {\r\n      return hydrateStructuredReport(\r\n        { servicesManager, extensionManager, commandsManager },\r\n        displaySetInstanceUID\r\n      );\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    downloadReport: actions.downloadReport,\r\n    storeMeasurements: actions.storeMeasurements,\r\n    hydrateStructuredReport: actions.hydrateStructuredReport,\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n    defaultContext: 'CORNERSTONE_STRUCTURED_REPORT',\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import { Types, metaData, utilities as csUtils } from '@cornerstonejs/core';\r\nimport {\r\n  AnnotationTool,\r\n  annotation,\r\n  drawing,\r\n  utilities,\r\n  Types as cs3DToolsTypes,\r\n} from '@cornerstonejs/tools';\r\nimport { getTrackingUniqueIdentifiersForElement } from './modules/dicomSRModule';\r\nimport { SCOORDTypes } from '../enums';\r\nimport toolNames from './toolNames';\r\n\r\nexport default class DICOMSRDisplayTool extends AnnotationTool {\r\n  static toolName = toolNames.DICOMSRDisplay;\r\n\r\n  constructor(\r\n    toolProps = {},\r\n    defaultToolProps = {\r\n      configuration: {},\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  _getTextBoxLinesFromLabels(labels) {\r\n    // TODO -> max 5 for now (label + shortAxis + longAxis), need a generic solution for this!\r\n\r\n    const labelLength = Math.min(labels.length, 5);\r\n    const lines = [];\r\n\r\n    for (let i = 0; i < labelLength; i++) {\r\n      const labelEntry = labels[i];\r\n      lines.push(`${_labelToShorthand(labelEntry.label)}: ${labelEntry.value}`);\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  // This tool should not inherit from AnnotationTool and we should not need\r\n  // to add the following lines.\r\n  isPointNearTool = () => null;\r\n  getHandleNearImagePoint = () => null;\r\n\r\n  renderAnnotation = (enabledElement: Types.IEnabledElement, svgDrawingHelper: any): void => {\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = annotation.state.getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(element, annotations);\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const trackingUniqueIdentifiersForElement = getTrackingUniqueIdentifiersForElement(element);\r\n\r\n    const { activeIndex, trackingUniqueIdentifiers } = trackingUniqueIdentifiersForElement;\r\n\r\n    const activeTrackingUniqueIdentifier = trackingUniqueIdentifiers[activeIndex];\r\n\r\n    // Filter toolData to only render the data for the active SR.\r\n    const filteredAnnotations = annotations.filter(annotation =>\r\n      trackingUniqueIdentifiers.includes(annotation.data?.TrackingUniqueIdentifier)\r\n    );\r\n\r\n    if (!viewport._actors?.size) {\r\n      return;\r\n    }\r\n\r\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n    const { style: annotationStyle } = annotation.config;\r\n\r\n    for (let i = 0; i < filteredAnnotations.length; i++) {\r\n      const annotation = filteredAnnotations[i];\r\n      const annotationUID = annotation.annotationUID;\r\n      const { renderableData, TrackingUniqueIdentifier } = annotation.data;\r\n      const { referencedImageId } = annotation.metadata;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const groupStyle = annotationStyle.getToolGroupToolStyles(this.toolGroupId)[\r\n        this.getToolName()\r\n      ];\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color =\r\n        TrackingUniqueIdentifier === activeTrackingUniqueIdentifier\r\n          ? 'rgb(0, 255, 0)'\r\n          : this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      const options = {\r\n        color,\r\n        lineDash,\r\n        lineWidth,\r\n        ...groupStyle,\r\n      };\r\n\r\n      Object.keys(renderableData).forEach(GraphicType => {\r\n        const renderableDataForGraphicType = renderableData[GraphicType];\r\n\r\n        let renderMethod;\r\n        let canvasCoordinatesAdapter;\r\n\r\n        switch (GraphicType) {\r\n          case SCOORDTypes.POINT:\r\n            renderMethod = this.renderPoint;\r\n            break;\r\n          case SCOORDTypes.MULTIPOINT:\r\n            renderMethod = this.renderMultipoint;\r\n            break;\r\n          case SCOORDTypes.POLYLINE:\r\n            renderMethod = this.renderPolyLine;\r\n            break;\r\n          case SCOORDTypes.CIRCLE:\r\n            renderMethod = this.renderEllipse;\r\n            break;\r\n          case SCOORDTypes.ELLIPSE:\r\n            renderMethod = this.renderEllipse;\r\n            canvasCoordinatesAdapter = utilities.math.ellipse.getCanvasEllipseCorners;\r\n            break;\r\n          default:\r\n            throw new Error(`Unsupported GraphicType: ${GraphicType}`);\r\n        }\r\n\r\n        const canvasCoordinates = renderMethod(\r\n          svgDrawingHelper,\r\n          viewport,\r\n          renderableDataForGraphicType,\r\n          annotationUID,\r\n          referencedImageId,\r\n          options\r\n        );\r\n\r\n        this.renderTextBox(\r\n          svgDrawingHelper,\r\n          viewport,\r\n          canvasCoordinates,\r\n          canvasCoordinatesAdapter,\r\n          annotation,\r\n          styleSpecifier,\r\n          options\r\n        );\r\n      });\r\n    }\r\n  };\r\n\r\n  renderPolyLine(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    const drawingOptions = {\r\n      color: options.color,\r\n      width: options.lineWidth,\r\n      lineDash: options.lineDash,\r\n    };\r\n    let allCanvasCoordinates = [];\r\n    renderableData.map((data, index) => {\r\n      const canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\r\n      const lineUID = `${index}`;\r\n\r\n      if (canvasCoordinates.length === 2) {\r\n        drawing.drawLine(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates[0],\r\n          canvasCoordinates[1],\r\n          drawingOptions\r\n        );\r\n      } else {\r\n        drawing.drawPolyline(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates,\r\n          drawingOptions\r\n        );\r\n      }\r\n\r\n      allCanvasCoordinates = allCanvasCoordinates.concat(canvasCoordinates);\r\n    });\r\n\r\n    return allCanvasCoordinates; // used for drawing textBox\r\n  }\r\n\r\n  renderMultipoint(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    let canvasCoordinates;\r\n    renderableData.map((data, index) => {\r\n      canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\r\n      const handleGroupUID = '0';\r\n      drawing.drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\r\n        color: options.color,\r\n      });\r\n    });\r\n  }\r\n\r\n  renderPoint(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    const canvasCoordinates = [];\r\n    renderableData.map((data, index) => {\r\n      const point = data[0];\r\n      // This gives us one point for arrow\r\n      canvasCoordinates.push(viewport.worldToCanvas(point));\r\n\r\n      if (data[1] !== undefined) {\r\n        canvasCoordinates.push(viewport.worldToCanvas(data[1]));\r\n      }\r\n      else{\r\n         // We get the other point for the arrow by using the image size\r\n      const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\r\n\r\n      let xOffset = 10;\r\n      let yOffset = 10;\r\n\r\n      if (imagePixelModule) {\r\n        const { columns, rows } = imagePixelModule;\r\n        xOffset = columns / 10;\r\n        yOffset = rows / 10;\r\n      }\r\n\r\n      const imagePoint = csUtils.worldToImageCoords(referencedImageId, point);\r\n      const arrowEnd = csUtils.imageToWorldCoords(referencedImageId, [\r\n        imagePoint[0] + xOffset,\r\n        imagePoint[1] + yOffset,\r\n      ]);\r\n\r\n      canvasCoordinates.push(viewport.worldToCanvas(arrowEnd));\r\n        \r\n      }\r\n     \r\n\r\n      const arrowUID = `${index}`;\r\n\r\n      // Todo: handle drawing probe as probe, currently we are drawing it as an arrow\r\n      drawing.drawArrow(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        arrowUID,\r\n        canvasCoordinates[1],\r\n        canvasCoordinates[0],\r\n        {\r\n          color: options.color,\r\n          width: options.lineWidth,\r\n        }\r\n      );\r\n    });\r\n\r\n    return canvasCoordinates; // used for drawing textBox\r\n  }\r\n\r\n  renderEllipse(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    let canvasCoordinates;\r\n    renderableData.map((data, index) => {\r\n      if (data.length === 0) {\r\n        // since oblique ellipse is not supported for hydration right now\r\n        // we just return\r\n        return;\r\n      }\r\n\r\n      const ellipsePointsWorld = data;\r\n\r\n      const rotation = viewport.getRotation();\r\n\r\n      canvasCoordinates = ellipsePointsWorld.map(p => viewport.worldToCanvas(p));\r\n      let canvasCorners;\r\n      if (rotation == 90 || rotation == 270) {\r\n        canvasCorners = utilities.math.ellipse.getCanvasEllipseCorners([\r\n          canvasCoordinates[2],\r\n          canvasCoordinates[3],\r\n          canvasCoordinates[0],\r\n          canvasCoordinates[1],\r\n        ]) as Array<Types.Point2>;\r\n      } else {\r\n        canvasCorners = utilities.math.ellipse.getCanvasEllipseCorners(\r\n          canvasCoordinates\r\n        ) as Array<Types.Point2>;\r\n      }\r\n\r\n      const lineUID = `${index}`;\r\n      drawing.drawEllipse(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCorners[0],\r\n        canvasCorners[1],\r\n        {\r\n          color: options.color,\r\n          width: options.lineWidth,\r\n          lineDash: options.lineDash,\r\n        }\r\n      );\r\n    });\r\n\r\n    return canvasCoordinates;\r\n  }\r\n\r\n  renderTextBox(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    canvasCoordinates,\r\n    canvasCoordinatesAdapter,\r\n    annotation,\r\n    styleSpecifier,\r\n    options = {}\r\n  ) {\r\n    if (!canvasCoordinates || !annotation) {\r\n      return;\r\n    }\r\n\r\n    const { annotationUID, data = {} } = annotation;\r\n    const { labels } = data;\r\n    const { color } = options;\r\n\r\n    let adaptedCanvasCoordinates = canvasCoordinates;\r\n    // adapt coordinates if there is an adapter\r\n    if (typeof canvasCoordinatesAdapter === 'function') {\r\n      adaptedCanvasCoordinates = canvasCoordinatesAdapter(canvasCoordinates);\r\n    }\r\n    const textLines = this._getTextBoxLinesFromLabels(labels);\r\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(adaptedCanvasCoordinates);\r\n\r\n    if (!annotation.data?.handles?.textBox?.worldPosition) {\r\n      annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);\r\n    }\r\n\r\n    const textBoxPosition = viewport.worldToCanvas(annotation.data.handles.textBox.worldPosition);\r\n\r\n    const textBoxUID = '1';\r\n    const textBoxOptions = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n\r\n    const boundingBox = drawing.drawLinkedTextBox(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      textBoxUID,\r\n      textLines,\r\n      textBoxPosition,\r\n      canvasCoordinates,\r\n      {},\r\n      {\r\n        ...textBoxOptions,\r\n        color,\r\n      }\r\n    );\r\n\r\n    const { x: left, y: top, width, height } = boundingBox;\r\n\r\n    annotation.data.handles.textBox.worldBoundingBox = {\r\n      topLeft: viewport.canvasToWorld([left, top]),\r\n      topRight: viewport.canvasToWorld([left + width, top]),\r\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n    };\r\n  }\r\n}\r\n\r\nconst SHORT_HAND_MAP = {\r\n  'Short Axis': 'W: ',\r\n  'Long Axis': 'L: ',\r\n  AREA: 'Area: ',\r\n  Length: '',\r\n  CORNERSTONEFREETEXT: '',\r\n};\r\n\r\nfunction _labelToShorthand(label) {\r\n  const shortHand = SHORT_HAND_MAP[label];\r\n\r\n  if (shortHand !== undefined) {\r\n    return shortHand;\r\n  }\r\n\r\n  return label;\r\n}\r\n","import { type Types } from '@cornerstonejs/core';\r\nimport {\r\n  annotation,\r\n  drawing,\r\n  utilities,\r\n  Types as cs3DToolsTypes,\r\n  AnnotationDisplayTool,\r\n} from '@cornerstonejs/tools';\r\nimport toolNames from './toolNames';\r\nimport { Annotation } from '@cornerstonejs/tools/dist/types/types';\r\n\r\nexport default class SCOORD3DPointTool extends AnnotationDisplayTool {\r\n  static toolName = toolNames.SRSCOORD3DPoint;\r\n\r\n  constructor(\r\n    toolProps = {},\r\n    defaultToolProps = {\r\n      configuration: {},\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  _getTextBoxLinesFromLabels(labels) {\r\n    // TODO -> max 5 for now (label + shortAxis + longAxis), need a generic solution for this!\r\n\r\n    const labelLength = Math.min(labels.length, 5);\r\n    const lines = [];\r\n\r\n    return lines;\r\n  }\r\n\r\n  // This tool should not inherit from AnnotationTool and we should not need\r\n  // to add the following lines.\r\n  isPointNearTool = () => null;\r\n  getHandleNearImagePoint = () => null;\r\n\r\n  renderAnnotation = (enabledElement: Types.IEnabledElement, svgDrawingHelper: any): void => {\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    const annotations = annotation.state.getAnnotations(this.getToolName(), element);\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    // Filter toolData to only render the data for the active SR.\r\n    const filteredAnnotations = annotations;\r\n    if (!viewport._actors?.size) {\r\n      return;\r\n    }\r\n\r\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < filteredAnnotations.length; i++) {\r\n      const annotation = filteredAnnotations[i];\r\n\r\n      const annotationUID = annotation.annotationUID;\r\n      const { renderableData } = annotation.data;\r\n      const { POINT: points } = renderableData;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color = this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      const options = {\r\n        color,\r\n        lineDash,\r\n        lineWidth,\r\n      };\r\n\r\n      const point = points[0][0];\r\n\r\n      // check if viewport can render it\r\n      const viewable = viewport.isReferenceViewable(\r\n        { FrameOfReferenceUID: annotation.metadata.FrameOfReferenceUID, cameraFocalPoint: point },\r\n        { asNearbyProjection: true }\r\n      );\r\n\r\n      if (!viewable) {\r\n        continue;\r\n      }\r\n\r\n      // render the point\r\n      const arrowPointCanvas = viewport.worldToCanvas(point);\r\n      // Todo: configure this\r\n      const arrowEndCanvas = [arrowPointCanvas[0] + 20, arrowPointCanvas[1] + 20];\r\n      const canvasCoordinates = [arrowPointCanvas, arrowEndCanvas];\r\n\r\n      drawing.drawArrow(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        '1',\r\n        canvasCoordinates[1],\r\n        canvasCoordinates[0],\r\n        {\r\n          color: options.color,\r\n          width: options.lineWidth,\r\n        }\r\n      );\r\n\r\n      this.renderTextBox(\r\n        svgDrawingHelper,\r\n        viewport,\r\n        canvasCoordinates,\r\n        annotation,\r\n        styleSpecifier,\r\n        options\r\n      );\r\n    }\r\n  };\r\n\r\n  renderTextBox(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    canvasCoordinates,\r\n    annotation,\r\n    styleSpecifier,\r\n    options = {}\r\n  ) {\r\n    if (!canvasCoordinates || !annotation) {\r\n      return;\r\n    }\r\n\r\n    const { annotationUID, data = {} } = annotation;\r\n    const { labels } = data;\r\n\r\n    const textLines = [];\r\n\r\n    for (const label of labels) {\r\n      // make this generic\r\n      // fix this\r\n      if (label.label === '363698007') {\r\n        textLines.push(`Finding Site: ${label.value}`);\r\n      }\r\n    }\r\n\r\n    const { color } = options;\r\n\r\n    const adaptedCanvasCoordinates = canvasCoordinates;\r\n    // adapt coordinates if there is an adapter\r\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(adaptedCanvasCoordinates);\r\n\r\n    if (!annotation.data?.handles?.textBox?.worldPosition) {\r\n      annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);\r\n    }\r\n\r\n    const textBoxPosition = viewport.worldToCanvas(annotation.data.handles.textBox.worldPosition);\r\n\r\n    const textBoxUID = '1';\r\n    const textBoxOptions = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\r\n\r\n    const boundingBox = drawing.drawLinkedTextBox(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      textBoxUID,\r\n      textLines,\r\n      textBoxPosition,\r\n      canvasCoordinates,\r\n      {},\r\n      {\r\n        ...textBoxOptions,\r\n        color,\r\n      }\r\n    );\r\n\r\n    const { x: left, y: top, width, height } = boundingBox;\r\n\r\n    annotation.data.handles.textBox.worldBoundingBox = {\r\n      topLeft: viewport.canvasToWorld([left, top]),\r\n      topRight: viewport.canvasToWorld([left + width, top]),\r\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n    };\r\n  }\r\n\r\n  public getLinkedTextBoxStyle(\r\n    specifications: cs3DToolsTypes.AnnotationStyle.StyleSpecifier,\r\n    annotation?: Annotation\r\n  ): Record<string, unknown> {\r\n    // Todo: this function can be used to set different styles for different toolMode\r\n    // for the textBox.\r\n\r\n    return {\r\n      visibility: this.getStyle('textBoxVisibility', specifications, annotation),\r\n      fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\r\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\r\n      color: this.getStyle('textBoxColor', specifications, annotation),\r\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\r\n      background: this.getStyle('textBoxBackground', specifications, annotation),\r\n      lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\r\n      lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\r\n    };\r\n  }\r\n}\r\n","const SRSCOOR3DProbe = {\r\n  toAnnotation: measurement => {},\r\n\r\n  /**\r\n   * Maps cornerstone annotation event data to measurement service format.\r\n   *\r\n   * @param {Object} cornerstone Cornerstone event data\r\n   * @return {Measurement} Measurement instance\r\n   */\r\n  toMeasurement: ({ servicesManager, getValueTypeFromToolType }, csToolsEventDetail) => {\r\n    const { displaySetService } = servicesManager.services;\r\n    const { annotation } = csToolsEventDetail;\r\n    const { metadata, data, annotationUID } = annotation;\r\n\r\n    if (!metadata || !data) {\r\n      console.warn('Probe tool: Missing metadata or data');\r\n      return null;\r\n    }\r\n\r\n    const { toolName, FrameOfReferenceUID } = metadata;\r\n    const { points } = data.handles;\r\n\r\n    const displaySets = displaySetService\r\n      .getActiveDisplaySets()\r\n      .filter(ds => ds.FrameOfReferenceUID === FrameOfReferenceUID);\r\n    const displaySet = displaySets.filter(ds => ds.isReconstructable)[0] || displaySets[0];\r\n\r\n    const { StudyInstanceUID: referenceStudyUID, SeriesInstanceUID: referenceSeriesUID } =\r\n      displaySets[0] || {};\r\n\r\n    const displayText = getDisplayText(annotation);\r\n    return {\r\n      uid: annotationUID,\r\n      points,\r\n      metadata,\r\n      referenceStudyUID,\r\n      referenceSeriesUID,\r\n      displaySetInstanceUID: displaySet?.displaySetInstanceUID,\r\n      toolName: metadata.toolName,\r\n      label: data.label,\r\n      displayText: displayText,\r\n      data: data.cachedStats,\r\n      type: getValueTypeFromToolType?.(toolName) ?? null,\r\n    };\r\n  },\r\n};\r\n\r\nfunction getDisplayText(annotation) {\r\n  const { data } = annotation;\r\n\r\n  if (!data) {\r\n    return [''];\r\n  }\r\n  const { labels } = data;\r\n\r\n  const displayText = [];\r\n\r\n  for (const label of labels) {\r\n    // make this generic\r\n    if (label.label === '33636980076') {\r\n      displayText.push(`Finding Site: ${label.value}`);\r\n    }\r\n  }\r\n\r\n  return {\r\n    primary: displayText,\r\n    secondary: [],\r\n  };\r\n}\r\n\r\nexport default SRSCOOR3DProbe;\r\n","import { addTool } from '@cornerstonejs/tools';\r\n\r\nexport default function addToolInstance(name: string, toolClass, configuration = {}): void {\r\n  class InstanceClass extends toolClass {\r\n    static toolName = name;\r\n    constructor(toolProps, defaultToolProps) {\r\n      toolProps.configuration = toolProps.configuration\r\n        ? { ...toolProps.configuration, ...configuration }\r\n        : configuration;\r\n      super(toolProps, defaultToolProps);\r\n    }\r\n  }\r\n  addTool(InstanceClass);\r\n}\r\n","import {\r\n  AngleTool,\r\n  annotation,\r\n  ArrowAnnotateTool,\r\n  BidirectionalTool,\r\n  CobbAngleTool,\r\n  EllipticalROITool,\r\n  CircleROITool,\r\n  LengthTool,\r\n  PlanarFreehandROITool,\r\n  RectangleROITool,\r\n} from '@cornerstonejs/tools';\r\nimport { Types } from '@ohif/core';\r\nimport { Enums as CSExtensionEnums } from '@ohif/extension-cornerstone';\r\n\r\nimport DICOMSRDisplayTool from './tools/DICOMSRDisplayTool';\r\nimport SCOORD3DPointTool from './tools/SCOORD3DPointTool';\r\nimport SRSCOOR3DProbeMapper from './utils/SRSCOOR3DProbeMapper';\r\nimport addToolInstance from './utils/addToolInstance';\r\nimport toolNames from './tools/toolNames';\r\n\r\nconst { CORNERSTONE_3D_TOOLS_SOURCE_NAME, CORNERSTONE_3D_TOOLS_SOURCE_VERSION } = CSExtensionEnums;\r\n\r\n/**\r\n * @param {object} configuration\r\n */\r\nexport default function init({\r\n  configuration = {},\r\n  servicesManager,\r\n}: Types.Extensions.ExtensionParams): void {\r\n  const { measurementService } = servicesManager.services;\r\n\r\n  addToolInstance(toolNames.DICOMSRDisplay, DICOMSRDisplayTool);\r\n  addToolInstance(toolNames.SRLength, LengthTool);\r\n  addToolInstance(toolNames.SRBidirectional, BidirectionalTool);\r\n  addToolInstance(toolNames.SREllipticalROI, EllipticalROITool);\r\n  addToolInstance(toolNames.SRCircleROI, CircleROITool);\r\n  addToolInstance(toolNames.SRArrowAnnotate, ArrowAnnotateTool);\r\n  addToolInstance(toolNames.SRAngle, AngleTool);\r\n  addToolInstance(toolNames.SRPlanarFreehandROI, PlanarFreehandROITool);\r\n  addToolInstance(toolNames.SRRectangleROI, RectangleROITool);\r\n  addToolInstance(toolNames.SRSCOORD3DPoint, SCOORD3DPointTool);\r\n\r\n  // TODO - fix the SR display of Cobb Angle, as it joins the two lines\r\n  addToolInstance(toolNames.SRCobbAngle, CobbAngleTool);\r\n\r\n  const csTools3DVer1MeasurementSource = measurementService.getSource(\r\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n  );\r\n\r\n  const { POINT } = measurementService.VALUE_TYPES;\r\n\r\n  measurementService.addMapping(\r\n    csTools3DVer1MeasurementSource,\r\n    'SRSCOORD3DPoint',\r\n    POINT,\r\n    SRSCOOR3DProbeMapper.toAnnotation,\r\n    SRSCOOR3DProbeMapper.toMeasurement.bind(null, { servicesManager })\r\n  );\r\n\r\n  // Modify annotation tools to use dashed lines on SR\r\n  const dashedLine = {\r\n    lineDash: '4,4',\r\n  };\r\n  annotation.config.style.setToolGroupToolStyles('SRToolGroup', {\r\n    [toolNames.DICOMSRDisplay]: dashedLine,\r\n    SRLength: dashedLine,\r\n    SRBidirectional: dashedLine,\r\n    SREllipticalROI: dashedLine,\r\n    SRCircleROI: dashedLine,\r\n    SRArrowAnnotate: dashedLine,\r\n    SRCobbAngle: dashedLine,\r\n    SRAngle: dashedLine,\r\n    SRPlanarFreehandROI: dashedLine,\r\n    SRRectangleROI: dashedLine,\r\n    global: {},\r\n  });\r\n}\r\n","import React from 'react';\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport { srProtocol } from './getHangingProtocolModule';\r\nimport onModeEnter from './onModeEnter';\r\nimport getCommandsModule from './commandsModule';\r\nimport preRegistration from './init';\r\nimport { id } from './id.js';\r\nimport toolNames from './tools/toolNames';\r\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\r\nimport createReferencedImageDisplaySet from './utils/createReferencedImageDisplaySet';\r\nimport Enums from './enums';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(/* webpackPrefetch: true */ './components/OHIFCornerstoneSRViewport');\r\n});\r\n\r\nconst OHIFCornerstoneSRViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n *\r\n */\r\nconst dicomSRExtension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   */\r\n  id,\r\n\r\n  onModeEnter,\r\n\r\n  preRegistration,\r\n\r\n  /**\r\n   *\r\n   *\r\n   * @param {object} [configuration={}]\r\n   * @param {object|array} [configuration.csToolsConfig] - Passed directly to `initCornerstoneTools`\r\n   */\r\n  getViewportModule({ servicesManager, extensionManager }) {\r\n    const ExtendedOHIFCornerstoneSRViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSRViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-sr', component: ExtendedOHIFCornerstoneSRViewport }];\r\n  },\r\n  getCommandsModule,\r\n  getSopClassHandlerModule,\r\n  // Include dynamically computed values such as toolNames not known till instantiation\r\n  getUtilityModule({ servicesManager }) {\r\n    return [\r\n      {\r\n        name: 'tools',\r\n        exports: {\r\n          toolNames,\r\n        },\r\n      },\r\n    ];\r\n  },\r\n};\r\n\r\nexport default dicomSRExtension;\r\n\r\n// Put static exports here so they can be type checked\r\nexport { hydrateStructuredReport, createReferencedImageDisplaySet, srProtocol, Enums, toolNames };\r\n","import { SOPClassHandlerId, SOPClassHandlerId3D } from './id';\r\n\r\nexport default function onModeEnter({ servicesManager }) {\r\n  const { displaySetService } = servicesManager.services;\r\n  const displaySetCache = displaySetService.getDisplaySetCache();\r\n\r\n  const srDisplaySets = [...displaySetCache.values()].filter(\r\n    ds => ds.SOPClassHandlerId === SOPClassHandlerId || ds.SOPClassHandlerId === SOPClassHandlerId3D\r\n  );\r\n\r\n  srDisplaySets.forEach(ds => {\r\n    // New mode route, allow SRs to be hydrated again\r\n    ds.isHydrated = false;\r\n  });\r\n}\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\n\r\nconst state = {\r\n  TrackingUniqueIdentifier: null,\r\n  trackingIdentifiersByViewportId: {},\r\n};\r\n\r\n/**\r\n * This file is being used to store the per-viewport state of the SR tools,\r\n * Since, all the toolStates are added to the cornerstoneTools, when displaying the SRTools,\r\n * if there are two viewports rendering the same imageId, we don't want to show\r\n * the same SR annotation twice on irrelevant viewport, hence, we are storing the state\r\n * of the SR tools in state here, so that we can filter them later.\r\n */\r\n\r\nfunction setTrackingUniqueIdentifiersForElement(\r\n  element,\r\n  trackingUniqueIdentifiers,\r\n  activeIndex = 0\r\n) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  state.trackingIdentifiersByViewportId[viewport.id] = {\r\n    trackingUniqueIdentifiers,\r\n    activeIndex,\r\n  };\r\n}\r\n\r\nfunction setActiveTrackingUniqueIdentifierForElement(element, TrackingUniqueIdentifier) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  const trackingIdentifiersForElement = state.trackingIdentifiersByViewportId[viewport.id];\r\n\r\n  if (trackingIdentifiersForElement) {\r\n    const activeIndex = trackingIdentifiersForElement.trackingUniqueIdentifiers.findIndex(\r\n      tuid => tuid === TrackingUniqueIdentifier\r\n    );\r\n\r\n    trackingIdentifiersForElement.activeIndex = activeIndex;\r\n  }\r\n}\r\n\r\nfunction getTrackingUniqueIdentifiersForElement(element) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  if (state.trackingIdentifiersByViewportId[viewport.id]) {\r\n    return state.trackingIdentifiersByViewportId[viewport.id];\r\n  }\r\n\r\n  return { trackingUniqueIdentifiers: [] };\r\n}\r\n\r\nexport {\r\n  setTrackingUniqueIdentifiersForElement,\r\n  setActiveTrackingUniqueIdentifierForElement,\r\n  getTrackingUniqueIdentifiersForElement,\r\n};\r\n","import { DisplaySetService, classes } from '@ohif/core';\r\n\r\nconst ImageSet = classes.ImageSet;\r\n\r\nconst findInstance = (measurement, displaySetService: DisplaySetService) => {\r\n  const { displaySetInstanceUID, ReferencedSOPInstanceUID: sopUid } = measurement;\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n  if (!referencedDisplaySet.images) {\r\n    return;\r\n  }\r\n  return referencedDisplaySet.images.find(it => it.SOPInstanceUID === sopUid);\r\n};\r\n\r\n/** Finds references to display sets inside the measurements\r\n * contained within the provided display set.\r\n * @return an array of instances referenced.\r\n */\r\nconst findReferencedInstances = (displaySetService: DisplaySetService, displaySet) => {\r\n  const instances = [];\r\n  const instanceById = {};\r\n  for (const measurement of displaySet.measurements) {\r\n    const { imageId } = measurement;\r\n    if (!imageId) {\r\n      continue;\r\n    }\r\n    if (instanceById[imageId]) {\r\n      continue;\r\n    }\r\n\r\n    const instance = findInstance(measurement, displaySetService);\r\n    if (!instance) {\r\n      console.log('Measurement', measurement, 'had no instances found');\r\n      continue;\r\n    }\r\n\r\n    instanceById[imageId] = instance;\r\n    instances.push(instance);\r\n  }\r\n  return instances;\r\n};\r\n\r\n/**\r\n * Creates a new display set containing a single image instance for each\r\n * referenced image.\r\n *\r\n * @param displaySetService\r\n * @param displaySet - containing measurements referencing images.\r\n * @returns A new (registered/active) display set containing the referenced images\r\n */\r\nconst createReferencedImageDisplaySet = (displaySetService, displaySet) => {\r\n  const instances = findReferencedInstances(displaySetService, displaySet);\r\n  // This will be a  member function of the created image set\r\n  const updateInstances = function () {\r\n    this.images.splice(\r\n      0,\r\n      this.images.length,\r\n      ...findReferencedInstances(displaySetService, displaySet)\r\n    );\r\n    this.numImageFrames = this.images.length;\r\n  };\r\n\r\n  const imageSet = new ImageSet(instances);\r\n  const instance = instances[0];\r\n\r\n  if (!instance) {\r\n    return;\r\n  }\r\n\r\n  imageSet.setAttributes({\r\n    displaySetInstanceUID: imageSet.uid, // create a local alias for the imageSet UID\r\n    SeriesDate: instance.SeriesDate,\r\n    SeriesTime: instance.SeriesTime,\r\n    SeriesInstanceUID: imageSet.uid,\r\n    StudyInstanceUID: instance.StudyInstanceUID,\r\n    SeriesNumber: instance.SeriesNumber || 0,\r\n    SOPClassUID: instance.SOPClassUID,\r\n    SeriesDescription: `${displaySet.SeriesDescription} KO ${displaySet.instance.SeriesNumber}`,\r\n    Modality: 'KO',\r\n    isMultiFrame: false,\r\n    numImageFrames: instances.length,\r\n    SOPClassHandlerId: `@ohif/extension-default.sopClassHandlerModule.stack`,\r\n    isReconstructable: false,\r\n    // This object is made of multiple instances from other series\r\n    isCompositeStack: true,\r\n    madeInClient: true,\r\n    excludeFromThumbnailBrowser: true,\r\n    updateInstances,\r\n  });\r\n\r\n  displaySetService.addDisplaySets(imageSet);\r\n\r\n  return imageSet;\r\n};\r\n\r\nexport default createReferencedImageDisplaySet;\r\n"],"names":["CodeScheme","Cornerstone3DCodeScheme","adaptersSR","Cornerstone3D","SCOORDTypes","POINT","MULTIPOINT","POLYLINE","CIRCLE","ELLIPSE","CodeNameCodeSequenceValues","ImagingMeasurementReport","ImageLibrary","ImagingMeasurements","MeasurementGroup","ImageLibraryGroup","TrackingUniqueIdentifier","TrackingIdentifier","Finding","FindingSite","FindingSiteSCT","CodingSchemeDesignators","SRT","SCT","CornerstoneCodeSchemes","CodingSchemeDesignator","RelationshipType","INFERRED_FROM","CONTAINS","EPSILON","getRenderableCoords","GraphicData","ValueType","imageId","renderableData","i","length","push","worldPos","utilities","GraphicType","pointsWorld","center","onPerimeter","radius","vec3","imagePlaneModule","metaData","Error","columnCosines","rowCosines","firstAxisStart","firstAxisEnd","secondAxisStart","secondAxisEnd","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","Math","abs","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","console","warn","DICOMSRDisplay","SRLength","SRBidirectional","SREllipticalROI","SRCircleROI","SRArrowAnnotate","SRAngle","SRCobbAngle","SRRectangleROI","SRPlanarFreehandROI","SRSCOORD3DPoint","MeasurementReport","addSRAnnotation","measurement","frameNumber","displaySet","toolName","toolNames","coords","reduce","acc","coordProps","getRenderableData","valueType","graphicType","graphicTypePoints","frameOfReferenceUID","planeRestriction","getAdapterForTrackingIdentifier","ReferencedFrameOfReferenceSequence","FrameOfReferenceUID","point","viewReference","referencedImageId","SRAnnotation","annotationUID","highlighted","isLocked","isPreview","invalidated","metadata","displaySetInstanceUID","data","label","labels","value","undefined","displayText","handles","textBox","points","cachedStats","annotation","addAnnotation","id","packageJson","SOPClassHandlerName","SOPClassHandlerId","SOPClassHandlerName3D","SOPClassHandlerId3D","sopClassDictionary","utils","CORNERSTONE_3D_TOOLS_SOURCE_NAME","CORNERSTONE_3D_TOOLS_SOURCE_VERSION","CSExtensionEnums","MetadataProvider","metadataProvider","classes","TEXT_ANNOTATION_POSITION","COMMENT_CODE","sopClassUids","BasicTextSR","EnhancedSR","ComprehensiveSR","Comprehensive3DSR","addInstances","instances","_displaySetService","this","sortStudyInstances","instance","isLoaded","_getDisplaySetsFromSeries","servicesManager","extensionManager","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SeriesTime","ConceptNameCodeSequence","SOPClassUID","validateSameStudyUID","uid","forEach","it","is3DSR","isImagingMeasurementReport","CodeValue","Modality","guid","referencedImages","measurements","isDerivedDisplaySet","i18n","t","load","async","srDisplaySet","displaySetService","measurementService","services","dataSources","getDataSources","dataSource","ContentSequence","retrieveBulkData","obj","parentObj","key","prop","Array","isArray","Promise","all","map","item","retrieve","bulkDataURI","BulkDataURI","Float32Array","ImagingMeasurementReportContentSequence","find","_getSequenceAsArray","ReferencedSOPSequence","ref","ReferencedSOPClassUID","ReferencedSOPInstanceUID","_getReferencedImagesList","mergedContentSequencesByTrackingUniqueIdentifiers","MeasurementGroups","TrackingUniqueIdentifierItem","trackingUniqueIdentifier","UID","_getMergedContentSequencesByTrackingUniqueIdentifiers","filter","Object","keys","mergedContentSequence","some","group","isScoordOr3d","concept","schemeDesignator","isTextPosition","graphicItem","UIDREFContentItem","TrackingIdentifierContentItem","NUMContentItems","conceptNameItem","graphicValue","graphicDesignator","graphicCode","pointDataItem","_getCoordsFromSCOORDOrSCOORD3D","is3DMeasurement","pointLength","pointsLength","loaded","TextValue","MeasuredValueSequence","_getLabelFromMeasuredValueSequence","findingSites","ConceptCodeSequence","CodeMeaning","_processTID1410Measurement","finding","commentSites","includes","codeValues","CORNERSTONEFREETEXT","cornerstoneFreeTextFindingSite","_processNonGeometricallyDefinedMeasurement","_processMeasurement","_getMeasurements","mappings","getSourceMappings","isHydrated","isRehydratable","mappingDefinitions","Set","m","add","annotationType","adapter","adapters","getAdaptersForTypes","hydratable","has","toolType","log","activeDisplaySets","activeDisplaySet","_checkIfCanAddMeasurementsToDisplaySet","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","newDisplaySet","_load","_measurementBelongsToDisplaySet","customizationService","unloadedMeasurements","unsupported","imageIdMap","Map","imageIds","getImageIdsForDisplaySet","getUIDsFromImageID","set","j","onBeforeSRAddMeasurement","getCustomization","splice","referencedSOPSequence","frame","ReferencedFrameNumber","get","_measurementReferencesSOPInstanceUID","Number","coord","ReferencedFrameOfReferenceUID","NumericValue","MeasurementUnitsCodeSequence","toFixed","sequence","params","getDisplaySetsFromSeries","name","srProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","srDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","measurementData","additionalFindingTypes","filteredToolState","addToFilteredToolState","NO_IMAGE_ID","imageIdSpecificToolState","measurementDataI","md","toolData","assign","uids","slice","annotationManager","getAnnotationManager","framesOfReference","getFramesOfReference","frameOfReference","frameOfReferenceAnnotations","getAnnotations","toolTypes","annotations","k","uidIndex","findIndex","locking","CsAnnotation","OHIF","convertCode","codingValues","code","text","convertSites","sites","ret","site","hydrateStructuredReport","commandsManager","getActiveDataSource","disableEditing","getDisplaySetByUID","DicomMetadataStore","getInstance","sopInstanceUIDToImageId","datasetToUse","storedMeasurementByAnnotationType","generateToolState","onBeforeSRHydration","hydratableMeasurementsInSR","targetStudyInstanceUID","sopInstanceUid","SeriesInstanceUIDs","getReferenceData","displaySetsFOR","getDisplaySetsBy","ds","volumeDs","isReconstructable","chooseDisplaySet","chooseCameraView","volumeId","getReferenceData3D","referenceData","source","getSource","freeTextLabel","fs","getLabelFromDCMJSImportedToolData","type","matchingMapping","newAnnotationUID","addRawMeasurement","toMeasurementSchema","runCommand","setAnnotationLocked","_ds","selectedPoints","firstIndex","secondIndex","ceil","thirdIndex","newPoints","choosePoints","cameraFocalPoint","scale","centerOf","viewPlaneNormal","viewUp","_generateReport","options","getFilteredCornerstoneToolState","report","generateReport","dataset","SpecificCharacterSet","InstanceNumber","props","actions","changeColorMeasurement","downloadReport","srDataset","reportBlob","dcmjs","datasetToBlob","objectUrl","URL","createObjectURL","window","location","storeMeasurements","info","store","dicom","error","reject","naturalizedReport","onBeforeDicomStore","dicomDict","deleteStudyMetadataPromise","message","definitions","defaultContext","DICOMSRDisplayTool","AnnotationTool","constructor","toolProps","defaultToolProps","configuration","super","isPointNearTool","getHandleNearImagePoint","renderAnnotation","enabledElement","svgDrawingHelper","viewport","element","getToolName","filterInteractableAnnotationsForElement","trackingUniqueIdentifiersForElement","getTrackingUniqueIdentifiersForElement","activeIndex","trackingUniqueIdentifiers","activeTrackingUniqueIdentifier","filteredAnnotations","_actors","size","styleSpecifier","viewportId","style","annotationStyle","groupStyle","getToolGroupToolStyles","lineWidth","getStyle","lineDash","color","renderableDataForGraphicType","renderMethod","canvasCoordinatesAdapter","renderPoint","renderMultipoint","renderPolyLine","renderEllipse","canvasCoordinates","renderTextBox","_getTextBoxLinesFromLabels","labelLength","min","lines","labelEntry","_labelToShorthand","drawingOptions","width","allCanvasCoordinates","index","p","worldToCanvas","lineUID","drawing","concat","imagePixelModule","xOffset","yOffset","imagePoint","csUtils","arrowEnd","arrowUID","ellipsePointsWorld","rotation","getRotation","canvasCorners","adaptedCanvasCoordinates","textLines","canvasTextBoxCoords","worldPosition","canvasToWorld","textBoxPosition","textBoxOptions","getLinkedTextBoxStyle","boundingBox","x","left","y","top","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","SHORT_HAND_MAP","AREA","Length","shortHand","SCOORD3DPointTool","AnnotationDisplayTool","isReferenceViewable","asNearbyProjection","arrowPointCanvas","specifications","visibility","fontFamily","fontSize","shadow","background","toAnnotation","toMeasurement","getValueTypeFromToolType","csToolsEventDetail","getActiveDisplaySets","referenceStudyUID","referenceSeriesUID","primary","secondary","getDisplayText","addToolInstance","toolClass","InstanceClass","addTool","Component","React","OHIFCornerstoneSRViewport","fallback","onModeEnter","getDisplaySetCache","values","preRegistration","LengthTool","BidirectionalTool","EllipticalROITool","CircleROITool","ArrowAnnotateTool","AngleTool","PlanarFreehandROITool","RectangleROITool","CobbAngleTool","csTools3DVer1MeasurementSource","VALUE_TYPES","addMapping","SRSCOOR3DProbeMapper","bind","dashedLine","setToolGroupToolStyles","global","getViewportModule","component","_extends","getCommandsModule","getSopClassHandlerModule","getUtilityModule","exports","state","trackingIdentifiersByViewportId","setTrackingUniqueIdentifiersForElement","getEnabledElement","ImageSet","findInstance","sopUid","referencedDisplaySet","images","findReferencedInstances","instanceById","createReferencedImageDisplaySet","imageSet","setAttributes","isMultiFrame","numImageFrames","isCompositeStack","madeInClient","excludeFromThumbnailBrowser","updateInstances","addDisplaySets"],"sourceRoot":""}