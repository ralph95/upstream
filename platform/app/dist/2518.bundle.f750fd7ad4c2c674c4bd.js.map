{"version":3,"file":"2518.bundle.f750fd7ad4c2c674c4bd.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/toArray.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/codeMeaningEquals.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/CircleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/getDatasetsFromImages.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/checkOrientation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/checkIfPerpendicular.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/ParametricMap.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/copyStudyTags.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/copySeriesTags.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/scoordToWorld.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/constants/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/toScoordType.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/LabelData.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/toPoint3.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/BaseAdapter3D.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/CircleROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/EllipticalROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RectangleROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/PlanarFreehandROI.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Probe.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/UltrasoundDirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateLabelMaps2DFrom3D.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/compactMergeSegData.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/labelmapImagesFromBuffer.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/Segmentation/generateToolState.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/ParametricMap/generateToolState.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getReferencedFrameOfReferenceSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getReferencedSeriesSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getStructureSetModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/RTSS.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getRTROIObservationsSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getPatientModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/utilities/getRTSeriesModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/RTStruct/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/KeyImage.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/Cornerstone3D/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/VTKjs/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/VTKjs/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/index.js","webpack:///../../../node_modules/@cornerstonejs/adapters/dist/esm/adapters/helpers/downloadDICOMData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js","webpack:///../../../node_modules/iota-array/iota.js","webpack:///../../../node_modules/is-buffer/index.js","webpack:///../../../node_modules/ndarray/ndarray.js"],"sourcesContent":["const toArray = x => Array.isArray(x) ? x : x !== undefined ? [x] : [];\n\nexport { toArray };\n","const codeMeaningEquals = codeMeaningName => {\n  return contentItem => {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n\nexport { codeMeaningEquals };\n","import { utilities, derivations, normalizers, data } from 'dcmjs';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\nimport '@cornerstonejs/core';\n\nconst {\n  TID1500,\n  addAccessors\n} = utilities;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nconst codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\nfunction getTID300ContentItem(tool, ReferencedSOPSequence, adapterClass) {\n  const args = adapterClass.getTID300RepresentationArguments(tool);\n  args.ReferencedSOPSequence = ReferencedSOPSequence;\n  args.ReferencedFrameOfReferenceUID = args.use3DSpatialCoordinates ? tool.metadata.FrameOfReferenceUID : null;\n  const tid300Measurement = new adapterClass.TID300Representation(args);\n  return tid300Measurement;\n}\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n  const toolTypeData = toolData[toolType];\n  const toolClass = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n  if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n    return;\n  }\n\n  // Loop through the array of tool instances\n  // for this tool\n  const measurements = toolTypeData.data.map(tool => {\n    return getTID300ContentItem(tool, ReferencedSOPSequence, toolClass);\n  });\n  return new TID1501MeasurementGroup(measurements);\n}\nclass MeasurementReport {\n  static getSetupMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => codeValueMatch(group, FINDING));\n    const findingSiteGroups = contentSequenceArr.filter(group => codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\");\n    const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n    const defaultState = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      complete: true,\n      finding: findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined,\n      findingSites: findingSiteGroups.map(fsg => {\n        return addAccessors(fsg.ConceptCodeSequence);\n      })\n    };\n    if (defaultState.finding) {\n      defaultState.description = defaultState.finding.CodeMeaning;\n    }\n    const findingSite = defaultState.findingSites && defaultState.findingSites[0];\n    if (findingSite) {\n      defaultState.location = findingSite[0] && findingSite[0].CodeMeaning || findingSite.CodeMeaning;\n    }\n    return {\n      defaultState,\n      findingGroup,\n      findingSiteGroups,\n      NUMGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    };\n  }\n  static generateReport(toolState, metadataProvider, options) {\n    // ToolState for array of imageIDs to a Report\n    // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n    let allMeasurementGroups = [];\n    const firstImageId = Object.keys(toolState)[0];\n    if (!firstImageId) {\n      throw new Error(\"No measurements provided.\");\n    }\n\n    /* Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n    Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n     */\n    const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", firstImageId);\n\n    //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n    // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n    // which means that if the toolState is for multiple series, the report will have the incorrect\n    // SeriesInstanceUIDs\n    const {\n      studyInstanceUID,\n      seriesInstanceUID\n    } = generalSeriesModule;\n\n    // Loop through each image in the toolData\n    Object.keys(toolState).forEach(imageId => {\n      const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n      const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const ReferencedSOPSequence = {\n        ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n      };\n      if (Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)) {\n        ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n      }\n\n      // Loop through each tool type for the image\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = getMeasurementGroup(toolType, toolData, ReferencedSOPSequence);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const tid1500MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n\n    // TODO: what is the correct metaheader\n    // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n    // TODO: move meta creation to happen in derivations.js\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const derivationSourceDataset = {\n      StudyInstanceUID: studyInstanceUID,\n      SeriesInstanceUID: seriesInstanceUID\n      //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n      //SOPClassUID: sopClassUID,\n    };\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      //MediaStorageSOPClassUID\n      //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        // TODO: could be git hash or other valid id\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    const _vrMap = {\n      PixelData: \"OW\"\n    };\n    derivationSourceDataset._meta = _meta;\n    derivationSourceDataset._vrMap = _vrMap;\n    const report = new StructuredReport([derivationSourceDataset]);\n    const contentItem = tid1500MeasurementReport.contentItem(derivationSourceDataset);\n\n    // Merge the derived dataset with the content from the Measurement Report\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    return report;\n  }\n\n  /**\n   * Generate Cornerstone tool state from dataset\n   * @param {object} dataset dataset\n   * @param {object} hooks\n   * @param {function} hooks.getToolClass Function to map dataset to a tool class\n   * @returns\n   */\n  static generateToolState(dataset) {\n    let hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // For now, bail out if the dataset is not a TID1500 SR with length measurements\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n    // Identify the Imaging Measurements\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n\n    // Retrieve the Measurements themselves\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n\n    // For each of the supported measurement types, compute the measurement data\n    const measurementData = {};\n    const cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n    const registeredToolClasses = [];\n    Object.keys(cornerstoneToolClasses).forEach(key => {\n      registeredToolClasses.push(cornerstoneToolClasses[key]);\n      measurementData[key] = [];\n    });\n    measurementGroups.forEach(measurementGroup => {\n      const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n      const TrackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n      const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n      const toolClass = hooks.getToolClass ? hooks.getToolClass(measurementGroup, dataset, registeredToolClasses) : registeredToolClasses.find(tc => tc.isValidCornerstoneTrackingIdentifier(TrackingIdentifierValue));\n      if (toolClass) {\n        const measurement = toolClass.getMeasurementData(measurementGroup);\n        console.log(`=== ${toolClass.toolType} ===`);\n        console.log(measurement);\n        measurementData[toolClass.toolType].push(measurement);\n      }\n    });\n\n    // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n    // That is up to the consumer to derive from the SOPInstanceUIDs.\n    return measurementData;\n  }\n  static registerTool(toolClass) {\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[toolClass.utilityToolType] = toolClass;\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolClass.toolType] = toolClass;\n    MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] = toolClass.utilityToolType;\n  }\n}\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\nexport { MeasurementReport as default };\n","var CORNERSTONE_4_TAG = \"cornerstoneTools@^4.0.0\";\n\nexport { CORNERSTONE_4_TAG as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      length: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Length.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const distance = tool.length;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === LENGTH;\n};\nMeasurementReport.registerTool(Length);\n\nexport { Length as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass FreehandRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: FreehandRoi.toolType,\n      handles: {\n        points: [],\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      state.handles.points.push({\n        x: GraphicData[i],\n        y: GraphicData[i + 1]\n      });\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites,\n      cachedStats = {}\n    } = tool;\n    const {\n      points\n    } = handles;\n    const {\n      area = 0,\n      perimeter = 0\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:FreehandRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === FreehandRoi.toolType;\n};\nMeasurementReport.registerTool(FreehandRoi);\n\nexport { FreehandRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\nimport '@cornerstonejs/core';\n\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\nclass Bidirectional {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const findingGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeValue === FINDING);\n    const findingSiteGroups = toArray(ContentSequence).filter(group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE);\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD\");\n    const {\n      ReferencedSOPSequence\n    } = longAxisSCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber\n    } = ReferencedSOPSequence;\n\n    // Long axis\n\n    const longestDiameter = String(longAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const shortestDiameter = String(shortAxisNUMGroup.MeasuredValueSequence.NumericValue);\n    const bottomRight = {\n      x: Math.max(longAxisSCOORDGroup.GraphicData[0], longAxisSCOORDGroup.GraphicData[2], shortAxisSCOORDGroup.GraphicData[0], shortAxisSCOORDGroup.GraphicData[2]),\n      y: Math.max(longAxisSCOORDGroup.GraphicData[1], longAxisSCOORDGroup.GraphicData[3], shortAxisSCOORDGroup.GraphicData[1], shortAxisSCOORDGroup.GraphicData[3])\n    };\n    const state = {\n      sopInstanceUid: ReferencedSOPInstanceUID,\n      frameIndex: ReferencedFrameNumber || 1,\n      toolType: Bidirectional.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: longAxisSCOORDGroup.GraphicData[0],\n          y: longAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 0\n        },\n        end: {\n          x: longAxisSCOORDGroup.GraphicData[2],\n          y: longAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 1\n        },\n        perpendicularStart: {\n          x: shortAxisSCOORDGroup.GraphicData[0],\n          y: shortAxisSCOORDGroup.GraphicData[1],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 2\n        },\n        perpendicularEnd: {\n          x: shortAxisSCOORDGroup.GraphicData[2],\n          y: shortAxisSCOORDGroup.GraphicData[3],\n          drawnIndependently: false,\n          allowedOutsideImage: false,\n          active: false,\n          highlight: false,\n          index: 3\n        },\n        textBox: {\n          highlight: false,\n          hasMoved: true,\n          active: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true,\n          x: bottomRight.x + 10,\n          y: bottomRight.y + 10\n        }\n      },\n      invalidated: false,\n      isCreating: false,\n      longestDiameter,\n      shortestDiameter,\n      toolName: \"Bidirectional\",\n      visible: true,\n      finding: findingGroup ? findingGroup.ConceptCodeSequence : undefined,\n      findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      start,\n      end,\n      perpendicularStart,\n      perpendicularEnd\n    } = tool.handles;\n    const {\n      shortestDiameter,\n      longestDiameter,\n      finding,\n      findingSites\n    } = tool;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Bidirectional\";\n    return {\n      longAxis: {\n        point1: start,\n        point2: end\n      },\n      shortAxis: {\n        point1: perpendicularStart,\n        point2: perpendicularEnd\n      },\n      longAxisLength: longestDiameter,\n      shortAxisLength: shortestDiameter,\n      trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === BIDIRECTIONAL;\n};\nMeasurementReport.registerTool(Bidirectional);\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nconst ELLIPTICALROI = \"EllipticalRoi\";\nclass EllipticalRoi {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const majorAxis = [{\n      x: GraphicData[0],\n      y: GraphicData[1]\n    }, {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    }];\n    const minorAxis = [{\n      x: GraphicData[4],\n      y: GraphicData[5]\n    }, {\n      x: GraphicData[6],\n      y: GraphicData[7]\n    }];\n\n    // Calculate two opposite corners of box defined by two axes.\n\n    const minorAxisLength = Math.sqrt(Math.pow(minorAxis[0].x - minorAxis[1].x, 2) + Math.pow(minorAxis[0].y - minorAxis[1].y, 2));\n    const minorAxisDirection = {\n      x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n      y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n    };\n    const halfMinorAxisLength = minorAxisLength / 2;\n\n    // First end point of major axis + half minor axis vector\n    const corner1 = {\n      x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n    };\n\n    // Second end point of major axis - half of minor axis vector\n    const corner2 = {\n      x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n      y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n    };\n    const state = {\n      ...defaultState,\n      toolType: EllipticalRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      handles: {\n        end: {\n          x: corner1.x,\n          y: corner1.y,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          x: corner2.x,\n          y: corner2.y,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const {\n      area\n    } = cachedStats;\n    const halfXLength = Math.abs(start.x - end.x) / 2;\n    const halfYLength = Math.abs(start.y - end.y) / 2;\n    const points = [];\n    const center = {\n      x: (start.x + end.x) / 2,\n      y: (start.y + end.y) / 2\n    };\n    if (halfXLength > halfYLength) {\n      // X-axis major\n      // Major axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n      // Minor axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n    } else {\n      // Y-axis major\n      // Major axis\n      points.push({\n        x: center.x,\n        y: center.y - halfYLength\n      });\n      points.push({\n        x: center.x,\n        y: center.y + halfYLength\n      });\n      // Minor axis\n      points.push({\n        x: center.x - halfXLength,\n        y: center.y\n      });\n      points.push({\n        x: center.x + halfXLength,\n        y: center.y\n      });\n    }\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n    return {\n      area,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ELLIPTICALROI;\n};\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport { EllipticalRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nconst CIRCLEROI = \"CircleRoi\";\nclass CircleRoi {\n  /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const center = {\n      x: GraphicData[0],\n      y: GraphicData[1]\n    };\n    const end = {\n      x: GraphicData[2],\n      y: GraphicData[3]\n    };\n    const state = {\n      ...defaultState,\n      toolType: CircleRoi.toolType,\n      active: false,\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n        // Dummy values to be updated by cornerstone\n        radius: 0,\n        perimeter: 0\n      },\n      handles: {\n        end: {\n          ...end,\n          highlight: false,\n          active: false\n        },\n        initialRotation: 0,\n        start: {\n          ...center,\n          highlight: false,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n\n  /**\n   * Gets the TID 300 representation of a circle, given the cornerstone representation.\n   *\n   * @param {Object} tool\n   * @returns\n   */\n  static getTID300RepresentationArguments(tool) {\n    const {\n      cachedStats = {},\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const {\n      start: center,\n      end\n    } = handles;\n    const {\n      area,\n      radius\n    } = cachedStats;\n    const perimeter = 2 * Math.PI * radius;\n    const points = [];\n    points.push(center);\n    points.push(end);\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n    return {\n      area,\n      perimeter,\n      radius,\n      points,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === CIRCLEROI;\n};\nMeasurementReport.registerTool(CircleRoi);\n\nexport { CircleRoi as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\nclass ArrowAnnotate {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      findingGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const {\n      GraphicData\n    } = SCOORDGroup;\n    const state = {\n      ...defaultState,\n      toolType: ArrowAnnotate.toolType,\n      active: false,\n      handles: {\n        start: {\n          x: GraphicData[0],\n          y: GraphicData[1],\n          highlight: true,\n          active: false\n        },\n        // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n        // use the actual endpoint.\n        end: {\n          x: GraphicData.length == 4 ? GraphicData[2] : GraphicData[0] + 20,\n          y: GraphicData.length == 4 ? GraphicData[3] : GraphicData[1] + 20,\n          highlight: true,\n          active: false\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      },\n      invalidated: true,\n      visible: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const points = [tool.handles.start, tool.handles.end];\n    const {\n      findingSites\n    } = tool;\n    let {\n      finding\n    } = tool;\n    const TID300RepresentationArguments = {\n      points,\n      trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n      findingSites: findingSites || []\n    };\n\n    // If freetext finding isn't present, add it from the tool label.\n    if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n      finding = {\n        CodeValue: CORNERSTONEFREETEXT,\n        CodingSchemeDesignator: \"CST4\",\n        CodeMeaning: tool.label\n      };\n    }\n    TID300RepresentationArguments.finding = finding;\n    return TID300RepresentationArguments;\n  }\n}\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ARROW_ANNOTATE;\n};\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nconst COBB_ANGLE = \"CobbAngle\";\nclass CobbAngle {\n  // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: CobbAngle.toolType,\n      handles: {\n        start: {},\n        end: {},\n        start2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        end2: {\n          highlight: true,\n          drawnIndependently: true\n        },\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.end.x, state.handles.end.y, state.handles.start2.x, state.handles.start2.y, state.handles.end2.x, state.handles.end2.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.end;\n    const point3 = handles.start2;\n    const point4 = handles.end2;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === COBB_ANGLE;\n};\nMeasurementReport.registerTool(CobbAngle);\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Angle: TID300Angle\n} = utilities.TID300;\nconst ANGLE = \"Angle\";\nclass Angle {\n  /**\n   * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n   */\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      NUMGroup,\n      SCOORDGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n      toolType: Angle.toolType,\n      handles: {\n        start: {},\n        middle: {},\n        end: {},\n        textBox: {\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        }\n      }\n    };\n    [state.handles.start.x, state.handles.start.y, state.handles.middle.x, state.handles.middle.y, state.handles.middle.x, state.handles.middle.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      handles,\n      finding,\n      findingSites\n    } = tool;\n    const point1 = handles.start;\n    const point2 = handles.middle;\n    const point3 = handles.middle;\n    const point4 = handles.end;\n    const rAngle = tool.rAngle;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ANGLE;\n};\nMeasurementReport.registerTool(Angle);\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport CORNERSTONE_4_TAG from './cornerstone4Tag.js';\n\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleRoi {\n  static getMeasurementData(MeasurementGroup) {\n    const {\n      defaultState,\n      SCOORDGroup,\n      NUMGroup\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n    const state = {\n      ...defaultState,\n      toolType: RectangleRoi.toolType,\n      handles: {\n        start: {},\n        end: {},\n        textBox: {\n          active: false,\n          hasMoved: false,\n          movesIndependently: false,\n          drawnIndependently: true,\n          allowedOutsideImage: true,\n          hasBoundingBox: true\n        },\n        initialRotation: 0\n      },\n      cachedStats: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      },\n      color: undefined,\n      invalidated: true\n    };\n    const intermediate = {};\n    [state.handles.start.x, state.handles.start.y, intermediate.x, intermediate.y, state.handles.end.x, state.handles.end.y] = SCOORDGroup.GraphicData;\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const {\n      finding,\n      findingSites,\n      cachedStats = {},\n      handles\n    } = tool;\n    const {\n      start,\n      end\n    } = handles;\n    const points = [start, {\n      x: start.x,\n      y: end.y\n    }, end, {\n      x: end.x,\n      y: start.y\n    }];\n    const {\n      area,\n      perimeter\n    } = cachedStats;\n    const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:RectangleRoi\";\n    return {\n      points,\n      area,\n      perimeter,\n      trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === RectangleRoi.toolType;\n};\nMeasurementReport.registerTool(RectangleRoi);\n\nexport { RectangleRoi as default };\n","import { data, normalizers } from 'dcmjs';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nfunction getDatasetsFromImages(images, isMultiframe, options) {\n  const datasets = [];\n  if (isMultiframe) {\n    const image = images[0];\n    const arrayBuffer = image.data.byteArray.buffer;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    datasets.push(dataset);\n  } else {\n    for (let i = 0; i < images.length; i++) {\n      const image = images[i];\n      const arrayBuffer = image.data.byteArray.buffer;\n      const dicomData = DicomMessage.readFile(arrayBuffer);\n      const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n      dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n      datasets.push(dataset);\n    }\n  }\n  if (options?.SpecificCharacterSet) {\n    datasets.forEach(dataset => dataset.SpecificCharacterSet = options.SpecificCharacterSet);\n  }\n  return Normalizer.normalizeToDataset(datasets);\n}\n\nexport { getDatasetsFromImages as default };\n","import { utilities, log, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  datasetToBlob,\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = utilities;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState\n};\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(images, brushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  const {\n    toolState,\n    segments\n  } = brushData;\n\n  // Calculate the dimensions of the data cube.\n  const image0 = images[0];\n  const dims = {\n    x: image0.columns,\n    y: image0.rows,\n    z: images.length\n  };\n  dims.xy = dims.x * dims.y;\n  const numSegments = _getSegCount(seg, segments);\n  if (!numSegments) {\n    throw new Error(\"No segments to export!\");\n  }\n  const isMultiframe = image0.imageId.includes(\"?frame\");\n  const seg = _createSegFromImages(images, isMultiframe, options);\n  const {\n    referencedFramesPerSegment,\n    segmentIndicies\n  } = _getNumberOfFramesPerSegment(toolState, images, segments);\n  let NumberOfFrames = 0;\n  for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n    NumberOfFrames += referencedFramesPerSegment[i].length;\n  }\n  seg.setNumberOfFrames(NumberOfFrames);\n  for (let i = 0; i < segmentIndicies.length; i++) {\n    const segmentIndex = segmentIndicies[i];\n    const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n    // Frame numbers start from 1.\n    const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n      return element + 1;\n    });\n    const segment = segments[segmentIndex];\n    seg.addSegment(segment, _extractCornerstoneToolsPixelData(segmentIndex, referencedFrameIndicies, toolState, images, dims), referencedFrameNumbers);\n  }\n  seg.bitPackPixelData();\n  const segBlob = datasetToBlob(seg.dataset);\n  return segBlob;\n}\nfunction _extractCornerstoneToolsPixelData(segmentIndex, referencedFrames, toolState, images, dims) {\n  const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n  let pixelDataIndex = 0;\n  for (let i = 0; i < referencedFrames.length; i++) {\n    const frame = referencedFrames[i];\n    const imageId = images[frame].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    const brushPixelData = imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n    for (let p = 0; p < brushPixelData.length; p++) {\n      pixelData[pixelDataIndex] = brushPixelData[p];\n      pixelDataIndex++;\n    }\n  }\n  return pixelData;\n}\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n  const segmentIndicies = [];\n  const referencedFramesPerSegment = [];\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      segmentIndicies.push(i);\n      referencedFramesPerSegment.push([]);\n    }\n  }\n  for (let z = 0; z < images.length; z++) {\n    const imageId = images[z].imageId;\n    const imageIdSpecificToolState = toolState[imageId];\n    for (let i = 0; i < segmentIndicies.length; i++) {\n      const segIdx = segmentIndicies[i];\n      if (imageIdSpecificToolState && imageIdSpecificToolState.brush && imageIdSpecificToolState.brush.data && imageIdSpecificToolState.brush.data[segIdx] && imageIdSpecificToolState.brush.data[segIdx].pixelData) {\n        referencedFramesPerSegment[i].push(z);\n      }\n    }\n  }\n  return {\n    referencedFramesPerSegment,\n    segmentIndicies\n  };\n}\nfunction _getSegCount(seg, segments) {\n  let numSegments = 0;\n  for (let i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      numSegments++;\n    }\n  }\n  return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe);\n  const pixelData = unpackPixelData(multiframe);\n  const PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence;\n  const toolState = {};\n  let inPlane = true;\n  for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n    const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n    const pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength), [multiframe.Rows, multiframe.Columns]);\n    const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations);\n    if (!alignedPixelDataI) {\n      console.warn(\"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \");\n      inPlane = false;\n      break;\n    }\n    const segmentIndex = PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber - 1;\n    let SourceImageSequence;\n    if (SharedFunctionalGroupsSequence.DerivationImageSequence && SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence) {\n      SourceImageSequence = SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence[i];\n    } else {\n      SourceImageSequence = PerFrameFunctionalGroups.DerivationImageSequence.SourceImageSequence;\n    }\n    const imageId = getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider);\n    addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, alignedPixelDataI);\n  }\n  if (!inPlane) {\n    return;\n  }\n  return {\n    toolState,\n    segMetadata\n  };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n  const segType = multiframe.SegmentationType;\n  if (segType === \"BINARY\") {\n    return BitArray.unpack(multiframe.PixelData);\n  }\n  const pixelData = new Uint8Array(multiframe.PixelData);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    log.warn(\"This is a fractional segmentation, which is not currently supported.\");\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, pixelData2D) {\n  if (!toolState[imageId]) {\n    toolState[imageId] = {};\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush) {\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush.data) {\n    toolState[imageId].brush.data = [];\n  }\n  toolState[imageId].brush.data[segmentIndex] = {};\n  const brushDataI = toolState[imageId].brush.data[segmentIndex];\n  brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n  const cToolsPixelData = brushDataI.pixelData;\n  for (let p = 0; p < cToolsPixelData.length; p++) {\n    if (pixelData2D.data[p]) {\n      cToolsPixelData[p] = 1;\n    } else {\n      cToolsPixelData[p] = 0;\n    }\n  }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, imageIds, metadataProvider) : getImageIdOfReferencedSingleFramedSOPInstance(ReferencedSOPInstanceUID, imageIds, metadataProvider);\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(sopInstanceUid, imageIds, metadataProvider) {\n  return imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    return sopCommonModule.sopInstanceUID === sopInstanceUid;\n  });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, imageIds, metadataProvider) {\n  const imageId = imageIds.find(imageId => {\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n    return (\n      //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n      sopCommonModule.sopInstanceUID === sopInstanceUid && imageIdFrameNumber === frameNumber - 1\n    );\n  });\n  return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n  if (compareIOP(iop, orientations[0])) {\n    //Same orientation.\n    return pixelData2D;\n  } else if (compareIOP(iop, orientations[1])) {\n    //Flipped vertically.\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareIOP(iop, orientations[2])) {\n    //Flipped horizontally.\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareIOP(iop, orientations[3])) {\n    //Rotated 90 degrees.\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareIOP(iop, orientations[4])) {\n    //Rotated 90 degrees and fliped horizontally.\n    return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[5])) {\n    //Rotated 90 degrees and fliped vertically.\n    return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[6])) {\n    //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareIOP(iop, orientations[7])) {\n    //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n  return Math.abs(iop1[0] - iop2[0]) < dx && Math.abs(iop1[1] - iop2[1]) < dx && Math.abs(iop1[2] - iop2[2]) < dx && Math.abs(iop1[3] - iop2[3]) < dx && Math.abs(iop1[4] - iop2[4]) < dx && Math.abs(iop1[5] - iop2[5]) < dx;\n}\nfunction getSegmentMetadata(multiframe) {\n  const data = [];\n  const segmentSequence = multiframe.SegmentSequence;\n  if (Array.isArray(segmentSequence)) {\n    for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n      data.push(segmentSequence[segIdx]);\n    }\n  } else {\n    // Only one segment, will be stored as an object.\n    data.push(segmentSequence);\n  }\n  return {\n    seriesInstanceUid: multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n    data\n  };\n}\n\nexport { Segmentation as default };\n","import checkIfPerpendicular from './checkIfPerpendicular.js';\nimport { utilities } from '@cornerstonejs/core';\n\nfunction checkOrientation(multiframe, validOrientations, sourceDataDimensions, tolerance) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n  const iop = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const inPlane = validOrientations.some(operation => utilities.isEqual(iop, operation, tolerance));\n  if (inPlane) {\n    return \"Planar\";\n  }\n  if (checkIfPerpendicular(iop, validOrientations[0], tolerance) && sourceDataDimensions.includes(multiframe.Rows) && sourceDataDimensions.includes(multiframe.Columns)) {\n    return \"Perpendicular\";\n  }\n  return \"Oblique\";\n}\n\nexport { checkOrientation as default };\n","function checkIfPerpendicular(iop1, iop2, tolerance) {\n  const absDotColumnCosines = Math.abs(iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]);\n  const absDotRowCosines = Math.abs(iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]);\n  return (absDotColumnCosines < tolerance || Math.abs(absDotColumnCosines - 1) < tolerance) && (absDotRowCosines < tolerance || Math.abs(absDotRowCosines - 1) < tolerance);\n}\n\nexport { checkIfPerpendicular as default };\n","var Events;\n(function (Events) {\n  Events[\"SEGMENTATION_LOAD_PROGRESS\"] = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\";\n})(Events || (Events = {}));\n\nexport { Events };\n","import { utilities, log, data, normalizers, derivations } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport getDatasetsFromImages from '../helpers/getDatasetsFromImages.js';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport { utilities as utilities$1 } from '@cornerstonejs/core';\nimport { Events } from '../enums/Events.js';\n\nconst {\n  rotateDirectionCosinesInPlane,\n  flipImageOrientationPatient: flipIOP,\n  flipMatrix2D,\n  rotateMatrix902D\n} = utilities.orientation;\nconst {\n  BitArray,\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nconst {\n  encode,\n  decode\n} = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n  includeSliceSpacing: true,\n  rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const isMultiframe = isMultiframeImage(images[0]);\n  const segmentation = _createSegFromImages(images, isMultiframe, userOptions);\n  return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * Fills a given segmentation object with data from the input labelmaps3D\n *\n * @param segmentation - The segmentation object to be filled.\n * @param inputLabelmaps3D - An array of 3D labelmaps, or a single 3D labelmap.\n * @param userOptions - Optional configuration settings. Will override the default options.\n *\n * @returns {object} The filled segmentation object.\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = Object.assign({}, generateSegmentationDefaultOptions, userOptions);\n\n  // Use another variable so we don't redefine labelmaps3D.\n  const labelmaps3D = Array.isArray(inputLabelmaps3D) ? inputLabelmaps3D : [inputLabelmaps3D];\n  let numberOfFrames = 0;\n  const referencedFramesPerLabelmap = [];\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      labelmaps2D,\n      metadata\n    } = labelmap3D;\n    const referencedFramesPerSegment = [];\n    for (let i = 1; i < metadata.length; i++) {\n      if (metadata[i]) {\n        referencedFramesPerSegment[i] = [];\n      }\n    }\n    for (let i = 0; i < labelmaps2D.length; i++) {\n      const labelmap2D = labelmaps2D[i];\n      if (labelmaps2D[i]) {\n        const {\n          segmentsOnLabelmap\n        } = labelmap2D;\n        segmentsOnLabelmap.forEach(segmentIndex => {\n          if (segmentIndex !== 0) {\n            referencedFramesPerSegment[segmentIndex].push(i);\n            numberOfFrames++;\n          }\n        });\n      }\n    }\n    referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n  }\n  segmentation.setNumberOfFrames(numberOfFrames);\n  for (let labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    const referencedFramesPerSegment = referencedFramesPerLabelmap[labelmapIndex];\n    const labelmap3D = labelmaps3D[labelmapIndex];\n    const {\n      metadata\n    } = labelmap3D;\n    for (let segmentIndex = 1; segmentIndex < referencedFramesPerSegment.length; segmentIndex++) {\n      const referencedFrameIndicies = referencedFramesPerSegment[segmentIndex];\n      if (referencedFrameIndicies) {\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n          return element + 1;\n        });\n        const segmentMetadata = metadata[segmentIndex];\n        const labelmaps = _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies);\n        segmentation.addSegmentFromLabelmap(segmentMetadata, labelmaps, segmentIndex, referencedFrameNumbers);\n      }\n    }\n  }\n  if (options.rleEncode) {\n    const rleEncodedFrames = encode(segmentation.dataset.PixelData, numberOfFrames, segmentation.dataset.Rows, segmentation.dataset.Columns);\n\n    // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n    // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n    // added to the standard.\n    segmentation.assignToDataset({\n      BitsAllocated: \"8\",\n      BitsStored: \"8\",\n      HighBit: \"7\",\n      SegmentationType: \"FRACTIONAL\",\n      SegmentationFractionalType: \"PROBABILITY\",\n      MaximumFractionalValue: \"255\"\n    });\n    segmentation.dataset._meta.TransferSyntaxUID = {\n      Value: [\"1.2.840.10008.1.2.5\"],\n      vr: \"UI\"\n    };\n    segmentation.dataset.SpecificCharacterSet = \"ISO_IR 192\";\n    segmentation.dataset._vrMap.PixelData = \"OB\";\n    segmentation.dataset.PixelData = rleEncodedFrames;\n  } else {\n    // If no rleEncoding, at least bitpack the data.\n    segmentation.bitPackPixelData();\n  }\n  return segmentation;\n}\nfunction _getLabelmapsFromReferencedFrameIndicies(labelmap3D, referencedFrameIndicies) {\n  const {\n    labelmaps2D\n  } = labelmap3D;\n  const labelmaps = [];\n  for (let i = 0; i < referencedFrameIndicies.length; i++) {\n    const frame = referencedFrameIndicies[i];\n    labelmaps.push(labelmaps2D[frame].pixelData);\n  }\n  return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  const multiframe = getDatasetsFromImages(images, isMultiframe);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} referencedImageIds - An array for referenced image imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000,\n    eventTarget = null,\n    triggerEvent = null\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const sliceLength = multiframe.Columns * multiframe.Rows;\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bitbacking.\");\n      return;\n    }\n\n    // Todo: need to test this with rle data\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n\n  // Pre-compute the sop UID to imageId index map so that in the for loop\n  // we don't have to call metadataProvider.get() for each imageId over\n  // and over again.\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let overlapping = false;\n  if (!skipOverlapping) {\n    overlapping = checkSEGsOverlapping(pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap);\n  }\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      if (overlapping) {\n        insertFunction = insertOverlappingPixelDataPlanar;\n      } else {\n        insertFunction = insertPixelDataPlanar;\n      }\n      break;\n    case \"Perpendicular\":\n      //insertFunction = insertPixelDataPerpendicular;\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n\n  /* if SEGs are overlapping:\n  1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n  2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n  3) insertFunction will return the number of LabelMaps\n  4) generateToolState return is an array*/\n\n  const segmentsOnFrameArray = [];\n  segmentsOnFrameArray[0] = [];\n  const segmentsOnFrame = [];\n  const arrayBufferLength = sliceLength * referencedImageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  const labelmapBufferArray = [];\n  labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n  // Pre-compute the indices and metadata so that we don't have to call\n  // a function for each imageId in the for loop.\n  const imageIdMaps = referencedImageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n\n  // This is the centroid calculation for each segment Index, the data structure\n  // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n  // later on we will use this data structure to calculate the centroid of the\n  // segment in the labelmapBuffer\n  const segmentsPixelIndices = new Map();\n  const overlappingSegments = await insertFunction(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelDataChunks, multiframe, referencedImageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent);\n\n  // calculate the centroid of each segment\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelmapBufferArray,\n    segMetadata,\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    centroids: centroidXYZ,\n    overlappingSegments\n  };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    SegmentSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  let numberOfSegs = SegmentSequence.length;\n  if (numberOfSegs < 2) {\n    return false;\n  }\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n  /** sort groupsLen to have all the segments for each frame in an array\n   * frame 2 : 1, 2\n   * frame 4 : 1, 3\n   * frame 5 : 4\n   */\n\n  let frameSegmentsMapping = new Map();\n  for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n    const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n    if (segmentIndex === undefined) {\n      console.warn(\"Could not retrieve the segment index for frame segment \" + frameSegment + \", skipping this frame.\");\n      continue;\n    }\n    const imageId = findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + frameSegment + \".\");\n      continue;\n    }\n    const imageIdIndex = imageIds.findIndex(element => element === imageId);\n    if (frameSegmentsMapping.has(imageIdIndex)) {\n      let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n      if (!segmentArray.includes(frameSegment)) {\n        segmentArray.push(frameSegment);\n        frameSegmentsMapping.set(imageIdIndex, segmentArray);\n      }\n    } else {\n      frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n    }\n  }\n  for (let [, role] of frameSegmentsMapping.entries()) {\n    let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n    for (let i = 0; i < role.length; ++i) {\n      const frameSegment = role[i];\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frameSegment];\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n      const view = readFromUnpackedChunks(pixelData, frameSegment * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        console.warn(\"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\");\n        continue;\n      }\n      const data = alignedPixelDataI.data;\n      for (let j = 0, len = data.length; j < len; ++j) {\n        if (data[j] !== 0) {\n          temp2DArray[j]++;\n          if (temp2DArray[j] > 1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction insertOverlappingPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayBufferLength = sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n  // indicate the number of labelMaps\n  let M = 1;\n\n  // indicate the current labelMap array index;\n  let m = 0;\n\n  // temp array for checking overlaps\n  let tempBuffer = labelmapBufferArray[m].slice(0);\n\n  // temp list for checking overlaps\n  let tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n\n  /** split overlapping SEGs algorithm for each segment:\n   *  A) copy the labelmapBuffer in the array with index 0\n   *  B) add the segment pixel per pixel on the copied buffer from (A)\n   *  C) if no overlap, copy the results back on the orignal array from (A)\n   *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n   */\n\n  let numberOfSegs = multiframe.SegmentSequence.length;\n  for (let segmentIndexToProcess = 1; segmentIndexToProcess <= numberOfSegs; ++segmentIndexToProcess) {\n    for (let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length; i < groupsLen; ++i) {\n      const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n      const segmentIndex = getSegmentIndex(multiframe, i);\n      if (segmentIndex === undefined) {\n        throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n      }\n      if (segmentIndex !== segmentIndexToProcess) {\n        continue;\n      }\n      const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n\n      // Since we moved to the chunks approach, we need to read the data\n      // and handle scenarios where the portion of data is in one chunk\n      // and the other portion is in another chunk\n      const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n      const pixelDataI2D = ndarray(view, [Rows, Columns]);\n      const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n      }\n      const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n      if (!imageId) {\n        console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n        continue;\n      }\n      const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n      if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n        throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n      }\n      const imageIdIndex = imageIds.findIndex(element => element === imageId);\n      const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n      const labelmap2DView = new TypedArrayConstructor(tempBuffer, byteOffset, sliceLength);\n      const data = alignedPixelDataI.data;\n      let segmentOnFrame = false;\n      for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n        if (data[j]) {\n          if (labelmap2DView[j] !== 0) {\n            m++;\n            if (m >= M) {\n              labelmapBufferArray[m] = new ArrayBuffer(arrayBufferLength);\n              segmentsOnFrameArray[m] = [];\n              M++;\n            }\n            tempBuffer = labelmapBufferArray[m].slice(0);\n            tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n            i = 0;\n            break;\n          } else {\n            labelmap2DView[j] = segmentIndex;\n            segmentOnFrame = true;\n          }\n        }\n      }\n      if (segmentOnFrame) {\n        if (!tempSegmentsOnFrame[imageIdIndex]) {\n          tempSegmentsOnFrame[imageIdIndex] = [];\n        }\n        tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n        if (!segmentsOnFrame[imageIdIndex]) {\n          segmentsOnFrame[imageIdIndex] = [];\n        }\n        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n      }\n    }\n    labelmapBufferArray[m] = tempBuffer.slice(0);\n    segmentsOnFrameArray[m] = structuredClone(tempSegmentsOnFrame);\n\n    // reset temp variables/buffers for new segment\n    m = 0;\n    tempBuffer = labelmapBufferArray[m].slice(0);\n    tempSegmentsOnFrame = structuredClone(segmentsOnFrameArray[m]);\n  }\n}\nconst getSegmentIndex = (multiframe, frame) => {\n  const {\n    PerFrameFunctionalGroupsSequence,\n    SharedFunctionalGroupsSequence\n  } = multiframe;\n  const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n  return PerFrameFunctionalGroups && PerFrameFunctionalGroups.SegmentIdentificationSequence ? PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber : SharedFunctionalGroupsSequence.SegmentIdentificationSequence ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence.ReferencedSegmentNumber : undefined;\n};\nfunction insertPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance, TypedArrayConstructor, segmentsPixelIndices, sopUIDImageIdIndexMap, imageIdMaps, eventTarget, triggerEvent) {\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  let i = 0;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n  const shouldTriggerEvent = triggerEvent && eventTarget;\n  let overlapping = false;\n  // Below, we chunk the processing of the frames to avoid blocking the main thread\n  // if the segmentation is large. We also use a promise to allow the caller to\n  // wait for the processing to finish.\n  return new Promise(resolve => {\n    function processInChunks() {\n      // process one chunk\n      for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelData, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          continue;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const byteOffset = sliceLength * imageIdIndex * TypedArrayConstructor.BYTES_PER_ELEMENT;\n        const labelmap2DView = new TypedArrayConstructor(labelmapBufferArray[0], byteOffset, sliceLength);\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n          if (data[j]) {\n            for (let x = j; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                }\n                labelmap2DView[x] = segmentIndex;\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n\n      // trigger an event after each chunk\n      if (shouldTriggerEvent) {\n        const percentComplete = Math.round(i / groupsLen * 100);\n        triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n          percentComplete\n        });\n      }\n\n      // schedule next chunk\n      if (i < groupsLen) {\n        setTimeout(processInChunks, 0);\n      } else {\n        // resolve the Promise when all chunks have been processed\n        resolve(overlapping);\n      }\n    }\n    processInChunks();\n  });\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n  const segType = multiframe.SegmentationType;\n  let data;\n  if (Array.isArray(multiframe.PixelData)) {\n    data = multiframe.PixelData[0];\n  } else {\n    data = multiframe.PixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This segmentation pixelData is undefined.\");\n  }\n  if (segType === \"BINARY\") {\n    // For extreme big data, we can't unpack the data at once and we need to\n    // chunk it and unpack each chunk separately.\n    // MAX 2GB is the limit right now to allocate a buffer\n    return getUnpackedChunks(data, options.maxBytesPerChunk);\n  }\n  if (segType === \"LABELMAP\") {\n    // For LABELMAP, we can return the data as is, since it is already in a\n    // format that Cornerstone can handle. Also here we are returning the\n    // whole data at once, since the storage is more efficent than BINARY mode\n    if (multiframe.BitsStored === 8) {\n      return new Uint8Array(data);\n    } else if (multiframe.BitsStored === 16) {\n      return new Uint16Array(data);\n    } else {\n      return new Uint8Array(data);\n    }\n  }\n  const pixelData = new Uint8Array(data);\n  const max = multiframe.MaximumFractionalValue;\n  const onlyMaxAndZero = pixelData.find(element => element !== 0 && element !== max) === undefined;\n  if (!onlyMaxAndZero) {\n    // This is a fractional segmentation, which is not currently supported.\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n  var bitArray = new Uint8Array(data);\n  var chunks = [];\n  var maxBitsPerChunk = maxBytesPerChunk * 8;\n  var numberOfChunks = Math.ceil(bitArray.length * 8 / maxBitsPerChunk);\n  for (var i = 0; i < numberOfChunks; i++) {\n    var startBit = i * maxBitsPerChunk;\n    var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n    var startByte = Math.floor(startBit / 8);\n    var endByte = Math.ceil(endBit / 8);\n    var chunk = bitArray.slice(startByte, endByte);\n    var unpackedChunk = BitArray.unpack(chunk);\n    chunks.push(unpackedChunk);\n  }\n  return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  const baseImageId = sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n  if (!baseImageId) {\n    console.warn(`No imageId found for SOPInstanceUID: ${ReferencedSOPInstanceUID}`);\n    return undefined;\n  }\n  if (ReferencedFrameNumber !== undefined) {\n    if (baseImageId.includes(\"frames/\")) {\n      return baseImageId.replace(/frames\\/\\d+/, `frames/${ReferencedFrameNumber}`);\n    } else if (baseImageId.includes(\"dicomfile:\")) {\n      // dicomfile base 1, despite having frame=\n      return baseImageId.replace(/frame=\\d+/, `frame=${ReferencedFrameNumber}`);\n    } else if (baseImageId.includes(\"frame=\")) {\n      return baseImageId.replace(/frame=\\d+/, `frame=${ReferencedFrameNumber - 1}`);\n    } else {\n      if (baseImageId.includes(\"wadors:\")) {\n        return `${baseImageId}/frames/${ReferencedFrameNumber}`;\n      } else {\n        return `${baseImageId}?frame=${ReferencedFrameNumber - 1}`;\n      }\n    }\n  }\n  return baseImageId;\n}\n\n/**\n * Determines if an image is a multiframe image based on its metadata.\n *\n * @param {Object} imageMetadata - The metadata object for the image\n * @param {number} [imageMetadata.NumberOfFrames] - The number of frames in the image\n * @returns {boolean} True if the image is a multiframe image (NumberOfFrames > 1)\n */\nfunction isMultiframeImage(imageMetadata) {\n  return imageMetadata && imageMetadata.NumberOfFrames > 1;\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (!ReferencedSeriesInstanceUID || !PerFrameFunctionalGroup.PlanePositionSequence?.[0]?.ImagePositionPatient) {\n    return undefined;\n  }\n  const segFramePosition = PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient;\n  for (let imageId of imageIds) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n    if (!sourceImageMetadata) {\n      continue;\n    }\n    const isMultiframe = isMultiframeImage(sourceImageMetadata);\n    if (!sourceImageMetadata.ImagePositionPatient || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n\n    // For multiframe images, check each frame's position\n    if (isMultiframe) {\n      const framePosition = metadataProvider.get(\"imagePlaneModule\", imageId)?.imagePositionPatient;\n      if (framePosition && utilities$1.isEqual(segFramePosition, framePosition, tolerance)) {\n        return imageId;\n      }\n    } else if (utilities$1.isEqual(segFramePosition, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageId;\n    }\n  }\n  return undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  const orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations, tolerance) {\n  if (utilities$1.isEqual(iop, orientations[0], tolerance)) {\n    return pixelData2D;\n  } else if (utilities$1.isEqual(iop, orientations[1], tolerance)) {\n    // Flipped vertically.\n\n    // Undo Flip\n    return flipMatrix2D.v(pixelData2D);\n  } else if (utilities$1.isEqual(iop, orientations[2], tolerance)) {\n    // Flipped horizontally.\n\n    // Unfo flip\n    return flipMatrix2D.h(pixelData2D);\n  } else if (utilities$1.isEqual(iop, orientations[3], tolerance)) {\n    //Rotated 90 degrees\n\n    // Rotate back\n    return rotateMatrix902D(pixelData2D);\n  } else if (utilities$1.isEqual(iop, orientations[4], tolerance)) {\n    //Rotated 90 degrees and fliped horizontally.\n\n    // Undo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n  } else if (utilities$1.isEqual(iop, orientations[5], tolerance)) {\n    // Rotated 90 degrees and fliped vertically\n\n    // Unfo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n  } else if (utilities$1.isEqual(iop, orientations[6], tolerance)) {\n    // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (utilities$1.isEqual(iop, orientations[7], tolerance)) {\n    // Rotated 270 degrees\n\n    // Rotate back.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n  const segmentSequence = multiframe.SegmentSequence;\n  let data = [];\n  if (Array.isArray(segmentSequence)) {\n    data = [undefined, ...segmentSequence];\n  } else {\n    // Only one segment, will be stored as an object.\n    data = [undefined, segmentSequence];\n  }\n  return {\n    seriesInstanceUid,\n    data\n  };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n  const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n  // If all the data is in one chunk, we can just slice that chunk\n  if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n    return new Uint8Array(chunks[mapping.start.chunkIndex].buffer, mapping.start.offset, length);\n  } else {\n    // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n    let result = new Uint8Array(length);\n    let resultOffset = 0;\n    for (let i = mapping.start.chunkIndex; i <= mapping.end.chunkIndex; i++) {\n      let start = i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n      let end = i === mapping.end.chunkIndex ? mapping.end.offset : chunks[i].length;\n      result.set(new Uint8Array(chunks[i].buffer, start, end - start), resultOffset);\n      resultOffset += end - start;\n    }\n    return result;\n  }\n}\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n  var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n  if (offset < 0 || offset + length > totalBytes) {\n    throw new Error(\"Offset and length out of bounds\");\n  }\n  var startChunkIndex = 0;\n  var startOffsetInChunk = offset;\n  while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n    startOffsetInChunk -= chunks[startChunkIndex].length;\n    startChunkIndex++;\n  }\n  var endChunkIndex = startChunkIndex;\n  var endOffsetInChunk = startOffsetInChunk + length;\n  while (endOffsetInChunk > chunks[endChunkIndex].length) {\n    endOffsetInChunk -= chunks[endChunkIndex].length;\n    endChunkIndex++;\n  }\n  return {\n    start: {\n      chunkIndex: startChunkIndex,\n      offset: startOffsetInChunk\n    },\n    end: {\n      chunkIndex: endChunkIndex,\n      offset: endOffsetInChunk\n    }\n  };\n}\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, imageIds) {\n  let xAcc = 0;\n  let yAcc = 0;\n  let zAcc = 0;\n  let worldXAcc = 0;\n  let worldYAcc = 0;\n  let worldZAcc = 0;\n  let count = 0;\n  for (const [imageIdIndex, bufferIndices] of Object.entries(imageIdIndexBufferIndex)) {\n    const z = Number(imageIdIndex);\n    if (!bufferIndices || bufferIndices.length === 0) {\n      continue;\n    }\n\n    // Get metadata for this slice\n    const imageId = imageIds[z];\n    const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageId);\n    if (!imagePlaneModule) {\n      console.debug(\"Missing imagePlaneModule metadata for centroid calculation\");\n      continue;\n    }\n    const {\n      imagePositionPatient,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing\n    } = imagePlaneModule;\n    for (const bufferIndex of bufferIndices) {\n      const y = Math.floor(bufferIndex / multiframe.Rows);\n      const x = bufferIndex % multiframe.Rows;\n\n      // Image coordinates\n      xAcc += x;\n      yAcc += y;\n      zAcc += z;\n\n      // Calculate world coordinates\n      // P(world) = P(image) * IOP * spacing + IPP\n      const worldX = imagePositionPatient[0] + x * rowCosines[0] * columnPixelSpacing + y * columnCosines[0] * rowPixelSpacing;\n      const worldY = imagePositionPatient[1] + x * rowCosines[1] * columnPixelSpacing + y * columnCosines[1] * rowPixelSpacing;\n      const worldZ = imagePositionPatient[2] + x * rowCosines[2] * columnPixelSpacing + y * columnCosines[2] * rowPixelSpacing;\n      worldXAcc += worldX;\n      worldYAcc += worldY;\n      worldZAcc += worldZ;\n      count++;\n    }\n  }\n  return {\n    image: {\n      x: Math.floor(xAcc / count),\n      y: Math.floor(yAcc / count),\n      z: Math.floor(zAcc / count)\n    },\n    world: {\n      x: worldXAcc / count,\n      y: worldYAcc / count,\n      z: worldZAcc / count\n    },\n    count\n  };\n}\nconst Segmentation = {\n  generateSegmentation,\n  generateToolState,\n  fillSegmentation\n};\n\nexport { _createSegFromImages, _getLabelmapsFromReferencedFrameIndicies, alignPixelDataWithSourceData, calculateCentroid, checkSEGsOverlapping, Segmentation as default, fillSegmentation, findReferenceSourceImageId, generateSegmentation, generateToolState, getImageIdOfSourceImageBySourceImageSequence, getImageIdOfSourceImagebyGeometry, getSegmentIndex, getSegmentMetadata, getUnpackedChunks, getUnpackedOffsetAndLength, getValidOrientations, insertOverlappingPixelDataPlanar, insertPixelDataPlanar, readFromUnpackedChunks, unpackPixelData };\n","import Segmentation$1 from './Segmentation_3X.js';\nimport Segmentation from './Segmentation_4X.js';\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(images, labelmaps3DorBrushData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {boolean} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cornerstoneToolsVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.generateToolState(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$1.generateToolState(imageIds, arrayBuffer, metadataProvider);\n  }\n  console.warn(`No generateToolState adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  let cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation.fillSegmentation(segmentation, inputLabelmaps3D, options);\n  }\n  console.warn(`No generateSegmentation adapter for cornerstone version ${cornerstoneToolsVersion}, exiting.`);\n}\n\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import { log, data, normalizers } from 'dcmjs';\nimport checkOrientation from '../helpers/checkOrientation.js';\nimport { utilities } from '@cornerstonejs/core';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nasync function generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-3;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = [ImageOrientationPatient];\n  const pixelData = getPixelData(multiframe);\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  if (orientation !== \"Planar\") {\n    const orientationText = {\n      Perpendicular: \"orthogonal\",\n      Oblique: \"oblique\"\n    };\n    throw new Error(`Parametric maps ${orientationText[orientation]} to the acquisition plane of the source data are not yet supported.`);\n  }\n  const imageIdMaps = imageIds.reduce((acc, curr, index) => {\n    acc.indices[curr] = index;\n    acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n    return acc;\n  }, {\n    indices: {},\n    metadata: {}\n  });\n  await insertPixelDataPlanar(pixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps);\n  return {\n    pixelData\n  };\n}\nfunction insertPixelDataPlanar(sourcePixelData, multiframe, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap, imageIdMaps) {\n  const targetPixelData = new sourcePixelData.constructor(sourcePixelData.length);\n  const {\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sliceLength = Columns * Rows;\n  const numSlices = PerFrameFunctionalGroupsSequence.length;\n  for (let i = 0; i < numSlices; i++) {\n    const sourceSliceDataView = new sourcePixelData.constructor(sourcePixelData.buffer, i * sliceLength, sliceLength);\n    const imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n      continue;\n    }\n    const sourceImageMetadata = imageIdMaps.metadata[imageId];\n    if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n      throw new Error(\"Parametric map have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported.\");\n    }\n    const imageIdIndex = imageIdMaps.indices[imageId];\n    const byteOffset = sliceLength * imageIdIndex * targetPixelData.BYTES_PER_ELEMENT;\n    const targetSliceDataView = new targetPixelData.constructor(targetPixelData.buffer, byteOffset, sliceLength);\n    targetSliceDataView.set(sourceSliceDataView);\n  }\n  return targetPixelData;\n}\nfunction getPixelData(multiframe) {\n  let TypedArrayClass;\n  let data;\n  if (multiframe.PixelData) {\n    const validTypedArrays = multiframe.BitsAllocated === 16 ? [Uint16Array, Int16Array] : [Uint32Array, Int32Array];\n    TypedArrayClass = validTypedArrays[multiframe.PixelRepresentation ?? 0];\n    data = multiframe.PixelData;\n  } else if (multiframe.FloatPixelData) {\n    TypedArrayClass = Float32Array;\n    data = multiframe.FloatPixelData;\n  } else if (multiframe.DoubleFloatPixelData) {\n    TypedArrayClass = Float64Array;\n    data = multiframe.DoubleFloatPixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This parametric map pixel data is undefined.\");\n  }\n  if (Array.isArray(data)) {\n    data = data[0];\n  }\n  return new TypedArrayClass(data);\n}\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap) {\n  let imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  const {\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence,\n    SourceImageSequence,\n    ReferencedSeriesSequence\n  } = multiframe;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  const PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  let frameSourceImageSequence = undefined;\n  if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    let DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    console.warn(\"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\");\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImageBySourceImageSequence(frameSourceImageSequence, sopUIDImageIdIndexMap);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    const ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\nfunction getImageIdOfSourceImageBySourceImageSequence(SourceImageSequence, sopUIDImageIdIndexMap) {\n  const {\n    ReferencedSOPInstanceUID,\n    ReferencedFrameNumber\n  } = SourceImageSequence;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, sopUIDImageIdIndexMap) : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (ReferencedSeriesInstanceUID === undefined || PerFrameFunctionalGroup.PlanePositionSequence === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient === undefined) {\n    return undefined;\n  }\n  for (let imageIdsIndex = 0; imageIdsIndex < imageIds.length; ++imageIdsIndex) {\n    const sourceImageMetadata = metadataProvider.get(\"instance\", imageIds[imageIdsIndex]);\n    if (sourceImageMetadata === undefined || sourceImageMetadata.ImagePositionPatient === undefined || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n    if (utilities.isEqual(PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageIds[imageIdsIndex];\n    }\n  }\n}\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, sopUIDImageIdIndexMap) {\n  const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n  if (!imageId) {\n    return;\n  }\n  const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n  return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\nconst ParametricMapObj = {\n  generateToolState\n};\n\nexport { ParametricMapObj as ParametricMap, ParametricMapObj as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport Length from './Length.js';\nimport FreehandRoi from './FreehandRoi.js';\nimport Bidirectional from './Bidirectional.js';\nimport EllipticalRoi from './EllipticalRoi.js';\nimport CircleRoi from './CircleRoi.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport CobbAngle from './CobbAngle.js';\nimport Angle from './Angle.js';\nimport RectangleRoi from './RectangleRoi.js';\nimport * as Segmentation from './Segmentation.js';\nimport ParametricMapObj from './ParametricMap.js';\n\nconst CornerstoneSR = {\n  Length,\n  FreehandRoi,\n  Bidirectional,\n  EllipticalRoi,\n  CircleRoi,\n  ArrowAnnotate,\n  MeasurementReport,\n  CobbAngle,\n  Angle,\n  RectangleRoi\n};\nconst CornerstoneSEG = {\n  Segmentation\n};\nconst CornerstonePMAP = {\n  ParametricMap: ParametricMapObj\n};\n\nexport { CornerstonePMAP, CornerstoneSEG, CornerstoneSR };\n","var CORNERSTONE_3D_TAG = \"Cornerstone3DTools@^0.1.0\";\n\nexport { CORNERSTONE_3D_TAG as default };\n","const patientTags = [\"PatientName\", \"PatientID\", \"PatientBirthDate\", \"PatientBirthTime\", \"PatientID\", \"IssuerOfPatientID\", \"OtherPatientIDs\", \"OtherPatientIDsSequence\", \"PatientSex\", \"PatientIdentityRemoved\", \"DeidentificationMethodCodeSequence\"];\nconst studyTags = [\"StudyDate\", \"StudyTime\", \"StudyStatusID\", \"StudyPriorityID\", \"StudyInstanceUID\", \"StudyDescription\", \"AccessionNumber\", \"StudyID\", \"ReferringPhysicianName\", \"BodyPartExamined\", \"TimezoneOffsetFromUTC\"];\nconst patientStudyTags = [...patientTags, ...studyTags];\nfunction copyStudyTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of patientStudyTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copyStudyTags, patientStudyTags, patientTags, studyTags };\n","const seriesTags = [\"SeriesInstanceUID\", \"SeriesNumber\", \"SeriesDescription\", \"Modality\", \"SeriesDate\", \"SeriesTime\"];\nfunction copySeriesTags(src) {\n  const study = {\n    _meta: src._meta,\n    _vrMap: src._vrMap\n  };\n  for (const tagKey of seriesTags) {\n    const value = src[tagKey];\n    if (value === undefined) {\n      continue;\n    }\n    study[tagKey] = value;\n  }\n  return study;\n}\n\nexport { copySeriesTags, seriesTags };\n","import { utilities } from '@cornerstonejs/core';\n\nconst {\n  imageToWorldCoords\n} = utilities;\nfunction scoordToWorld(_ref, scoord) {\n  let {\n    is3DMeasurement,\n    referencedImageId\n  } = _ref;\n  const worldCoords = [];\n  if (is3DMeasurement) {\n    const {\n      GraphicData\n    } = scoord;\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      const point = [GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]];\n      worldCoords.push(point);\n    }\n  } else {\n    const {\n      GraphicData\n    } = scoord;\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n      worldCoords.push(point);\n    }\n  }\n  return worldCoords;\n}\n\nexport { scoordToWorld };\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\nconst CodingScheme = {\n  CodingSchemeDesignator,\n  codeValues: {\n    CORNERSTONEFREETEXT\n  }\n};\n\nexport { CodingScheme as default };\n","const NO_IMAGE_ID = \"none\";\nconst CS3D_DESIGNATOR = \"99CS3D\";\nconst TEXT_ANNOTATION_POSITION = {\n  schemeDesignator: CS3D_DESIGNATOR,\n  meaning: \"Text Annotation Position\",\n  value: \"TextPosition\"\n};\nconst COMMENT_CODE = {\n  schemeDesignator: \"DCM\",\n  meaning: \"Comment\",\n  value: \"121106\"\n};\n\nexport { COMMENT_CODE, CS3D_DESIGNATOR, NO_IMAGE_ID, TEXT_ANNOTATION_POSITION };\n","import { utilities } from '@cornerstonejs/core';\n\nconst {\n  worldToImageCoords: globalWorldToImageCoords\n} = utilities;\nlet useWorldToImageCoords = globalWorldToImageCoords;\nfunction toScoord(_ref, point) {\n  let {\n    is3DMeasurement,\n    referencedImageId\n  } = _ref;\n  if (is3DMeasurement) {\n    return {\n      x: point[0],\n      y: point[1],\n      z: point[2]\n    };\n  }\n  const point2 = useWorldToImageCoords(referencedImageId, point);\n  return {\n    x: point2[0],\n    y: point2[1]\n  };\n}\nfunction toScoords(scoordArgs, points) {\n  return points.map(point => toScoord(scoordArgs, point));\n}\nfunction setWorldToImageCoords() {\n  let worldToImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : globalWorldToImageCoords;\n  useWorldToImageCoords = worldToImage;\n}\n\nexport { setWorldToImageCoords, toScoord, toScoords };\n","import { COMMENT_CODE, TEXT_ANNOTATION_POSITION } from './constants/index.js';\nimport dcmjs from 'dcmjs';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nconst {\n  sr: {\n    valueTypes,\n    coding\n  }\n} = dcmjs;\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\nclass LabelData {\n  constructor(tid300Item, annotation) {\n    this.tid300Item = tid300Item;\n    this.annotation = annotation;\n    this.ReferencedSOPSequence = tid300Item.ReferencedSOPSequence;\n  }\n  contentItem() {\n    const contentEntries = this.tid300Item.contentItem();\n    const {\n      label,\n      handles\n    } = this.annotation.data;\n    if (label) {\n      contentEntries.push(this.createQualitativeLabel(label));\n      this.filterCornerstoneFreeText(contentEntries);\n    }\n    if (handles?.textBox?.hasMoved) {\n      contentEntries.push(this.createQualitativeLabelPosition(this.annotation));\n    }\n    return contentEntries;\n  }\n  filterCornerstoneFreeText(contentEntries) {\n    for (let i = 0; i < contentEntries.length; i++) {\n      const group = contentEntries[i];\n      if (!group.ConceptCodeSequence) {\n        continue;\n      }\n      const csLabel = group.ConceptCodeSequence.find(item => item.CodeValue === CORNERSTONEFREETEXT);\n      if (csLabel !== -1) {\n        group.ConceptCodeSequence.splice(csLabel, 1);\n        if (group.ConceptCodeSequence.length === 0) {\n          contentEntries.splice(i, 1);\n        }\n        return;\n      }\n    }\n  }\n  createQualitativeLabel(label) {\n    const relationshipType = valueTypes.RelationshipTypes.CONTAINS;\n    return new valueTypes.TextContentItem({\n      name: new coding.CodedConcept(COMMENT_CODE),\n      relationshipType,\n      value: label\n    });\n  }\n  createQualitativeLabelPosition(annotation) {\n    const {\n      textBox\n    } = annotation.data.handles;\n    const {\n      referencedImageId,\n      FrameOfReferenceUID: frameOfReferenceUID\n    } = annotation.metadata;\n    const is3DMeasurement = !referencedImageId;\n    const {\n      worldPosition\n    } = textBox;\n    const {\n      x,\n      y,\n      z\n    } = toScoord({\n      is3DMeasurement,\n      referencedImageId\n    }, worldPosition);\n    const graphicType = valueTypes.GraphicTypes.POINT;\n    const relationshipType = valueTypes.RelationshipTypes.CONTAINS;\n    const name = new coding.CodedConcept(TEXT_ANNOTATION_POSITION);\n    if (is3DMeasurement) {\n      const graphicData = [x, y, z];\n      return new valueTypes.Scoord3DContentItem({\n        name,\n        relationshipType,\n        graphicType,\n        frameOfReferenceUID,\n        graphicData\n      });\n    }\n    const graphicData = [x, y];\n    return new valueTypes.ScoordContentItem({\n      name,\n      relationshipType,\n      graphicType,\n      graphicData\n    });\n  }\n}\n\nexport { LabelData as default };\n","import { utilities as utilities$1, derivations, normalizers, data } from 'dcmjs';\nimport { utilities, cache } from '@cornerstonejs/core';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport { toArray } from '../helpers/toArray.js';\nimport { codeMeaningEquals } from '../helpers/codeMeaningEquals.js';\nimport 'buffer';\nimport { copyStudyTags } from '../helpers/copyStudyTags.js';\nimport { copySeriesTags } from '../helpers/copySeriesTags.js';\nimport { scoordToWorld } from '../helpers/scoordToWorld.js';\nimport { toPoint3 } from '../helpers/toPoint3.js';\nimport CodingScheme from './CodingScheme.js';\nimport { COMMENT_CODE, TEXT_ANNOTATION_POSITION, NO_IMAGE_ID } from './constants/index.js';\nimport LabelData from './LabelData.js';\n\nvar _MeasurementReport;\nconst {\n  TID1500,\n  addAccessors\n} = utilities$1;\nconst {\n  StructuredReport\n} = derivations;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  TID1500MeasurementReport,\n  TID1501MeasurementGroup\n} = TID1500;\nconst {\n  DicomMetaDictionary\n} = data;\nconst FINDING = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nconst COMMENT = {\n  CodingSchemeDesignator: COMMENT_CODE.schemeDesignator,\n  CodeValue: COMMENT_CODE.value\n};\nconst COMMENT_POSITION = {\n  CodingSchemeDesignator: TEXT_ANNOTATION_POSITION.schemeDesignator,\n  CodeValue: TEXT_ANNOTATION_POSITION.value\n};\nconst FINDING_SITE = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nconst FINDING_SITE_OLD = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nclass MeasurementReport {\n  static getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, is3DMeasurement) {\n    const args = toolClass.getTID300RepresentationArguments(tool, is3DMeasurement);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n    if (args.use3DSpatialCoordinates) {\n      args.ReferencedFrameOfReferenceUID = tool.metadata.FrameOfReferenceUID;\n    }\n    const tid300Measurement = new toolClass.TID300Representation(args);\n    const labelMeasurement = new LabelData(tid300Measurement, tool);\n    return labelMeasurement;\n  }\n  static getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, is3DMeasurement) {\n    const toolTypeData = toolData[toolType];\n    const toolClass = this.measurementAdapterByToolType.get(toolType);\n    if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n      return;\n    }\n    const Measurements = toolTypeData.data.map(tool => {\n      return this.getTID300ContentItem(tool, ReferencedSOPSequence, toolClass, is3DMeasurement);\n    });\n    return new TID1501MeasurementGroup(Measurements);\n  }\n  static getCornerstoneLabelFromDefaultState(defaultState) {\n    const {\n      findingSites = [],\n      finding,\n      commentGroup\n    } = defaultState;\n    if (commentGroup?.TextValue) {\n      return commentGroup.TextValue;\n    }\n    const cornersoneFreeTextCodingValue = CodingScheme.codeValues.CORNERSTONEFREETEXT;\n    const freeTextLabel = findingSites.find(fs => fs.CodeValue === cornersoneFreeTextCodingValue);\n    if (freeTextLabel) {\n      return freeTextLabel.CodeMeaning;\n    }\n    if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n      return finding.CodeMeaning;\n    }\n  }\n  static generateDatasetMeta() {\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n    const _meta = {\n      FileMetaInformationVersion: {\n        Value: [fileMetaInformationVersionArray.buffer],\n        vr: \"OB\"\n      },\n      TransferSyntaxUID: {\n        Value: [\"1.2.840.10008.1.2.1\"],\n        vr: \"UI\"\n      },\n      ImplementationClassUID: {\n        Value: [DicomMetaDictionary.uid()],\n        vr: \"UI\"\n      },\n      ImplementationVersionName: {\n        Value: [\"dcmjs\"],\n        vr: \"SH\"\n      }\n    };\n    return _meta;\n  }\n  static processSCOORDGroup(_ref) {\n    let {\n      SCOORDGroup,\n      toolType,\n      sopInstanceUIDToImageIdMap,\n      metadata\n    } = _ref;\n    const {\n      ReferencedSOPSequence\n    } = SCOORDGroup.ContentSequence;\n    const {\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber = 1\n    } = ReferencedSOPSequence;\n    const referencedImageId = sopInstanceUIDToImageIdMap[`${ReferencedSOPInstanceUID}:${ReferencedFrameNumber}`];\n    const imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n    const annotationUID = DicomMetaDictionary.uid();\n    return {\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      referencedImageId,\n      state: {\n        description: undefined,\n        sopInstanceUid: ReferencedSOPInstanceUID,\n        annotation: {\n          data: {\n            annotationUID,\n            cachedStats: {},\n            handles: {\n              activeHandleIndex: 0,\n              textBox: {\n                hasMoved: false\n              }\n            }\n          },\n          annotationUID,\n          metadata: {\n            toolName: toolType,\n            referencedImageId,\n            FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID\n          }\n        }\n      }\n    };\n  }\n  static processSCOORD3DGroup(_ref2) {\n    let {\n      SCOORD3DGroup,\n      toolType\n    } = _ref2;\n    const annotationUID = DicomMetaDictionary.uid();\n    const toolData = {\n      SCOORD3DGroup,\n      FrameOfReferenceUID: SCOORD3DGroup.ReferencedFrameOfReferenceUID,\n      state: {\n        description: undefined,\n        annotation: {\n          annotationUID,\n          data: {\n            annotationUID,\n            cachedStats: {},\n            handles: {\n              activeHandleIndex: 0,\n              textBox: {\n                hasMoved: false\n              }\n            }\n          },\n          metadata: {\n            toolName: toolType,\n            FrameOfReferenceUID: SCOORD3DGroup.ReferencedFrameOfReferenceUID\n          }\n        }\n      }\n    };\n    utilities.updatePlaneRestriction(toPoint3(SCOORD3DGroup.GraphicData), toolData.state.annotation.metadata);\n    return toolData;\n  }\n  static getSpatialCoordinatesState(_ref3) {\n    let {\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      toolType\n    } = _ref3;\n    const contentSequenceArr = toArray(NUMGroup.ContentSequence);\n    const SCOORDGroup = contentSequenceArr.find(group => group.ValueType === \"SCOORD\");\n    const SCOORD3DGroup = contentSequenceArr.find(group => group.ValueType === \"SCOORD3D\");\n    const result = SCOORD3DGroup && this.processSCOORD3DGroup({\n      SCOORD3DGroup,\n      toolType\n    }) || SCOORDGroup && this.processSCOORDGroup({\n      SCOORDGroup,\n      toolType,\n      metadata,\n      sopInstanceUIDToImageIdMap\n    });\n    if (!result) {\n      throw new Error(\"No spatial coordinates group found.\");\n    }\n    return result;\n  }\n  static processSpatialCoordinatesGroup(_ref4) {\n    let {\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      findingGroup,\n      findingSiteGroups,\n      commentGroup,\n      commentPositionGroup,\n      toolType\n    } = _ref4;\n    const {\n      state,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      ReferencedFrameNumber,\n      SCOORD3DGroup,\n      FrameOfReferenceUID,\n      referencedImageId,\n      textBoxPosition\n    } = this.getSpatialCoordinatesState({\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      toolType\n    });\n    const finding = findingGroup ? addAccessors(findingGroup.ConceptCodeSequence) : undefined;\n    const findingSites = findingSiteGroups.map(fsg => {\n      return addAccessors(fsg.ConceptCodeSequence);\n    });\n    if (commentPositionGroup) {\n      state.commentPositionGroup = commentPositionGroup;\n      const textBoxCoords = scoordToWorld({\n        is3DMeasurement: !referencedImageId,\n        referencedImageId\n      }, commentPositionGroup);\n      state.annotation.data.handles.textBox = {\n        hasMoved: true,\n        worldPosition: textBoxCoords[0]\n      };\n    }\n    state.finding = finding;\n    state.findingSites = findingSites;\n    state.commentGroup = commentGroup;\n    state.commentPositionGroup = commentPositionGroup;\n    if (finding) {\n      state.description = finding.CodeMeaning;\n    }\n    state.annotation.data.label = this.getCornerstoneLabelFromDefaultState(state);\n    return {\n      defaultState: state,\n      state,\n      NUMGroup,\n      scoord: SCOORD3DGroup || SCOORDGroup,\n      SCOORDGroup,\n      ReferencedSOPSequence,\n      ReferencedSOPInstanceUID,\n      referencedImageId,\n      textBoxPosition,\n      ReferencedFrameNumber,\n      SCOORD3DGroup,\n      FrameOfReferenceUID\n    };\n  }\n  static getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, toolType) {\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const contentSequenceArr = toArray(ContentSequence);\n    const findingGroup = contentSequenceArr.find(group => this.codeValueMatch(group, FINDING));\n    const commentGroup = contentSequenceArr.find(group => this.codeValueMatch(group, COMMENT));\n    const commentPositionGroup = contentSequenceArr.find(group => this.codeValueMatch(group, COMMENT_POSITION));\n    const findingSiteGroups = contentSequenceArr.filter(group => this.codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)) || [];\n    const NUMGroup = contentSequenceArr.find(group => group.ValueType === \"NUM\") || {\n      ContentSequence: contentSequenceArr.filter(group => group.ValueType === \"SCOORD\" || group.ValueType === \"SCOORD3D\")\n    };\n    const spatialGroup = this.processSpatialCoordinatesGroup({\n      NUMGroup,\n      sopInstanceUIDToImageIdMap,\n      metadata,\n      findingGroup,\n      findingSiteGroups,\n      commentGroup,\n      commentPositionGroup,\n      toolType\n    });\n    const {\n      referencedImageId\n    } = spatialGroup.state.annotation.metadata;\n    const is3DMeasurement = !!spatialGroup.SCOORD3DGroup;\n    const scoordArgs = {\n      referencedImageId,\n      is3DMeasurement\n    };\n    const scoord = spatialGroup.SCOORD3DGroup || spatialGroup.SCOORDGroup;\n    const worldCoords = scoordToWorld(scoordArgs, scoord);\n    return {\n      ...spatialGroup,\n      is3DMeasurement,\n      scoordArgs,\n      scoord,\n      worldCoords\n    };\n  }\n  static generateReferencedSOPSequence(_ref5) {\n    let {\n      toolData,\n      toolTypes,\n      metadataProvider,\n      imageId,\n      sopInstanceUIDsToSeriesInstanceUIDMap,\n      derivationSourceDatasets\n    } = _ref5;\n    const effectiveImageId = imageId === NO_IMAGE_ID ? this.getImageIdFromVolume({\n      toolData,\n      toolTypes\n    }) : imageId;\n    const sopCommonModule = metadataProvider.get(\"sopCommonModule\", effectiveImageId);\n    const instance = metadataProvider.get(\"instance\", effectiveImageId);\n    const {\n      sopInstanceUID,\n      sopClassUID\n    } = sopCommonModule;\n    const {\n      SeriesInstanceUID: seriesInstanceUID\n    } = instance;\n    sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] = seriesInstanceUID;\n    if (!derivationSourceDatasets.find(dsd => dsd.SeriesInstanceUID === seriesInstanceUID)) {\n      const derivationSourceDataset = MeasurementReport.generateDerivationSourceDataset(instance);\n      derivationSourceDatasets.push(derivationSourceDataset);\n    }\n    const frameNumber = metadataProvider.get(\"frameNumber\", effectiveImageId);\n    const ReferencedSOPSequence = {\n      ReferencedSOPClassUID: sopClassUID,\n      ReferencedSOPInstanceUID: sopInstanceUID,\n      ReferencedFrameNumber: undefined\n    };\n    if (instance && instance.NumberOfFrames && instance.NumberOfFrames > 1 || Normalizer.isMultiframeSOPClassUID(sopClassUID)) {\n      ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n    }\n    return ReferencedSOPSequence;\n  }\n  static getImageIdFromVolume(_ref6) {\n    let {\n      toolData,\n      toolTypes\n    } = _ref6;\n    const referenceToolData = toolData?.[toolTypes?.[0]]?.data?.[0];\n    const volumeId = referenceToolData?.metadata?.volumeId;\n    const volume = cache.getVolume(volumeId);\n    if (!volume) {\n      throw new Error(`No volume found for ${volumeId}`);\n    }\n    const imageId = volume.imageIds[0];\n    return imageId;\n  }\n  static generateReport(toolState, metadataProvider, options) {\n    let allMeasurementGroups = [];\n    const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n    const derivationSourceDatasets = [];\n    const _meta = MeasurementReport.generateDatasetMeta();\n    let is3DSR = false;\n    Object.keys(toolState).forEach(imageId => {\n      const toolData = toolState[imageId];\n      const toolTypes = Object.keys(toolData);\n      const is3DMeasurement = imageId === NO_IMAGE_ID;\n      const ReferencedSOPSequence = this.generateReferencedSOPSequence({\n        toolData,\n        toolTypes,\n        metadataProvider,\n        imageId,\n        sopInstanceUIDsToSeriesInstanceUIDMap,\n        derivationSourceDatasets\n      });\n      if (is3DMeasurement) {\n        is3DSR = true;\n      }\n      const measurementGroups = [];\n      toolTypes.forEach(toolType => {\n        const group = this.getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, is3DMeasurement);\n        if (group) {\n          measurementGroups.push(group);\n        }\n      });\n      allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n    });\n    const tid1500MeasurementReport = new TID1500MeasurementReport({\n      TID1501MeasurementGroups: allMeasurementGroups\n    }, options);\n    const report = new StructuredReport(derivationSourceDatasets, options);\n    const contentItem = tid1500MeasurementReport.contentItem(derivationSourceDatasets, {\n      ...options,\n      sopInstanceUIDsToSeriesInstanceUIDMap\n    });\n    report.dataset = Object.assign(report.dataset, contentItem);\n    report.dataset._meta = _meta;\n    report.SpecificCharacterSet = \"ISO_IR 192\";\n    if (is3DSR) {\n      report.dataset.SOPClassUID = DicomMetaDictionary.sopClassUIDsByName.Comprehensive3DSR;\n      if (!report.dataset.SOPClassUID) {\n        throw new Error(`NO sop class defined for Comprehensive3DSR in ${JSON.stringify(DicomMetaDictionary.sopClassUIDsByName)}`);\n      }\n    }\n    return report;\n  }\n  static generateToolState(dataset, sopInstanceUIDToImageIdMap, metadata, hooks) {\n    if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n      throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n    }\n    const REPORT = \"Imaging Measurements\";\n    const GROUP = \"Measurement Group\";\n    const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n    const TRACKING_UNIQUE_IDENTIFIER = \"Tracking Unique Identifier\";\n    const imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n    const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n    const measurementData = {};\n    measurementGroups.forEach(measurementGroup => {\n      try {\n        const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n        const trackingIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER);\n        const {\n          TextValue: trackingIdentifierValue\n        } = trackingIdentifierGroup;\n        const trackingUniqueIdentifierGroup = measurementGroupContentSequence.find(contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_UNIQUE_IDENTIFIER);\n        const trackingUniqueIdentifierValue = trackingUniqueIdentifierGroup?.UID;\n        const toolAdapter = hooks?.getToolClass?.(measurementGroup, dataset, this.measurementAdapterByToolType) || this.getAdapterForTrackingIdentifier(trackingIdentifierValue) || this.getAdapterForCodeType(measurementGroup);\n        if (toolAdapter) {\n          const measurement = toolAdapter.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, metadata, trackingIdentifierValue);\n          measurement.TrackingUniqueIdentifier = trackingUniqueIdentifierValue;\n          console.log(`=== ${toolAdapter.toolType} ===`);\n          console.log(measurement);\n          measurementData[toolAdapter.toolType] ||= [];\n          measurementData[toolAdapter.toolType].push(measurement);\n        }\n      } catch (e) {\n        console.warn(\"Unable to generate tool state for\", measurementGroup, e);\n      }\n    });\n    return measurementData;\n  }\n  static registerTool(toolAdapter) {\n    let replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const registerName = toolAdapter.toolType;\n    if (this.measurementAdapterByToolType.has(registerName)) {\n      if (!replace) {\n        throw new Error(`The registered tool name ${registerName} already exists in adapters, use a different toolType or use replace`);\n      }\n      if (typeof replace === \"function\") {\n        replace(this.measurementAdapterByToolType.get(registerName));\n      }\n    }\n    this.measurementAdapterByToolType.set(toolAdapter.toolType, toolAdapter);\n    this.measurementAdapterByTrackingIdentifier.set(toolAdapter.trackingIdentifierTextValue, toolAdapter);\n  }\n  static registerTrackingIdentifier(toolClass) {\n    for (var _len = arguments.length, trackingIdentifiers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      trackingIdentifiers[_key - 1] = arguments[_key];\n    }\n    for (const identifier of trackingIdentifiers) {\n      this.measurementAdapterByTrackingIdentifier.set(identifier, toolClass);\n    }\n  }\n  static getAdapterForTrackingIdentifier(trackingIdentifier) {\n    const adapter = this.measurementAdapterByTrackingIdentifier.get(trackingIdentifier);\n    if (adapter) {\n      return adapter;\n    }\n    for (const adapterTest of [...this.measurementAdapterByToolType.values()]) {\n      if (adapterTest.isValidCornerstoneTrackingIdentifier(trackingIdentifier)) {\n        this.measurementAdapterByTrackingIdentifier.set(trackingIdentifier, adapterTest);\n        return adapterTest;\n      }\n    }\n  }\n  static getAdapterForCodeType(measurementGroup) {\n    for (const adapter of this.measurementAdapterByTrackingIdentifier.values()) {\n      if (adapter.isValidMeasurement(measurementGroup)) {\n        return adapter;\n      }\n    }\n  }\n  static registerAdapterTypes(adapter) {\n    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      types[_key2 - 1] = arguments[_key2];\n    }\n    for (const type of types) {\n      if (!this.measurementAdaptersByType.has(type)) {\n        this.measurementAdaptersByType.set(type, []);\n      }\n      const adapters = this.measurementAdaptersByType.get(type);\n      if (adapters.indexOf(adapter) === -1) {\n        adapters.push(adapter);\n      }\n    }\n  }\n  static getAdaptersForTypes(graphicCode, graphicType, pointCount) {\n    const adapters = [];\n    appendList(adapters, this.measurementAdaptersByType.get(`${graphicCode}-${graphicType}-${pointCount}`));\n    appendList(adapters, this.measurementAdaptersByType.get(`${graphicCode}-${graphicType}`));\n    appendList(adapters, this.measurementAdaptersByType.get(graphicCode));\n    appendList(adapters, this.measurementAdaptersByType.get(graphicType));\n    return adapters;\n  }\n}\n_MeasurementReport = MeasurementReport;\n_MeasurementReport.CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n_MeasurementReport.measurementAdapterByToolType = new Map();\n_MeasurementReport.measurementAdaptersByType = new Map();\n_MeasurementReport.measurementAdapterByTrackingIdentifier = new Map();\n_MeasurementReport.codeValueMatch = (group, code, oldCode) => {\n  const {\n    ConceptNameCodeSequence\n  } = group;\n  if (!ConceptNameCodeSequence) {\n    return;\n  }\n  const {\n    CodingSchemeDesignator,\n    CodeValue\n  } = ConceptNameCodeSequence;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\n_MeasurementReport.generateDerivationSourceDataset = instance => {\n  const studyTags = copyStudyTags(instance);\n  const seriesTags = copySeriesTags(instance);\n  return {\n    ...studyTags,\n    ...seriesTags\n  };\n};\nfunction appendList(list, appendList) {\n  if (!appendList?.length) {\n    return;\n  }\n  list.push(...appendList);\n}\n\nexport { MeasurementReport as default };\n","function toPoint3(flatPoints) {\n  const points = [];\n  if (!flatPoints?.length) {\n    return points;\n  }\n  const {\n    length: n\n  } = flatPoints;\n  if (n % 3 !== 0) {\n    throw new Error(`Points array should be divisible by 3 for SCOORD3D, but contents are: ${JSON.stringify(flatPoints)} of length ${n}`);\n  }\n  for (let i = 0; i < n; i += 3) {\n    points.push([flatPoints[i], flatPoints[i + 1], flatPoints[i + 2]]);\n  }\n  return points;\n}\n\nexport { toPoint3 as default, toPoint3 };\n","import CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport MeasurementReport from './MeasurementReport.js';\nimport 'dcmjs';\nimport 'buffer';\nimport { toScoords } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nclass BaseAdapter3D {\n  static registerType() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let key = code;\n    if (type) {\n      key = `${key}${key.length ? \"-\" : \"\"}${type}`;\n    }\n    if (count) {\n      key = `${key}${key.length ? \"-\" : \"\"}${count}`;\n    }\n    MeasurementReport.registerAdapterTypes(this, key);\n  }\n  static getPointsCount(graphicItem) {\n    const is3DMeasurement = graphicItem.ValueType === \"SCOORD3D\";\n    const pointSize = is3DMeasurement ? 3 : 2;\n    return graphicItem.GraphicData.length / pointSize;\n  }\n  static getGraphicItems(measurementGroup, filter) {\n    const items = measurementGroup.ContentSequence.filter(group => group.ValueType === \"SCOORD\" || group.ValueType === \"SCOORD3D\");\n    return filter ? items.filter(filter) : items;\n  }\n  static getGraphicItem(measurementGroup) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const items = this.getGraphicItems(measurementGroup, type && (group => group.ValueType === type));\n    return items[offset];\n  }\n  static getGraphicCode(graphicItem) {\n    const {\n      ConceptNameCodeSequence: conceptNameItem\n    } = graphicItem;\n    const {\n      CodeValue: graphicValue,\n      CodingSchemeDesignator: graphicDesignator\n    } = conceptNameItem;\n    return `${graphicDesignator}:${graphicValue}`;\n  }\n  static getGraphicType(graphicItem) {\n    return graphicItem.GraphicType;\n  }\n  static isValidMeasurement(_measurementGroup) {\n    return false;\n  }\n  static init(toolType, representation, options) {\n    this.toolType = toolType;\n    if (BaseAdapter3D.toolType) {\n      throw new Error(`Base adapter tool type set to ${this.toolType} while setting ${toolType}`);\n    }\n    this.parentType = options?.parentType;\n    this.trackingIdentifiers = new Set();\n    this.TID300Representation = representation;\n    if (this.parentType) {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${this.parentType}:${this.toolType}`;\n      const alternateTrackingIdentifier = `${CORNERSTONE_3D_TAG}:${this.toolType}`;\n      this.trackingIdentifiers.add(alternateTrackingIdentifier);\n    } else {\n      this.trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${toolType}`;\n    }\n    this.trackingIdentifiers.add(this.trackingIdentifierTextValue);\n    MeasurementReport.registerTool(this);\n  }\n  static registerLegacy() {\n    this.trackingIdentifiers.add(`cornerstoneTools@^4.0.0:${this.toolType}`);\n  }\n  static registerSubType(adapter, toolType, replace) {\n    const subAdapter = Object.create(adapter);\n    subAdapter.init(toolType, adapter.TID300Representation, {\n      parentType: adapter.parentType || adapter.toolType,\n      replace\n    });\n    return subAdapter;\n  }\n  static isValidCornerstoneTrackingIdentifier(trackingIdentifier) {\n    if (this.trackingIdentifiers.has(trackingIdentifier)) {\n      return true;\n    }\n    if (!trackingIdentifier.includes(\":\")) {\n      return false;\n    }\n    return trackingIdentifier.startsWith(this.trackingIdentifierTextValue);\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, trackingIdentifier) {\n    const {\n      defaultState: state,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    state.annotation.data = {\n      cachedStats: {},\n      frameNumber: ReferencedFrameNumber,\n      seriesLevel: trackingIdentifier?.indexOf(\":Series\") > 0\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const pointsImage = toScoords(scoordProps, tool.data.handles.points);\n    const tidArguments = {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null\n    };\n    return tidArguments;\n  }\n}\n\nexport { BaseAdapter3D as default };\n","import { utilities } from 'dcmjs';\nimport { utilities as utilities$1 } from '@cornerstonejs/core';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\n\nvar _ArrowAnnotate;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nconst {\n  imageToWorldCoords\n} = utilities$1;\nclass ArrowAnnotate extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, _trackingIdentifier) {\n    const {\n      state,\n      SCOORDGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const text = state.annotation.data.label;\n    if (worldCoords.length === 1 && SCOORDGroup) {\n      const imagePixelModule = metadata.get(\"imagePixelModule\", referencedImageId);\n      let xOffset = 10;\n      let yOffset = 10;\n      if (imagePixelModule) {\n        const {\n          columns,\n          rows\n        } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n      const {\n        GraphicData\n      } = SCOORDGroup;\n      const secondPoint = imageToWorldCoords(referencedImageId, [GraphicData[0] + xOffset, GraphicData[1] + yOffset]);\n      worldCoords.push(secondPoint);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      text,\n      handles: {\n        ...state.annotation.data.handles,\n        arrowFirst: true,\n        points: worldCoords\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      metadata,\n      findingSites\n    } = tool;\n    const {\n      finding\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const {\n      points,\n      arrowFirst\n    } = data.handles;\n    const point = arrowFirst ? points[0] : points[1];\n    const point2 = arrowFirst ? points[1] : points[0];\n    const pointImage = toScoord(scoordProps, point);\n    const pointImage2 = toScoord(scoordProps, point2);\n    const TID300RepresentationArguments = {\n      points: [pointImage, pointImage2],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n    return TID300RepresentationArguments;\n  }\n}\n_ArrowAnnotate = ArrowAnnotate;\n(() => {\n  _ArrowAnnotate.init(\"ArrowAnnotate\", TID300Point);\n  _ArrowAnnotate.registerLegacy();\n})();\n\nexport { ArrowAnnotate as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport { toArray } from '../helpers/toArray.js';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\nimport { scoordToWorld } from '../helpers/scoordToWorld.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _Bidirectional;\nconst {\n  Bidirectional: TID300Bidirectional\n} = utilities.TID300;\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nclass Bidirectional extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      scoordArgs,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const {\n      ContentSequence\n    } = MeasurementGroup;\n    const longAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS);\n    const shortAxisNUMGroup = toArray(ContentSequence).find(group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS);\n    const longAxisScoordGroup = toArray(longAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\" || group.ValueType === \"SCOORD\");\n    const shortAxisScoordGroup = toArray(shortAxisNUMGroup.ContentSequence).find(group => group.ValueType === \"SCOORD3D\" || group.ValueType === \"SCOORD\");\n    const worldCoords = [];\n    worldCoords.push(...scoordToWorld(scoordArgs, longAxisScoordGroup));\n    worldCoords.push(...scoordToWorld(scoordArgs, shortAxisScoordGroup));\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]]\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    if (referencedImageId) {\n      state.annotation.data.cachedStats = {\n        [`imageId:${referencedImageId}`]: {\n          length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n          width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        }\n      };\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const {\n      points\n    } = handles;\n    const firstPointPairs = [points[0], points[1]];\n    const secondPointPairs = [points[2], points[3]];\n    const firstPointPairsDistance = Math.sqrt(Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) + Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) + Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2));\n    const secondPointPairsDistance = Math.sqrt(Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) + Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) + Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2));\n    let shortAxisPoints;\n    let longAxisPoints;\n    if (firstPointPairsDistance > secondPointPairsDistance) {\n      shortAxisPoints = firstPointPairs;\n      longAxisPoints = secondPointPairs;\n    } else {\n      shortAxisPoints = secondPointPairs;\n      longAxisPoints = firstPointPairs;\n    }\n    const longAxisStartImage = toScoord(scoordProps, shortAxisPoints[0]);\n    const longAxisEndImage = toScoord(scoordProps, shortAxisPoints[1]);\n    const shortAxisStartImage = toScoord(scoordProps, longAxisPoints[0]);\n    const shortAxisEndImage = toScoord(scoordProps, longAxisPoints[1]);\n    const {\n      length,\n      width\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      longAxis: {\n        point1: longAxisStartImage,\n        point2: longAxisEndImage\n      },\n      shortAxis: {\n        point1: shortAxisStartImage,\n        point2: shortAxisEndImage\n      },\n      longAxisLength: length,\n      shortAxisLength: width,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding: finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_Bidirectional = Bidirectional;\n(() => {\n  _Bidirectional.init(\"Bidirectional\", TID300Bidirectional);\n  _Bidirectional.registerLegacy();\n})();\n\nexport { Bidirectional as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _Angle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass Angle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      NUMGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const cachedStats = referencedImageId ? {\n      [`imageId:${referencedImageId}`]: {\n        angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n      }\n    } : {};\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: [worldCoords[0], worldCoords[1], worldCoords[3]]\n      },\n      cachedStats,\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const point1 = toScoord(scoordProps, handles.points[0]);\n    const point2 = toScoord(scoordProps, handles.points[1]);\n    const point3 = toScoord(scoordProps, handles.points[1]);\n    const point4 = toScoord(scoordProps, handles.points[2]);\n    const angle = cachedStats[`imageId:${referencedImageId}`]?.angle;\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_Angle = Angle;\n(() => {\n  _Angle.init(\"Angle\", TID300CobbAngle);\n  _Angle.registerLegacy();\n})();\n\nexport { Angle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoords } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _CobbAngle;\nconst {\n  CobbAngle: TID300CobbAngle\n} = utilities.TID300;\nclass CobbAngle extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      NUMGroup,\n      referencedImageId,\n      worldCoords,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CobbAngle.toolType);\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: [worldCoords[0], worldCoords[1], worldCoords[2], worldCoords[3]]\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    if (referencedImageId) {\n      state.annotation.data.cachedStats = {\n        [`imageId:${referencedImageId}`]: {\n          angle: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      };\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const points = toScoords(scoordProps, handles.points);\n    const [point1, point2, point3, point4] = points;\n    const {\n      angle\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      point3,\n      point4,\n      rAngle: angle,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_CobbAngle = CobbAngle;\n(() => {\n  _CobbAngle.init(\"CobbAngle\", TID300CobbAngle);\n  _CobbAngle.registerLegacy();\n})();\n\nexport { CobbAngle as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _CircleROI;\nconst {\n  Circle: TID300Circle\n} = utilities.TID300;\nclass CircleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      NUMGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: worldCoords\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    if (referencedImageId) {\n      state.annotation.data.cachedStats = {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n          radius: 0,\n          perimeter: 0\n        }\n      };\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const center = toScoord(scoordProps, handles.points[0]);\n    const end = toScoord(scoordProps, handles.points[1]);\n    const {\n      area,\n      radius\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    const perimeter = 2 * Math.PI * radius;\n    return {\n      area,\n      perimeter,\n      radius,\n      points: [center, end],\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_CircleROI = CircleROI;\n(() => {\n  _CircleROI.init(\"CircleROI\", TID300Circle);\n  _CircleROI.registerLegacy();\n})();\n\nexport { CircleROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _EllipticalROI;\nconst {\n  Ellipse: TID300Ellipse\n} = utilities.TID300;\nclass EllipticalROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      NUMGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, EllipticalROI.toolType);\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: worldCoords\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    state.annotation.data.cachedStats = referencedImageId ? {\n      [`imageId:${referencedImageId}`]: {\n        area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      }\n    } : {};\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const rotation = data.initialRotation || 0;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    let top, bottom, left, right;\n    if (rotation == 90 || rotation == 270) {\n      bottom = handles.points[2];\n      top = handles.points[3];\n      left = handles.points[0];\n      right = handles.points[1];\n    } else {\n      top = handles.points[0];\n      bottom = handles.points[1];\n      left = handles.points[2];\n      right = handles.points[3];\n    }\n    const topBottomLength = Math.sqrt((top[0] - bottom[0]) ** 2 + (top[1] - bottom[1]) ** 2 + (top[2] - bottom[2]) ** 2);\n    const leftRightLength = Math.sqrt((left[0] - right[0]) ** 2 + (left[1] - right[1]) ** 2 + (left[2] - right[2]) ** 2);\n    const points = [];\n    if (topBottomLength > leftRightLength) {\n      points.push(top, bottom, left, right);\n    } else {\n      points.push(left, right, top, bottom);\n    }\n    const {\n      area\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    const convertedPoints = points.map(point => toScoord(scoordProps, point));\n    return {\n      area,\n      points: convertedPoints,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_EllipticalROI = EllipticalROI;\n_EllipticalROI.init(\"EllipticalROI\", TID300Ellipse);\n\nexport { EllipticalROI as default };\n","import { utilities } from 'dcmjs';\nimport 'buffer';\nimport { toScoords } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _RectangleROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass RectangleROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const areaGroup = MeasurementGroup.ContentSequence.find(g => g.ValueType === \"NUM\" && g.ConceptNameCodeSequence[0].CodeMeaning === \"Area\");\n    const cachedStats = referencedImageId ? {\n      [`imageId:${referencedImageId}`]: {\n        area: areaGroup?.MeasuredValueSequence?.[0]?.NumericValue || 0,\n        areaUnit: areaGroup?.MeasuredValueSequence?.[0]?.MeasurementUnitsCodeSequence?.CodeValue\n      }\n    } : {};\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: [worldCoords[0], worldCoords[1], worldCoords[3], worldCoords[2]]\n      },\n      cachedStats,\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const corners = toScoords(scoordProps, data.handles.points);\n    const {\n      area,\n      perimeter\n    } = data.cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      points: [corners[0], corners[1], corners[3], corners[2], corners[0]],\n      area,\n      perimeter,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_RectangleROI = RectangleROI;\n(() => {\n  _RectangleROI.init(\"RectangleROI\", TID300Polyline);\n  _RectangleROI.registerLegacy();\n})();\n\nexport { RectangleROI, RectangleROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoord } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _Length;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst LENGTH = \"Length\";\nclass Length extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      NUMGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const cachedStats = referencedImageId ? {\n      [`imageId:${referencedImageId}`]: {\n        length: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n      }\n    } : {};\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: [worldCoords[0], worldCoords[1]],\n        activeHandleIndex: 0\n      },\n      cachedStats,\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      cachedStats = {},\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const point1 = toScoord(scoordProps, handles.points[0]);\n    const point2 = toScoord(scoordProps, handles.points[1]);\n    const {\n      length: distance\n    } = cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      point1,\n      point2,\n      distance,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_Length = Length;\n(() => {\n  _Length.init(LENGTH, TID300Length);\n  _Length.registerLegacy();\n})();\n\nexport { Length as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport { utilities } from 'dcmjs';\nimport { vec3 } from 'gl-matrix';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoords } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _PlanarFreehandROI;\nconst {\n  Polyline: TID300Polyline\n} = utilities.TID300;\nclass PlanarFreehandROI extends BaseAdapter3D {\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      NUMGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n    let isOpenContour = true;\n    if (distanceBetweenFirstAndLastPoint < this.closedContourThreshold) {\n      worldCoords.pop();\n      isOpenContour = false;\n    }\n    const points = [];\n    if (isOpenContour) {\n      points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n    }\n    state.annotation.data = {\n      ...state.annotation.data,\n      contour: {\n        polyline: worldCoords,\n        closed: !isOpenContour\n      },\n      handles: {\n        ...state.annotation.data.handles,\n        points\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    if (referencedImageId) {\n      state.annotation.data.cachedStats = {\n        [`imageId:${referencedImageId}`]: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : null\n        }\n      };\n    }\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      polyline,\n      closed\n    } = data.contour;\n    const isOpenContour = closed !== true;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const points = toScoords(scoordProps, polyline);\n    if (!isOpenContour) {\n      const firstPoint = points[0];\n      points.push(firstPoint);\n    }\n    const {\n      area,\n      areaUnit,\n      modalityUnit,\n      perimeter,\n      mean,\n      max,\n      stdDev\n    } = data.cachedStats[`imageId:${referencedImageId}`] || {};\n    return {\n      points,\n      area,\n      areaUnit,\n      perimeter,\n      modalityUnit,\n      mean,\n      max,\n      stdDev,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || [],\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_PlanarFreehandROI = PlanarFreehandROI;\n_PlanarFreehandROI.closedContourThreshold = 1e-5;\n_PlanarFreehandROI.init(\"PlanarFreehandROI\", TID300Polyline);\n\nexport { PlanarFreehandROI as default };\n","import { utilities } from 'dcmjs';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport 'buffer';\nimport { toScoords } from '../helpers/toScoordType.js';\nimport '@cornerstonejs/core';\n\nvar _Probe;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass Probe extends BaseAdapter3D {\n  static isValidMeasurement(measurement) {\n    const graphicItem = this.getGraphicItem(measurement);\n    return this.getGraphicType(graphicItem) === \"POINT\" && this.getPointsCount(graphicItem) <= 2;\n  }\n  static getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, _trackingIdentifier) {\n    const {\n      state,\n      NUMGroup,\n      worldCoords,\n      referencedImageId,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    const cachedStats = referencedImageId ? {\n      [`imageId:${referencedImageId}`]: {\n        value: NUMGroup?.MeasuredValueSequence?.NumericValue ?? null\n      }\n    } : {};\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: worldCoords\n      },\n      cachedStats,\n      frameNumber: ReferencedFrameNumber,\n      invalidated: true\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool) {\n    let is3DMeasurement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      data,\n      metadata\n    } = tool;\n    const {\n      finding,\n      findingSites\n    } = tool;\n    const {\n      referencedImageId\n    } = metadata;\n    const scoordProps = {\n      is3DMeasurement,\n      referencedImageId\n    };\n    const {\n      handles: {\n        points = []\n      }\n    } = data;\n    const pointsImage = toScoords(scoordProps, points);\n    return {\n      points: pointsImage,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      findingSites: findingSites || [],\n      finding,\n      ReferencedFrameOfReferenceUID: is3DMeasurement ? metadata.FrameOfReferenceUID : null,\n      use3DSpatialCoordinates: is3DMeasurement\n    };\n  }\n}\n_Probe = Probe;\n(() => {\n  _Probe.init(\"Probe\", TID300Point);\n  _Probe.registerLegacy();\n  _Probe.registerType(\"DCM:111030\", \"POINT\", 1);\n  _Probe.registerType(\"DCM:111030\", \"POINT\", 2);\n})();\n\nexport { Probe as default };\n","import { utilities } from 'dcmjs';\nimport { utilities as utilities$1 } from '@cornerstonejs/core';\nimport MeasurementReport from './MeasurementReport.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\n\nvar _UltrasoundDirectional;\nconst {\n  Length: TID300Length\n} = utilities.TID300;\nconst {\n  worldToImageCoords\n} = utilities$1;\nclass UltrasoundDirectional extends BaseAdapter3D {\n  static getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, metadata) {\n    const {\n      state,\n      worldCoords,\n      ReferencedFrameNumber\n    } = MeasurementReport.getSetupMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, metadata, this.toolType);\n    state.annotation.data = {\n      ...state.annotation.data,\n      handles: {\n        ...state.annotation.data.handles,\n        points: worldCoords\n      },\n      frameNumber: ReferencedFrameNumber\n    };\n    return state;\n  }\n  static getTID300RepresentationArguments(tool, is3DMeasurement) {\n    const {\n      data,\n      finding,\n      findingSites,\n      metadata\n    } = tool;\n    const {\n      handles\n    } = data;\n    const {\n      referencedImageId\n    } = metadata;\n    if (!referencedImageId) {\n      throw new Error(\"UltrasoundDirectionalTool.getTID300RepresentationArguments: referencedImageId is not defined\");\n    }\n    const start = worldToImageCoords(referencedImageId, handles.points[0]);\n    const end = worldToImageCoords(referencedImageId, handles.points[1]);\n    const point1 = {\n      x: start[0],\n      y: start[1]\n    };\n    const point2 = {\n      x: end[0],\n      y: end[1]\n    };\n    return {\n      point1,\n      point2,\n      trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n      finding,\n      findingSites: findingSites || []\n    };\n  }\n}\n_UltrasoundDirectional = UltrasoundDirectional;\n_UltrasoundDirectional.init(\"UltrasoundDirectionalTool\", TID300Length);\n\nexport { UltrasoundDirectional as default };\n","import { normalizers, derivations } from 'dcmjs';\nimport { fillSegmentation } from '../../Cornerstone/Segmentation_4X.js';\n\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  Segmentation: SegmentationDerivation\n} = derivations;\nfunction generateSegmentation(images, labelmaps, metadata) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const segmentation = _createMultiframeSegmentationFromReferencedImages(images, metadata, options);\n  return fillSegmentation(segmentation, labelmaps, options);\n}\nfunction _createMultiframeSegmentationFromReferencedImages(images, metadata, options) {\n  const datasets = images.map(image => {\n    const instance = metadata.get(\"instance\", image.imageId);\n    return {\n      ...image,\n      ...instance,\n      SOPClassUID: instance.SopClassUID || instance.SOPClassUID,\n      SOPInstanceUID: instance.SopInstanceUID || instance.SOPInstanceUID,\n      PixelData: image.voxelManager.getScalarData(),\n      _vrMap: {\n        PixelData: \"OW\"\n      },\n      _meta: {}\n    };\n  });\n  const multiframe = Normalizer.normalizeToDataset(datasets);\n  if (!multiframe) {\n    throw new Error(\"Failed to normalize the multiframe dataset, the data is not multi-frame.\");\n  }\n  return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","function generateLabelMaps2DFrom3D(labelmap3D) {\n  const {\n    scalarData,\n    dimensions\n  } = labelmap3D;\n  const labelmaps2D = [];\n  const segmentsOnLabelmap3D = new Set();\n  for (let z = 0; z < dimensions[2]; z++) {\n    const pixelData = scalarData.slice(z * dimensions[0] * dimensions[1], (z + 1) * dimensions[0] * dimensions[1]);\n    const segmentsOnLabelmap = [];\n    for (let i = 0; i < pixelData.length; i++) {\n      const segment = pixelData[i];\n      if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n        segmentsOnLabelmap.push(segment);\n      }\n    }\n    const labelmap2D = {\n      segmentsOnLabelmap,\n      pixelData,\n      rows: dimensions[1],\n      columns: dimensions[0]\n    };\n    if (segmentsOnLabelmap.length === 0) {\n      continue;\n    }\n    segmentsOnLabelmap.forEach(segmentIndex => {\n      segmentsOnLabelmap3D.add(segmentIndex);\n    });\n    labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\n  }\n  labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\n  labelmap3D.labelmaps2D = labelmaps2D;\n  return labelmap3D;\n}\n\nexport { generateLabelMaps2DFrom3D };\n","const checkHasOverlapping = _ref => {\n  let {\n    largerArray,\n    currentTestedArray,\n    newArray\n  } = _ref;\n  return largerArray.some((_, currentImageIndex) => {\n    const originalImagePixelData = currentTestedArray[currentImageIndex];\n    const newImagePixelData = newArray[currentImageIndex];\n    if (!originalImagePixelData || !newImagePixelData) {\n      return false;\n    }\n    return originalImagePixelData.some((originalPixel, currentPixelIndex) => {\n      const newPixel = newImagePixelData[currentPixelIndex];\n      return originalPixel && newPixel;\n    });\n  });\n};\nconst compactMergeSegmentDataWithoutInformationLoss = _ref2 => {\n  let {\n    arrayOfSegmentData,\n    newSegmentData\n  } = _ref2;\n  if (arrayOfSegmentData.length === 0) {\n    arrayOfSegmentData.push(newSegmentData);\n    return;\n  }\n  for (let currentTestedIndex = 0; currentTestedIndex < arrayOfSegmentData.length; currentTestedIndex++) {\n    const currentTestedArray = arrayOfSegmentData[currentTestedIndex];\n    const originalArrayIsLarger = currentTestedArray.length > newSegmentData.length;\n    const largerArray = originalArrayIsLarger ? currentTestedArray : newSegmentData;\n    const hasOverlapping = checkHasOverlapping({\n      currentTestedArray,\n      largerArray,\n      newArray: newSegmentData\n    });\n    if (hasOverlapping) {\n      continue;\n    }\n    largerArray.forEach((_, currentImageIndex) => {\n      const originalImagePixelData = currentTestedArray[currentImageIndex];\n      const newImagePixelData = newSegmentData[currentImageIndex];\n      if (!originalImagePixelData && !newImagePixelData || !newImagePixelData) {\n        return;\n      }\n      if (!originalImagePixelData) {\n        currentTestedArray[currentImageIndex] = newImagePixelData;\n        return;\n      }\n      const mergedPixelData = originalImagePixelData.map((originalPixel, currentPixelIndex) => {\n        const newPixel = newImagePixelData[currentPixelIndex];\n        return originalPixel || newPixel;\n      });\n      currentTestedArray[currentImageIndex] = mergedPixelData;\n    });\n    return;\n  }\n  arrayOfSegmentData.push(newSegmentData);\n};\n\nexport { compactMergeSegmentDataWithoutInformationLoss };\n","import { triggerEvent, eventTarget, imageLoader } from '@cornerstonejs/core';\nimport { utilities as utilities$1 } from '@cornerstonejs/tools';\nimport { utilities, data, normalizers } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport checkOrientation from '../../helpers/checkOrientation.js';\nimport { getValidOrientations, getSegmentMetadata, unpackPixelData, calculateCentroid, readFromUnpackedChunks, alignPixelDataWithSourceData, getSegmentIndex, findReferenceSourceImageId } from '../../Cornerstone/Segmentation_4X.js';\nimport { compactMergeSegmentDataWithoutInformationLoss } from './compactMergeSegData.js';\nimport { Events } from '../../enums/Events.js';\n\nconst {\n  DicomMessage,\n  DicomMetaDictionary\n} = data;\nconst {\n  Normalizer\n} = normalizers;\nconst {\n  decode\n} = utilities.compression;\nconst updateSegmentsOnFrame = _ref => {\n  let {\n    segmentsOnFrame,\n    imageIdIndex,\n    segmentIndex\n  } = _ref;\n  if (!segmentsOnFrame[imageIdIndex]) {\n    segmentsOnFrame[imageIdIndex] = [];\n  }\n  segmentsOnFrame[imageIdIndex].push(segmentIndex);\n};\nconst updateSegmentsPixelIndices = _ref2 => {\n  let {\n    segmentsPixelIndices,\n    segmentIndex,\n    imageIdIndex,\n    indexCache\n  } = _ref2;\n  if (!segmentsPixelIndices.has(segmentIndex)) {\n    segmentsPixelIndices.set(segmentIndex, {});\n  }\n  const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n  segmentIndexObject[imageIdIndex] = indexCache;\n  segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n};\nconst extractInfoFromPerFrameFunctionalGroups = _ref3 => {\n  let {\n    PerFrameFunctionalGroups,\n    sequenceIndex,\n    sopUIDImageIdIndexMap,\n    multiframe\n  } = _ref3;\n  const referencedSOPInstanceUid = PerFrameFunctionalGroups.DerivationImageSequence[0].SourceImageSequence[0].ReferencedSOPInstanceUID;\n  const referencedImageId = sopUIDImageIdIndexMap[referencedSOPInstanceUid];\n  const segmentIndex = getSegmentIndex(multiframe, sequenceIndex);\n  return {\n    referencedSOPInstanceUid,\n    referencedImageId,\n    segmentIndex\n  };\n};\nasync function createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, options) {\n  const {\n    tolerance = 1e-3,\n    TypedArrayConstructor = Uint8Array,\n    maxBytesPerChunk = 199000000\n  } = options;\n  const dicomData = DicomMessage.readFile(arrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n  const multiframe = Normalizer.normalizeToDataset([dataset]);\n  const imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", referencedImageIds[0]);\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", referencedImageIds[0]);\n  const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines] : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n  const validOrientations = getValidOrientations(ImageOrientationPatient);\n  const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  let pixelData;\n  let pixelDataChunks;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    const rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bit packing.\");\n      return;\n    }\n    pixelDataChunks = [pixelData];\n  } else {\n    pixelDataChunks = unpackPixelData(multiframe, {\n      maxBytesPerChunk\n    });\n    if (!pixelDataChunks) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  const orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, referencedImageIds.length], tolerance);\n  const sopUIDImageIdIndexMap = referencedImageIds.reduce((acc, imageId) => {\n    const {\n      sopInstanceUID\n    } = metadataProvider.get(\"generalImageModule\", imageId);\n    acc[sopInstanceUID] = imageId;\n    return acc;\n  }, {});\n  let insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      insertFunction = insertPixelDataPlanar;\n      break;\n    case \"Perpendicular\":\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n  const segmentsOnFrame = [];\n  const imageIdMaps = {\n    indices: {},\n    metadata: {}\n  };\n  const labelMapImages = [];\n  for (let i = 0; i < referencedImageIds.length; i++) {\n    const referenceImageId = referencedImageIds[i];\n    imageIdMaps.indices[referenceImageId] = i;\n    imageIdMaps.metadata[referenceImageId] = metadataProvider.get(\"instance\", referenceImageId);\n    const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referenceImageId);\n    labelMapImages.push(labelMapImage);\n  }\n  const segmentsPixelIndices = new Map();\n  const {\n    hasOverlappingSegments,\n    arrayOfLabelMapImages\n  } = await insertFunction({\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    TypedArrayConstructor\n  });\n  const centroidXYZ = new Map();\n  segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n    const centroids = calculateCentroid(imageIdIndexBufferIndex, multiframe, metadataProvider, referencedImageIds);\n    centroidXYZ.set(segmentIndex, centroids);\n  });\n  return {\n    labelMapImages: arrayOfLabelMapImages,\n    segMetadata,\n    segmentsOnFrame,\n    centroids: centroidXYZ,\n    overlappingSegments: hasOverlappingSegments\n  };\n}\nconst throttledTriggerLoadProgressEvent = utilities$1.throttle(percentComplete => {\n  triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n    percentComplete\n  });\n}, 200);\nfunction insertPixelDataPlanar(_ref4) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref4;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const groupsLen = PerFrameFunctionalGroupsSequence.length;\n  let overlapping = false;\n  return new Promise(resolve => {\n    const percentImagesPerChunk = 0.1;\n    const imagesPerChunk = Math.ceil(groupsLen * percentImagesPerChunk);\n    const processChunk = firstIndex => {\n      for (let i = firstIndex; i < firstIndex + imagesPerChunk && i < groupsLen; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n        const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = readFromUnpackedChunks(pixelDataChunks, i * sliceLength, sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const segmentIndex = getSegmentIndex(multiframe, i);\n        if (segmentIndex === undefined) {\n          throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n        }\n        if (!segmentsPixelIndices.has(segmentIndex)) {\n          segmentsPixelIndices.set(segmentIndex, {});\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, referencedImageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n          return;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const labelmapImage = labelMapImages[imageIdIndex];\n        const labelmap2DView = labelmapImage.getPixelData();\n        const imageVoxelManager = labelmapImage.voxelManager;\n        const data = alignedPixelDataI.data;\n        const indexCache = [];\n        for (let k = 0, len = alignedPixelDataI.data.length; k < len; ++k) {\n          if (data[k]) {\n            for (let x = k; x < len; ++x) {\n              if (data[x]) {\n                if (!overlapping && labelmap2DView[x] !== 0) {\n                  overlapping = true;\n                  return resolve(insertOverlappingPixelDataPlanar({\n                    segmentsOnFrame,\n                    labelMapImages,\n                    pixelDataChunks,\n                    multiframe,\n                    referencedImageIds,\n                    validOrientations,\n                    metadataProvider,\n                    tolerance,\n                    segmentsPixelIndices,\n                    sopUIDImageIdIndexMap,\n                    imageIdMaps\n                  }));\n                }\n                if (imageVoxelManager) {\n                  imageVoxelManager.setAtIndex(x, segmentIndex);\n                } else {\n                  labelmap2DView[x] = segmentIndex;\n                }\n                indexCache.push(x);\n              }\n            }\n            if (!segmentsOnFrame[imageIdIndex]) {\n              segmentsOnFrame[imageIdIndex] = [];\n            }\n            segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            break;\n          }\n        }\n        const segmentIndexObject = segmentsPixelIndices.get(segmentIndex);\n        segmentIndexObject[imageIdIndex] = indexCache;\n        segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n      }\n      const percentComplete = Math.round(firstIndex / groupsLen * 100);\n      throttledTriggerLoadProgressEvent(percentComplete);\n      if (firstIndex < groupsLen) {\n        setTimeout(() => processChunk(firstIndex + imagesPerChunk), 0);\n      } else {\n        resolve({\n          hasOverlappingSegments: false,\n          arrayOfLabelMapImages: [labelMapImages]\n        });\n      }\n    };\n    const processLabelmapChunk = firstIndex => {\n      const pfSeq = multiframe.PerFrameFunctionalGroupsSequence;\n      const sharedPlaneOrientation = multiframe.SharedFunctionalGroupsSequence.PlaneOrientationSequence?.ImageOrientationPatient;\n      for (let i = firstIndex; i < firstIndex + imagesPerChunk && i < groupsLen; i++) {\n        const PerFrameFunctionalGroups = pfSeq[i];\n        const ImageOrientationPatientI = sharedPlaneOrientation || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        const view = pixelDataChunks.subarray(i * sliceLength, (i + 1) * sliceLength);\n        const pixelDataI2D = ndarray(view, [Rows, Columns]);\n        const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          throw new Error(\"Individual Labelmap SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n        }\n        const imageId = findReferenceSourceImageId(multiframe, i, referencedImageIds, metadataProvider, tolerance, sopUIDImageIdIndexMap);\n        if (!imageId) {\n          console.warn(`Image not present in stack, can't import frame : ${i}.`);\n          continue;\n        }\n        const sourceImageMetadata = imageIdMaps.metadata[imageId];\n        if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n          throw new Error(\"Individual Labelmap SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n        }\n        const imageIdIndex = imageIdMaps.indices[imageId];\n        const labelmapImage = labelMapImages[imageIdIndex];\n        const labelmap2DView = labelmapImage.getPixelData();\n        const data = alignedPixelDataI.data;\n        let segmentsOnFrameArr = segmentsOnFrame[imageIdIndex];\n        if (!segmentsOnFrameArr) {\n          segmentsOnFrameArr = [];\n          segmentsOnFrame[imageIdIndex] = segmentsOnFrameArr;\n        }\n        const segSet = new Set(segmentsOnFrameArr);\n        for (let k = 0, len = data.length; k < len; ++k) {\n          const segIdx = data[k];\n          if (segIdx !== 0) {\n            labelmap2DView[k] = segIdx;\n            if (!segSet.has(segIdx)) {\n              segmentsOnFrameArr.push(segIdx);\n              segSet.add(segIdx);\n            }\n            if (!segmentsPixelIndices.has(segIdx)) {\n              segmentsPixelIndices.set(segIdx, {});\n            }\n            const segmentPixelInfo = segmentsPixelIndices.get(segIdx);\n            if (!segmentPixelInfo[imageIdIndex]) {\n              segmentPixelInfo[imageIdIndex] = [];\n            }\n            segmentPixelInfo[imageIdIndex].push(k);\n          }\n        }\n      }\n      const percentComplete = Math.round(firstIndex / groupsLen * 100);\n      throttledTriggerLoadProgressEvent(percentComplete);\n      if (firstIndex < groupsLen) {\n        setTimeout(() => processLabelmapChunk(firstIndex + imagesPerChunk), 0);\n      } else {\n        resolve({\n          hasOverlappingSegments: false,\n          arrayOfLabelMapImages: [labelMapImages]\n        });\n      }\n    };\n    if (multiframe.SegmentationType === \"LABELMAP\") {\n      processLabelmapChunk(0);\n    } else {\n      processChunk(0);\n    }\n  });\n}\nconst getAlignedPixelData = _ref5 => {\n  let {\n    sharedImageOrientationPatient,\n    PerFrameFunctionalGroups,\n    pixelDataChunks,\n    sequenceIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance\n  } = _ref5;\n  const ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  const view = readFromUnpackedChunks(pixelDataChunks, sequenceIndex * sliceLength, sliceLength);\n  const pixelDataI2D = ndarray(view, [Rows, Columns]);\n  const alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n  if (!alignedPixelDataI) {\n    throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n  }\n  return alignedPixelDataI;\n};\nconst checkImageDimensions = _ref6 => {\n  let {\n    metadataProvider,\n    imageId,\n    Rows,\n    Columns\n  } = _ref6;\n  const sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n  if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n    throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n  }\n};\nconst getArrayOfLabelMapImagesWithSegmentData = _ref7 => {\n  let {\n    arrayOfSegmentData,\n    referencedImageIds\n  } = _ref7;\n  let largestArray = [];\n  for (let i = 0; i < arrayOfSegmentData.length; i++) {\n    const segmentData = arrayOfSegmentData[i];\n    if (segmentData.length > largestArray.length) {\n      largestArray = segmentData;\n    }\n  }\n  return arrayOfSegmentData.map(arr => {\n    const labelMapImages = referencedImageIds.map((referencedImageId, i) => {\n      const hasEmptySegmentData = !arr[i];\n      const labelMapImage = imageLoader.createAndCacheDerivedLabelmapImage(referencedImageId);\n      const pixelData = labelMapImage.getPixelData();\n      if (!hasEmptySegmentData) {\n        for (let j = 0; j < pixelData.length; j++) {\n          pixelData[j] = arr[i][j];\n        }\n      }\n      return labelMapImage;\n    }).filter(Boolean);\n    return labelMapImages;\n  });\n};\nfunction insertOverlappingPixelDataPlanar(_ref8) {\n  let {\n    segmentsOnFrame,\n    labelMapImages,\n    pixelDataChunks,\n    multiframe,\n    referencedImageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps\n  } = _ref8;\n  const {\n    SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence,\n    Rows,\n    Columns\n  } = multiframe;\n  const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  const sliceLength = Columns * Rows;\n  const arrayOfSegmentData = getArrayOfSegmentData({\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  });\n  const arrayOfLabelMapImagesWithSegmentData = getArrayOfLabelMapImagesWithSegmentData({\n    arrayOfSegmentData,\n    referencedImageIds\n  });\n  return {\n    arrayOfLabelMapImages: arrayOfLabelMapImagesWithSegmentData,\n    hasOverlappingSegments: true\n  };\n}\nconst getArrayOfSegmentData = _ref9 => {\n  let {\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    tolerance,\n    pixelDataChunks,\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    sharedImageOrientationPatient,\n    segmentsPixelIndices\n  } = _ref9;\n  const arrayOfSegmentData = [];\n  const numberOfSegments = multiframe.SegmentSequence.length;\n  for (let currentSegmentIndex = 1; currentSegmentIndex <= numberOfSegments; ++currentSegmentIndex) {\n    const segmentData = getSegmentData({\n      PerFrameFunctionalGroupsSequence,\n      labelMapImages,\n      sopUIDImageIdIndexMap,\n      multiframe,\n      segmentIndex: currentSegmentIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance,\n      pixelDataChunks,\n      sharedImageOrientationPatient,\n      metadataProvider,\n      imageIdMaps,\n      segmentsOnFrame,\n      segmentsPixelIndices\n    });\n    compactMergeSegmentDataWithoutInformationLoss({\n      arrayOfSegmentData,\n      newSegmentData: segmentData\n    });\n  }\n  return arrayOfSegmentData;\n};\nconst getSegmentData = _ref10 => {\n  let {\n    PerFrameFunctionalGroupsSequence,\n    labelMapImages,\n    sopUIDImageIdIndexMap,\n    multiframe,\n    segmentIndex,\n    sliceLength,\n    Rows,\n    Columns,\n    validOrientations,\n    tolerance,\n    pixelDataChunks,\n    sharedImageOrientationPatient,\n    metadataProvider,\n    imageIdMaps,\n    segmentsOnFrame,\n    segmentsPixelIndices\n  } = _ref10;\n  const segmentData = [];\n  for (let currentLabelMapImageIndex = 0; currentLabelMapImageIndex < labelMapImages.length; currentLabelMapImageIndex++) {\n    const currentLabelMapImage = labelMapImages[currentLabelMapImageIndex];\n    const referencedImageId = currentLabelMapImage.referencedImageId;\n    const PerFrameFunctionalGroupsIndex = PerFrameFunctionalGroupsSequence.findIndex((PerFrameFunctionalGroups, currentSequenceIndex) => {\n      const {\n        segmentIndex: groupsSegmentIndex,\n        referencedImageId: groupsReferenceImageId\n      } = extractInfoFromPerFrameFunctionalGroups({\n        PerFrameFunctionalGroups,\n        sequenceIndex: currentSequenceIndex,\n        sopUIDImageIdIndexMap,\n        multiframe\n      });\n      const isCorrectPerFrameFunctionalGroup = groupsSegmentIndex === segmentIndex && groupsReferenceImageId === currentLabelMapImage.referencedImageId;\n      return isCorrectPerFrameFunctionalGroup;\n    });\n    if (PerFrameFunctionalGroupsIndex === -1) {\n      continue;\n    }\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[PerFrameFunctionalGroupsIndex];\n    const alignedPixelDataI = getAlignedPixelData({\n      sharedImageOrientationPatient,\n      PerFrameFunctionalGroups,\n      pixelDataChunks,\n      sequenceIndex: PerFrameFunctionalGroupsIndex,\n      sliceLength,\n      Rows,\n      Columns,\n      validOrientations,\n      tolerance\n    });\n    checkImageDimensions({\n      metadataProvider,\n      Rows,\n      Columns,\n      imageId: referencedImageId\n    });\n    const indexCache = [];\n    const segmentationDataForImageId = alignedPixelDataI.data.map((pixel, pixelIndex) => {\n      const pixelValue = pixel ? segmentIndex : 0;\n      if (pixelValue) {\n        indexCache.push(pixelIndex);\n      }\n      return pixel ? segmentIndex : 0;\n    });\n    const hasWrittenSegmentationData = indexCache.length > 0;\n    if (hasWrittenSegmentationData) {\n      segmentData[currentLabelMapImageIndex] = segmentationDataForImageId;\n    }\n    const imageIdIndex = imageIdMaps.indices[referencedImageId];\n    updateSegmentsOnFrame({\n      imageIdIndex,\n      segmentIndex,\n      segmentsOnFrame\n    });\n    updateSegmentsPixelIndices({\n      imageIdIndex,\n      segmentIndex,\n      segmentsPixelIndices,\n      indexCache\n    });\n  }\n  return segmentData;\n};\n\nexport { createLabelmapsFromBufferInternal, insertOverlappingPixelDataPlanar, insertPixelDataPlanar };\n","import { generateToolState as generateToolState$1 } from '../../Cornerstone/Segmentation.js';\nimport { createLabelmapsFromBufferInternal } from './labelmapImagesFromBuffer.js';\n\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  let cs3dVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  return generateToolState$1(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance, cs3dVersion);\n}\nfunction createFromDICOMSegBuffer(referencedImageIds, arrayBuffer, _ref) {\n  let {\n    metadataProvider,\n    tolerance = 1e-3\n  } = _ref;\n  return createLabelmapsFromBufferInternal(referencedImageIds, arrayBuffer, metadataProvider, {\n    tolerance\n  });\n}\n\nexport { createFromDICOMSegBuffer, generateToolState };\n","import { CornerstonePMAP } from '../../Cornerstone/index.js';\n\nconst {\n  ParametricMap\n} = CornerstonePMAP;\nconst {\n  generateToolState: generateToolStateCornerstone\n} = ParametricMap;\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  let skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  return generateToolStateCornerstone(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n}\n\nexport { generateToolState };\n","function getReferencedFrameOfReferenceSequence(metadata, metadataProvider, dataset) {\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID\n  } = instance;\n  const {\n    ReferencedSeriesSequence\n  } = dataset;\n  return [{\n    FrameOfReferenceUID,\n    RTReferencedStudySequence: [{\n      ReferencedSOPClassUID: dataset.SOPClassUID,\n      ReferencedSOPInstanceUID: dataset.SOPInstanceUID,\n      RTReferencedSeriesSequence: [{\n        SeriesInstanceUID,\n        ContourImageSequence: [...ReferencedSeriesSequence[0].ReferencedInstanceSequence]\n      }]\n    }]\n  }];\n}\n\nexport { getReferencedFrameOfReferenceSequence as default };\n","function getReferencedSeriesSequence(metadata, _index, metadataProvider, DicomMetadataStore) {\n  // grab imageId from toolData\n  const {\n    referencedImageId: imageId\n  } = metadata;\n  const instance = metadataProvider.get(\"instance\", imageId);\n  const {\n    SeriesInstanceUID,\n    StudyInstanceUID\n  } = instance;\n  const ReferencedSeriesSequence = [];\n  if (SeriesInstanceUID) {\n    const series = DicomMetadataStore.getSeries(StudyInstanceUID, SeriesInstanceUID);\n    const ReferencedSeries = {\n      SeriesInstanceUID,\n      ReferencedInstanceSequence: []\n    };\n    series.instances.forEach(instance => {\n      const {\n        SOPInstanceUID,\n        SOPClassUID\n      } = instance;\n      ReferencedSeries.ReferencedInstanceSequence.push({\n        ReferencedSOPClassUID: SOPClassUID,\n        ReferencedSOPInstanceUID: SOPInstanceUID\n      });\n    });\n    ReferencedSeriesSequence.push(ReferencedSeries);\n  }\n  return ReferencedSeriesSequence;\n}\n\nexport { getReferencedSeriesSequence as default };\n","function getStructureSetModule(contour, index) {\n  const {\n    FrameOfReferenceUID\n  } = contour.metadata;\n  return {\n    ROINumber: index + 1,\n    ROIName: contour.name || `Todo: name ${index + 1}`,\n    ROIDescription: `Todo: description ${index + 1}`,\n    ROIGenerationAlgorithm: \"Todo: algorithm\",\n    ReferencedFrameOfReferenceUID: FrameOfReferenceUID\n  };\n}\n\nexport { getStructureSetModule as default };\n","import { utilities } from '@cornerstonejs/tools';\nimport dcmjs from 'dcmjs';\nimport getPatientModule from './utilities/getPatientModule.js';\nimport getReferencedFrameOfReferenceSequence from './utilities/getReferencedFrameOfReferenceSequence.js';\nimport getReferencedSeriesSequence from './utilities/getReferencedSeriesSequence.js';\nimport getRTROIObservationsSequence from './utilities/getRTROIObservationsSequence.js';\nimport getRTSeriesModule from './utilities/getRTSeriesModule.js';\nimport getStructureSetModule from './utilities/getStructureSetModule.js';\n\nconst {\n  generateContourSetsFromLabelmap,\n  AnnotationToPointData\n} = utilities.contours;\nconst {\n  DicomMetaDictionary\n} = dcmjs.data;\nasync function generateRTSSFromSegmentations(segmentations, metadataProvider, DicomMetadataStore) {\n  const roiContours = [];\n  const contourSets = await generateContourSetsFromLabelmap({\n    segmentations\n  });\n  contourSets.forEach((contourSet, segIndex) => {\n    if (contourSet) {\n      const contourSequence = [];\n      contourSet.sliceContours.forEach(sliceContour => {\n        const sopCommon = metadataProvider.get(\"sopCommonModule\", sliceContour.referencedImageId);\n        const ReferencedSOPClassUID = sopCommon.sopClassUID;\n        const ReferencedSOPInstanceUID = sopCommon.sopInstanceUID;\n        const ContourImageSequence = [{\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID\n        }];\n        const sliceContourPolyData = sliceContour.polyData;\n        sliceContour.contours.forEach((contour, index) => {\n          const ContourGeometricType = contour.type;\n          const NumberOfContourPoints = contour.contourPoints.length;\n          const ContourData = [];\n          contour.contourPoints.forEach(point => {\n            const pointData = sliceContourPolyData.points[point];\n            pointData[0] = +pointData[0].toFixed(2);\n            pointData[1] = +pointData[1].toFixed(2);\n            pointData[2] = +pointData[2].toFixed(2);\n            ContourData.push(pointData[0]);\n            ContourData.push(pointData[1]);\n            ContourData.push(pointData[2]);\n          });\n          contourSequence.push({\n            ContourImageSequence,\n            ContourGeometricType,\n            NumberOfContourPoints,\n            ContourNumber: index + 1,\n            ContourData\n          });\n        });\n      });\n      const segLabel = contourSet.label || `Segment ${segIndex + 1}`;\n      const ROIContour = {\n        name: segLabel,\n        description: segLabel,\n        contourSequence,\n        color: contourSet.color,\n        metadata: contourSet.metadata\n      };\n      roiContours.push(ROIContour);\n    }\n  });\n  const rtMetadata = {\n    name: segmentations.label,\n    label: segmentations.label\n  };\n  const dataset = _initializeDataset(rtMetadata, roiContours[0].metadata, metadataProvider);\n  roiContours.forEach((contour, index) => {\n    const roiContour = {\n      ROIDisplayColor: contour.color || [255, 0, 0],\n      ContourSequence: contour.contourSequence,\n      ReferencedROINumber: index + 1\n    };\n    dataset.StructureSetROISequence.push(getStructureSetModule(contour, index));\n    dataset.ROIContourSequence.push(roiContour);\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(contour.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(contour.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction generateRTSSFromAnnotations(annotations, metadataProvider, DicomMetadataStore) {\n  const rtMetadata = {\n    name: \"RTSS from Annotations\",\n    label: \"RTSS from Annotations\"\n  };\n  const dataset = _initializeDataset(rtMetadata, annotations[0].metadata, metadataProvider);\n  annotations.forEach((annotation, index) => {\n    const ContourSequence = AnnotationToPointData.convert(annotation, index, metadataProvider);\n    dataset.StructureSetROISequence.push(getStructureSetModule(annotation, index));\n    dataset.ROIContourSequence.push(ContourSequence);\n    dataset.RTROIObservationsSequence.push(getRTROIObservationsSequence(annotation, index));\n    dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(annotation.metadata, index, metadataProvider, DicomMetadataStore);\n    dataset.ReferencedFrameOfReferenceSequence = getReferencedFrameOfReferenceSequence(annotation.metadata, metadataProvider, dataset);\n  });\n  const fileMetaInformationVersionArray = new Uint8Array(2);\n  fileMetaInformationVersionArray[1] = 1;\n  const _meta = {\n    FileMetaInformationVersion: {\n      Value: [fileMetaInformationVersionArray.buffer],\n      vr: \"OB\"\n    },\n    TransferSyntaxUID: {\n      Value: [\"1.2.840.10008.1.2.1\"],\n      vr: \"UI\"\n    },\n    ImplementationClassUID: {\n      Value: [DicomMetaDictionary.uid()],\n      vr: \"UI\"\n    },\n    ImplementationVersionName: {\n      Value: [\"dcmjs\"],\n      vr: \"SH\"\n    }\n  };\n  dataset._meta = _meta;\n  dataset.SpecificCharacterSet = \"ISO_IR 192\";\n  return dataset;\n}\nfunction _initializeDataset(rtMetadata, imgMetadata, metadataProvider) {\n  const rtSOPInstanceUID = DicomMetaDictionary.uid();\n  const {\n    referencedImageId: imageId,\n    FrameOfReferenceUID\n  } = imgMetadata;\n  const {\n    studyInstanceUID\n  } = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const patientModule = getPatientModule(imageId, metadataProvider);\n  const rtSeriesModule = getRTSeriesModule(DicomMetaDictionary);\n  return {\n    StructureSetROISequence: [],\n    ROIContourSequence: [],\n    RTROIObservationsSequence: [],\n    ReferencedSeriesSequence: [],\n    ReferencedFrameOfReferenceSequence: [],\n    ...patientModule,\n    ...rtSeriesModule,\n    StudyInstanceUID: studyInstanceUID,\n    SOPClassUID: \"1.2.840.10008.5.1.4.1.1.481.3\",\n    SOPInstanceUID: rtSOPInstanceUID,\n    Manufacturer: \"dcmjs\",\n    Modality: \"RTSTRUCT\",\n    FrameOfReferenceUID,\n    PositionReferenceIndicator: \"\",\n    StructureSetLabel: rtMetadata.label || \"\",\n    StructureSetName: rtMetadata.name || \"\",\n    ReferringPhysicianName: \"\",\n    OperatorsName: \"\",\n    StructureSetDate: DicomMetaDictionary.date(),\n    StructureSetTime: DicomMetaDictionary.time(),\n    _meta: null\n  };\n}\n\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations };\n","function getRTROIObservationsSequence(toolData, index) {\n  return {\n    ObservationNumber: index + 1,\n    ReferencedROINumber: index + 1,\n    RTROIInterpretedType: \"Todo: type\",\n    ROIInterpreter: \"Todo: interpreter\"\n  };\n}\n\nexport { getRTROIObservationsSequence as default };\n","function getPatientModule(imageId, metadataProvider) {\n  const generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", imageId);\n  const generalStudyModule = metadataProvider.get(\"generalStudyModule\", imageId);\n  const patientStudyModule = metadataProvider.get(\"patientStudyModule\", imageId);\n  const patientModule = metadataProvider.get(\"patientModule\", imageId);\n  const patientDemographicModule = metadataProvider.get(\"patientDemographicModule\", imageId);\n  return {\n    Modality: generalSeriesModule.modality,\n    PatientID: patientModule.patientId,\n    PatientName: patientModule.patientName,\n    PatientBirthDate: \"\",\n    PatientAge: patientStudyModule.patientAge,\n    PatientSex: patientDemographicModule.patientSex,\n    PatientWeight: patientStudyModule.patientWeight,\n    StudyDate: generalStudyModule.studyDate,\n    StudyTime: generalStudyModule.studyTime,\n    StudyID: \"ToDo\",\n    AccessionNumber: generalStudyModule.accessionNumber\n  };\n}\n\nexport { getPatientModule as default };\n","function getRTSeriesModule(DicomMetaDictionary) {\n  return {\n    SeriesInstanceUID: DicomMetaDictionary.uid(),\n    // generate a new series instance uid\n    SeriesNumber: \"99\" // Todo:: what should be the series number?\n  };\n}\n\nexport { getRTSeriesModule as default };\n","import { utilities } from '@cornerstonejs/tools';\nexport { generateRTSSFromAnnotations, generateRTSSFromSegmentations } from './RTSS.js';\n\nconst {\n  generateContourSetsFromLabelmap\n} = utilities.contours;\n\nexport { generateContourSetsFromLabelmap };\n","import { utilities } from 'dcmjs';\nimport Probe from './Probe.js';\n\nvar _KeyImage;\nconst {\n  Point: TID300Point\n} = utilities.TID300;\nclass KeyImage extends Probe {\n  static getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, metadata, trackingIdentifier) {\n    const baseData = super.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, metadata, trackingIdentifier);\n    const {\n      data\n    } = baseData.annotation;\n    data.isPoint = trackingIdentifier.indexOf(\"Point\") !== -1;\n    return baseData;\n  }\n  static getTID300RepresentationArguments(tool) {\n    const tid300Arguments = super.getTID300RepresentationArguments(tool);\n    const {\n      data\n    } = tool;\n    if (data.isPoint) {\n      if (data.seriesLevel) {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesPointIdentifier;\n      } else {\n        tid300Arguments.trackingIdentifierTextValue = this.trackingPointIdentifier;\n      }\n    }\n    if (data.seriesLevel) {\n      tid300Arguments.trackingIdentifierTextValue = this.trackingSeriesIdentifier;\n    }\n    if (!tid300Arguments.points.length) {\n      tid300Arguments.points.push({\n        x: 0,\n        y: 0\n      });\n    }\n    return tid300Arguments;\n  }\n}\n_KeyImage = KeyImage;\n_KeyImage.init(\"KeyImage\", TID300Point, {\n  parentType: Probe.toolType\n});\n_KeyImage.trackingSeriesIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Series`;\n_KeyImage.trackingPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:Point`;\n_KeyImage.trackingSeriesPointIdentifier = `${_KeyImage.trackingIdentifierTextValue}:SeriesPoint`;\n\nexport { KeyImage, KeyImage as default };\n","import MeasurementReport from './MeasurementReport.js';\nimport CodingScheme from './CodingScheme.js';\nimport CORNERSTONE_3D_TAG from './cornerstone3DTag.js';\nimport ArrowAnnotate from './ArrowAnnotate.js';\nimport Bidirectional from './Bidirectional.js';\nimport Angle from './Angle.js';\nimport CobbAngle from './CobbAngle.js';\nimport CircleROI from './CircleROI.js';\nimport EllipticalROI from './EllipticalROI.js';\nimport { RectangleROI } from './RectangleROI.js';\nimport Length from './Length.js';\nimport PlanarFreehandROI from './PlanarFreehandROI.js';\nimport Probe from './Probe.js';\nimport UltrasoundDirectional from './UltrasoundDirectional.js';\nimport BaseAdapter3D from './BaseAdapter3D.js';\nimport * as index from './Segmentation/index.js';\nimport * as index$1 from './ParametricMap/index.js';\nimport * as index$2 from './RTStruct/index.js';\nimport KeyImage from './KeyImage.js';\nimport { COMMENT_CODE, NO_IMAGE_ID, TEXT_ANNOTATION_POSITION } from './constants/index.js';\n\nconst Cornerstone3DSR = {\n  BaseAdapter3D,\n  Bidirectional,\n  CobbAngle,\n  Angle,\n  Length,\n  CircleROI,\n  EllipticalROI,\n  RectangleROI,\n  ArrowAnnotate,\n  Probe,\n  PlanarFreehandROI,\n  UltrasoundDirectional,\n  KeyImage,\n  MeasurementReport,\n  CodeScheme: CodingScheme,\n  CORNERSTONE_3D_TAG,\n  COMMENT_CODE,\n  NO_IMAGE_ID,\n  TEXT_ANNOTATION_POSITION\n};\nconst Cornerstone3DSEG = {\n  Segmentation: index\n};\nconst Cornerstone3DPMAP = {\n  ParametricMap: index$1\n};\nconst Cornerstone3DRT = {\n  RTSS: index$2\n};\n\nexport { Cornerstone3DPMAP, Cornerstone3DRT, Cornerstone3DSEG, Cornerstone3DSR };\n","import { data } from 'dcmjs';\n\nconst {\n  Colors,\n  BitArray\n} = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n  const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n  rgba.push(255);\n  return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n  const Zx = x[1] * y[2] - x[2] * y[1];\n  const Zy = x[2] * y[0] - x[0] * y[2];\n  const Zz = x[0] * y[1] - x[1] * y[0];\n  out[0] = Zx;\n  out[1] = Zy;\n  out[2] = Zz;\n}\nfunction norm(x) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  switch (n) {\n    case 1:\n      return Math.abs(x);\n    case 2:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n    case 3:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n    default:\n      {\n        let sum = 0;\n        for (let i = 0; i < n; i++) {\n          sum += x[i] * x[i];\n        }\n        return Math.sqrt(sum);\n      }\n  }\n}\nfunction normalize(x) {\n  const den = norm(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n    x[2] /= den;\n  }\n  return den;\n}\nfunction subtract(a, b, out) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n  const geometry = {};\n  const pixelMeasures = dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  const planeOrientation = dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n  // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n  //\n  // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n  // sort them to obtain the first and last position along the acquisition axis.\n  const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n  const lastFunctionalGroup = PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n  const firstPosition = firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  const lastPosition = lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.origin = firstPosition;\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  geometry.spacing = [pixelMeasures.PixelSpacing[1], pixelMeasures.PixelSpacing[0], pixelMeasures.SpacingBetweenSlices].map(Number);\n  geometry.dimensions = [dataset.Columns, dataset.Rows, PerFrameFunctionalGroups.length].map(Number);\n  const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  const columnStepToPatient = orientation.slice(0, 3);\n  const rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n  geometry.sliceStep = [];\n  subtract(lastPosition, firstPosition, geometry.sliceStep);\n  normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient.concat(rowStepToPatient).concat(geometry.sliceStep);\n  return geometry;\n}\nclass Segmentation {\n  constructor() {}\n\n  /**\n   * Produces an array of Segments from an input DICOM Segmentation dataset\n   *\n   * Segments are returned with Geometry values that can be used to create\n   * VTK Image Data objects.\n   *\n   * @example Example usage to create VTK Volume actors from each segment:\n   *\n   * const actors = [];\n   * const segments = generateToolState(dataset);\n   * segments.forEach(segment => {\n   *   // now make actors using the segment information\n   *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n   *        name: \"Scalars\",\n   *        numberOfComponents: 1,\n   *        values: segment.pixelData,\n   *    });\n   *\n   *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n   *    imageData.getPointData().setScalars(scalarArray);\n   *    imageData.setDimensions(geometry.dimensions);\n   *    imageData.setSpacing(geometry.spacing);\n   *    imageData.setOrigin(geometry.origin);\n   *    imageData.setDirection(geometry.direction);\n   *\n   *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n   *    mapper.setInputData(imageData);\n   *    mapper.setSampleDistance(2.);\n   *\n   *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n   *    actor.setMapper(mapper);\n   *\n   *    actors.push(actor);\n   * });\n   *\n   * @param dataset\n   * @return {{}}\n   */\n  static generateSegments(dataset) {\n    if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n      dataset.SegmentSequence = [dataset.SegmentSequence];\n    }\n    dataset.SegmentSequence.forEach(segment => {\n      // TODO: other interesting fields could be extracted from the segment\n      // TODO: Read SegmentsOverlay field\n      // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n      // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n      // Why was this example converting to RGBA with 0-255 values?\n      const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n      segments[segment.SegmentNumber] = {\n        color,\n        functionalGroups: [],\n        offset: null,\n        size: null,\n        pixelData: null\n      };\n    });\n\n    // make a list of functional groups per segment\n    dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n      const segmentNumber = functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n      segments[segmentNumber].functionalGroups.push(functionalGroup);\n    });\n\n    // determine per-segment index into the pixel data\n    // TODO: only handles one-bit-per pixel\n    const frameSize = Math.ceil(dataset.Rows * dataset.Columns / 8);\n    let nextOffset = 0;\n    Object.keys(segments).forEach(segmentNumber => {\n      const segment = segments[segmentNumber];\n      segment.numberOfFrames = segment.functionalGroups.length;\n      segment.size = segment.numberOfFrames * frameSize;\n      segment.offset = nextOffset;\n      nextOffset = segment.offset + segment.size;\n      const packedSegment = dataset.PixelData.slice(segment.offset, nextOffset);\n      segment.pixelData = BitArray.unpack(packedSegment);\n      const geometry = geometryFromFunctionalGroups(dataset, segment.functionalGroups);\n      segment.geometry = geometry;\n    });\n    return segments;\n  }\n}\n\nexport { Segmentation as default };\n","import Segmentation from './Segmentation.js';\n\nconst VTKjsSEG = {\n  Segmentation\n};\n\nexport { VTKjsSEG };\n","import { CornerstoneSR, CornerstoneSEG, CornerstonePMAP } from './Cornerstone/index.js';\nimport { Cornerstone3DSR, Cornerstone3DSEG, Cornerstone3DPMAP, Cornerstone3DRT } from './Cornerstone3D/index.js';\nimport { VTKjsSEG } from './VTKjs/index.js';\nimport './enums/Events.js';\nimport 'dcmjs';\nimport 'buffer';\nimport '@cornerstonejs/core';\n\nconst adaptersSR = {\n  Cornerstone: CornerstoneSR,\n  Cornerstone3D: Cornerstone3DSR\n};\nconst adaptersSEG = {\n  Cornerstone: CornerstoneSEG,\n  Cornerstone3D: Cornerstone3DSEG,\n  VTKjs: VTKjsSEG\n};\nconst adaptersPMAP = {\n  Cornerstone: CornerstonePMAP,\n  Cornerstone3D: Cornerstone3DPMAP\n};\nconst adaptersRT = {\n  Cornerstone3D: Cornerstone3DRT\n};\n\nexport { adaptersPMAP, adaptersRT, adaptersSEG, adaptersSR };\n","import { data } from 'dcmjs';\nimport { Buffer } from 'buffer';\n\nconst {\n  datasetToDict\n} = data;\nfunction downloadDICOMData(bufferOrDataset, filename) {\n  let blob;\n  if (bufferOrDataset instanceof ArrayBuffer) {\n    blob = new Blob([bufferOrDataset], {\n      type: \"application/dicom\"\n    });\n  } else {\n    if (!bufferOrDataset._meta) {\n      throw new Error(\"Dataset must have a _meta property\");\n    }\n    const buffer = Buffer.from(datasetToDict(bufferOrDataset).write());\n    blob = new Blob([buffer], {\n      type: \"application/dicom\"\n    });\n  }\n  const link = document.createElement(\"a\");\n  link.href = window.URL.createObjectURL(blob);\n  link.download = filename;\n  link.click();\n}\n\nexport { downloadDICOMData };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"CROSSHAIR_TOOL_CENTER_CHANGED\"] = \"CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED\";\n    Events[\"VOLUMECROPPINGCONTROL_TOOL_CHANGED\"] = \"CORNERSTONE_TOOLS_VOLUMECROPPINGCONTROL_TOOL_CHANGED\";\n    Events[\"VOLUMECROPPING_TOOL_CHANGED\"] = \"CORNERSTONE_TOOLS_VOLUMECROPPING_TOOL_CHANGED\";\n    Events[\"STACK_PREFETCH_COMPLETE\"] = \"CORNERSTONE_TOOLS_STACK_PREFETCH_COMPLETE\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_CUT_MERGE_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_CUT_MERGE_PROCESS_COMPLETED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"HISTORY_UNDO\"] = \"CORNERSTONE_TOOLS_HISTORY_UNDO\";\n    Events[\"HISTORY_REDO\"] = \"CORNERSTONE_TOOLS_HISTORY_REDO\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"Labelmap\";\n    SegmentationRepresentations[\"Contour\"] = \"Contour\";\n    SegmentationRepresentations[\"Surface\"] = \"Surface\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"Interpolate\"] = \"interpolate\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"AddPreview\"] = \"addPreview\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n    StrategyCallbacks[\"GetStatistics\"] = \"getStatistics\";\n    StrategyCallbacks[\"EnsureImageVolumeFor3DManipulation\"] = \"ensureImageVolumeFor3DManipulation\";\n    StrategyCallbacks[\"EnsureSegmentationVolumeFor3DManipulation\"] = \"ensureSegmentationVolumeFor3DManipulation\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n    MouseBindings[MouseBindings[\"Wheel\"] = 524288] = \"Wheel\";\n    MouseBindings[MouseBindings[\"Wheel_Primary\"] = 524289] = \"Wheel_Primary\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n    ChangeTypes[\"COMPUTE_STATISTICS\"] = \"Computing Statistics\";\n    ChangeTypes[\"INTERPOLATE_LABELMAP\"] = \"Interpolating Labelmap\";\n    ChangeTypes[\"COMPUTE_LARGEST_BIDIRECTIONAL\"] = \"Computing Largest Bidirectional\";\n    ChangeTypes[\"GENERATE_CONTOUR_SETS\"] = \"Generating Contour Sets\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":["toArray","x","Array","isArray","undefined","codeMeaningEquals","codeMeaningName","contentItem","ConceptNameCodeSequence","CodeMeaning","TID1500","addAccessors","StructuredReport","Normalizer","TID1500MeasurementReport","TID1501MeasurementGroup","DicomMetaDictionary","FINDING","CodingSchemeDesignator","CodeValue","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","group","code","oldCode","MeasurementReport","getSetupMeasurementData","MeasurementGroup","ContentSequence","contentSequenceArr","findingGroup","find","findingSiteGroups","filter","NUMGroup","ValueType","SCOORDGroup","ReferencedSOPSequence","ReferencedSOPInstanceUID","ReferencedFrameNumber","defaultState","sopInstanceUid","frameIndex","complete","finding","ConceptCodeSequence","findingSites","map","fsg","description","findingSite","location","generateReport","toolState","metadataProvider","options","allMeasurementGroups","firstImageId","Object","keys","Error","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","forEach","imageId","sopCommonModule","frameNumber","toolData","toolTypes","ReferencedSOPClassUID","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","measurementGroups","toolType","toolTypeData","toolClass","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","data","length","measurements","tool","adapterClass","args","getTID300RepresentationArguments","ReferencedFrameOfReferenceUID","use3DSpatialCoordinates","metadata","FrameOfReferenceUID","TID300Representation","getTID300ContentItem","getMeasurementGroup","push","concat","tid1500MeasurementReport","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","StudyInstanceUID","SeriesInstanceUID","_meta","FileMetaInformationVersion","Value","buffer","vr","TransferSyntaxUID","ImplementationClassUID","uid","ImplementationVersionName","_vrMap","PixelData","report","dataset","assign","SpecificCharacterSet","generateToolState","hooks","arguments","ContentTemplateSequence","TemplateIdentifier","imagingMeasurementContent","measurementData","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","key","measurementGroup","TrackingIdentifierValue","TextValue","getToolClass","tc","isValidCornerstoneTrackingIdentifier","measurement","getMeasurementData","console","log","registerTool","utilityToolType","MEASUREMENT_BY_TOOLTYPE","CORNERSTONE_4_TAG","Length","TID300Length","TID300","LENGTH","state","MeasuredValueSequence","NumericValue","handles","start","end","textBox","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","y","GraphicData","point1","point2","distance","trackingIdentifierTextValue","TrackingIdentifier","includes","cornerstone4Tag","split","Polyline","TID300Polyline","FreehandRoi","points","active","cachedStats","area","color","invalidated","i","perimeter","Bidirectional","TID300Bidirectional","BIDIRECTIONAL","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","bottomRight","Math","max","highlight","index","perpendicularStart","perpendicularEnd","isCreating","toolName","visible","longAxis","shortAxis","longAxisLength","shortAxisLength","Ellipse","TID300Ellipse","ELLIPTICALROI","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","abs","halfYLength","center","Circle","TID300Circle","CIRCLEROI","CircleRoi","radius","PI","Point","TID300Point","ARROW_ANNOTATE","CORNERSTONEFREETEXT","ArrowAnnotate","TID300RepresentationArguments","label","CobbAngle","TID300CobbAngle","COBB_ANGLE","rAngle","start2","end2","point3","point4","Angle","TID300Angle","ANGLE","middle","RectangleRoi","intermediate","DicomMessage","getDatasetsFromImages","images","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","normalizeToDataset","rotateDirectionCosinesInPlane","flipImageOrientationPatient","flipIOP","flipMatrix2D","rotateMatrix902D","orientation","datasetToBlob","BitArray","Segmentation","SegmentationDerivation","generateSegmentation","brushData","includeSliceSpacing","segments","image0","dims","columns","rows","z","xy","seg","numSegments","_getSegCount","multiframe","_createSegFromImages","referencedFramesPerSegment","segmentIndicies","imageIdSpecificToolState","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","element","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","imageIds","imagePlaneModule","warn","validOrientations","iop","orientations","h","v","iop90","getValidOrientations","rowCosines","columnCosines","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData","SegmentIdentificationSequence","ReferencedSegmentNumber","SourceImageSequence","DerivationImageSequence","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","referencedFrames","pixelDataIndex","brushPixelData","p","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","Number","getImageIdOfReferencedFrame","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","dx","iop1","iop2","checkOrientation","sourceDataDimensions","tolerance","some","operation","utilities","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","Events","encode","decode","compression","generateSegmentationDefaultOptions","rleEncode","fillSegmentation","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","labelmapIndex","labelmap3D","labelmaps2D","labelmap2D","segmentsOnLabelmap","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","frame","findReferenceSourceImageId","frameSegment","sopUIDImageIdIndexMap","PerFrameFunctionalGroup","frameSourceImageSequence","baseImageId","replace","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","segFramePosition","sourceImageMetadata","isMultiframeImage","framePosition","imagePositionPatient","getImageIdOfSourceImagebyGeometry","insertOverlappingPixelDataPlanar","segmentsOnFrame","segmentsOnFrameArray","labelmapBufferArray","TypedArrayConstructor","segmentsPixelIndices","arrayBufferLength","BYTES_PER_ELEMENT","M","m","tempBuffer","slice","tempSegmentsOnFrame","structuredClone","numberOfSegs","segmentIndexToProcess","groupsLen","getSegmentIndex","view","readFromUnpackedChunks","imageIdIndex","findIndex","labelmap2DView","segmentOnFrame","j","len","ArrayBuffer","insertPixelDataPlanar","imageIdMaps","eventTarget","triggerEvent","chunkSize","ceil","shouldTriggerEvent","overlapping","Promise","resolve","processInChunks","min","has","set","indices","byteOffset","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","error","maxBytesPerChunk","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","floor","endByte","chunk","unpackedChunk","getUnpackedChunks","Uint16Array","imageMetadata","offset","mapping","totalBytes","reduce","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","calculateCentroid","imageIdIndexBufferIndex","xAcc","yAcc","zAcc","worldXAcc","worldYAcc","worldZAcc","count","bufferIndices","entries","debug","rowPixelSpacing","columnPixelSpacing","bufferIndex","image","world","async","referencedImageIds","skipOverlapping","pixelDataChunks","acc","insertFunction","frameSegmentsMapping","Map","segmentArray","role","temp2DArray","fill","checkSEGsOverlapping","curr","overlappingSegments","centroidXYZ","centroids","labelmaps3DorBrushData","cornerstoneToolsVersion","imageIdsIndex","CornerstoneSR","CornerstoneSEG","CornerstonePMAP","ParametricMap","TypedArrayClass","Int16Array","Uint32Array","Int32Array","PixelRepresentation","FloatPixelData","Float32Array","DoubleFloatPixelData","Float64Array","getPixelData","Perpendicular","Oblique","sourcePixelData","targetPixelData","constructor","numSlices","sourceSliceDataView","CORNERSTONE_3D_TAG","patientStudyTags","seriesTags","copySeriesTags","src","study","tagKey","value","imageToWorldCoords","scoordToWorld","_ref","scoord","is3DMeasurement","referencedImageId","worldCoords","point","CodingScheme","codeValues","NO_IMAGE_ID","TEXT_ANNOTATION_POSITION","schemeDesignator","meaning","COMMENT_CODE","worldToImageCoords","globalWorldToImageCoords","useWorldToImageCoords","toScoord","toScoords","scoordArgs","sr","valueTypes","coding","LabelData","tid300Item","annotation","this","contentEntries","createQualitativeLabel","filterCornerstoneFreeText","createQualitativeLabelPosition","csLabel","item","splice","relationshipType","RelationshipTypes","CONTAINS","TextContentItem","name","CodedConcept","frameOfReferenceUID","worldPosition","graphicType","GraphicTypes","POINT","graphicData","Scoord3DContentItem","ScoordContentItem","_MeasurementReport","COMMENT","COMMENT_POSITION","tid300Measurement","measurementAdapterByToolType","Measurements","getCornerstoneLabelFromDefaultState","commentGroup","cornersoneFreeTextCodingValue","freeTextLabel","fs","generateDatasetMeta","processSCOORDGroup","sopInstanceUIDToImageIdMap","annotationUID","activeHandleIndex","processSCOORD3DGroup","_ref2","SCOORD3DGroup","flatPoints","n","JSON","stringify","toPoint3","getSpatialCoordinatesState","_ref3","processSpatialCoordinatesGroup","_ref4","commentPositionGroup","textBoxPosition","textBoxCoords","spatialGroup","generateReferencedSOPSequence","_ref5","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","effectiveImageId","getImageIdFromVolume","instance","dsd","generateDerivationSourceDataset","_ref6","referenceToolData","volumeId","volume","cache","getVolume","is3DSR","SOPClassUID","sopClassUIDsByName","Comprehensive3DSR","measurementGroupContentSequence","trackingIdentifierGroup","trackingIdentifierValue","trackingUniqueIdentifierGroup","trackingUniqueIdentifierValue","UID","toolAdapter","getAdapterForTrackingIdentifier","getAdapterForCodeType","TrackingUniqueIdentifier","e","registerName","measurementAdapterByTrackingIdentifier","registerTrackingIdentifier","_len","trackingIdentifiers","_key","identifier","trackingIdentifier","adapter","adapterTest","values","isValidMeasurement","registerAdapterTypes","_len2","types","_key2","type","measurementAdaptersByType","adapters","indexOf","getAdaptersForTypes","graphicCode","pointCount","appendList","list","copyStudyTags","BaseAdapter3D","registerType","getPointsCount","graphicItem","pointSize","getGraphicItems","items","getGraphicItem","getGraphicCode","conceptNameItem","graphicValue","graphicDesignator","getGraphicType","GraphicType","_measurementGroup","init","representation","parentType","Set","alternateTrackingIdentifier","add","registerLegacy","registerSubType","subAdapter","create","startsWith","seriesLevel","_ArrowAnnotate","_trackingIdentifier","text","imagePixelModule","xOffset","yOffset","secondPoint","arrowFirst","scoordProps","_Bidirectional","longAxisScoordGroup","shortAxisScoordGroup","width","firstPointPairs","secondPointPairs","shortAxisPoints","longAxisPoints","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","_Angle","angle","_CobbAngle","_CircleROI","CircleROI","EllipticalROI","rotation","top","bottom","left","right","_RectangleROI","RectangleROI","areaGroup","g","areaUnit","MeasurementUnitsCodeSequence","corners","_Length","_PlanarFreehandROI","PlanarFreehandROI","isOpenContour","closedContourThreshold","pop","contour","polyline","closed","firstPoint","modalityUnit","mean","stdDev","_Probe","Probe","UltrasoundDirectional","SopClassUID","SOPInstanceUID","SopInstanceUID","voxelManager","getScalarData","_createMultiframeSegmentationFromReferencedImages","generateLabelMaps2DFrom3D","scalarData","dimensions","segmentsOnLabelmap3D","from","checkHasOverlapping","largerArray","currentTestedArray","newArray","_","currentImageIndex","originalImagePixelData","newImagePixelData","originalPixel","currentPixelIndex","newPixel","compactMergeSegmentDataWithoutInformationLoss","arrayOfSegmentData","newSegmentData","currentTestedIndex","mergedPixelData","updateSegmentsOnFrame","updateSegmentsPixelIndices","extractInfoFromPerFrameFunctionalGroups","sequenceIndex","referencedSOPInstanceUid","throttledTriggerLoadProgressEvent","labelMapImages","imagesPerChunk","processChunk","firstIndex","labelmapImage","imageVoxelManager","k","setAtIndex","hasOverlappingSegments","arrayOfLabelMapImages","processLabelmapChunk","pfSeq","sharedPlaneOrientation","subarray","segmentsOnFrameArr","segSet","segmentPixelInfo","getAlignedPixelData","checkImageDimensions","getArrayOfLabelMapImagesWithSegmentData","_ref7","largestArray","segmentData","arr","hasEmptySegmentData","labelMapImage","imageLoader","Boolean","_ref8","getArrayOfSegmentData","_ref9","numberOfSegments","currentSegmentIndex","getSegmentData","_ref10","currentLabelMapImageIndex","currentLabelMapImage","PerFrameFunctionalGroupsIndex","currentSequenceIndex","groupsSegmentIndex","groupsReferenceImageId","segmentationDataForImageId","pixel","pixelIndex","createFromDICOMSegBuffer","referenceImageId","createLabelmapsFromBufferInternal","generateToolStateCornerstone","getReferencedFrameOfReferenceSequence","RTReferencedStudySequence","RTReferencedSeriesSequence","ContourImageSequence","ReferencedInstanceSequence","getReferencedSeriesSequence","_index","DicomMetadataStore","series","getSeries","ReferencedSeries","instances","getStructureSetModule","ROINumber","ROIName","ROIDescription","ROIGenerationAlgorithm","generateContourSetsFromLabelmap","AnnotationToPointData","generateRTSSFromSegmentations","segmentations","roiContours","contourSet","segIndex","contourSequence","sliceContours","sliceContour","sopCommon","sliceContourPolyData","polyData","contours","ContourGeometricType","NumberOfContourPoints","contourPoints","ContourData","pointData","toFixed","ContourNumber","segLabel","ROIContour","_initializeDataset","roiContour","ROIDisplayColor","ContourSequence","ReferencedROINumber","StructureSetROISequence","ROIContourSequence","ReferencedFrameOfReferenceSequence","generateRTSSFromAnnotations","annotations","convert","RTROIObservationsSequence","ObservationNumber","RTROIInterpretedType","ROIInterpreter","getRTROIObservationsSequence","rtMetadata","imgMetadata","rtSOPInstanceUID","patientModule","generalStudyModule","patientStudyModule","patientDemographicModule","Modality","modality","PatientID","patientId","PatientName","patientName","PatientBirthDate","PatientAge","patientAge","PatientSex","patientSex","PatientWeight","patientWeight","StudyDate","studyDate","StudyTime","studyTime","StudyID","AccessionNumber","accessionNumber","getPatientModule","rtSeriesModule","SeriesNumber","getRTSeriesModule","Manufacturer","PositionReferenceIndicator","StructureSetLabel","StructureSetName","ReferringPhysicianName","OperatorsName","StructureSetDate","date","StructureSetTime","time","_KeyImage","KeyImage","baseData","super","isPoint","tid300Arguments","trackingSeriesPointIdentifier","trackingPointIdentifier","trackingSeriesIdentifier","Cornerstone3DSR","CodeScheme","Cornerstone3DSEG","Cornerstone3DPMAP","Cornerstone3DRT","RTSS","Colors","normalize","den","sum","norm","adaptersSR","Cornerstone","Cornerstone3D","adaptersSEG","VTKjs","generateSegments","cielab","rgba","dicomlab2RGB","dicomlab2RGBA","RecommendedDisplayCIELabValue","SegmentNumber","functionalGroups","size","functionalGroup","segmentNumber","frameSize","nextOffset","packedSegment","geometry","pixelMeasures","PixelMeasuresSequence","planeOrientation","firstFunctionalGroup","lastFunctionalGroup","firstPosition","lastPosition","origin","spacing","PixelSpacing","SpacingBetweenSlices","columnStepToPatient","rowStepToPatient","a","b","out","planeNormal","Zx","Zy","Zz","cross","sliceStep","direction","geometryFromFunctionalGroups","adaptersPMAP","adaptersRT","datasetToDict","downloadDICOMData","bufferOrDataset","filename","blob","Blob","write","link","document","createElement","href","window","URL","createObjectURL","download","click","ChangeTypes","SegmentationRepresentations","StrategyCallbacks","MouseBindings","KeyboardBindings","ToolModes","Swipe","AnnotationStyleStates","module","exports","obj","isBuffer","iota","hasTypedArrays","compare1st","order","stride","terms","sort","compileConstructor","dtype","dimension","className","join","useGetters","Function","procedure","CACHED_CONSTRUCTORS","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","idx","shape","ctor","array","d","sz","prototype","toString","call","arrayDType","ctor_list"],"sourceRoot":""}